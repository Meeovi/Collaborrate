schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

directive @external on FIELD_DEFINITION

directive @requires(fields: _FieldSet!) on FIELD_DEFINITION

directive @provides(fields: _FieldSet!) on FIELD_DEFINITION

directive @key(fields: _FieldSet!) on OBJECT | INTERFACE

"""The root query type which gives access points into the data universe."""
type Query {
  """Reads and enables pagination through a set of `Endofshift`."""
  allEndofshifts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EndofshiftCondition
  ): EndofshiftsConnection
  """Reads a set of `Endofshift`."""
  allEndofshiftsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EndofshiftCondition
  ): [Endofshift!]
  """Reads and enables pagination through a set of `_Schema`."""
  allSchemas(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `_Schema`."""
    orderBy: [_SchemasOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: _SchemaCondition
  ): _SchemasConnection
  """Reads a set of `_Schema`."""
  allSchemasList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `_Schema`."""
    orderBy: [_SchemasOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: _SchemaCondition
  ): [_Schema!]
  """Reads and enables pagination through a set of `_PrismaMigration`."""
  allPrismaMigrations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: _PrismaMigrationCondition
  ): _PrismaMigrationsConnection
  """Reads a set of `_PrismaMigration`."""
  allPrismaMigrationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: _PrismaMigrationCondition
  ): [_PrismaMigration!]
  """Reads and enables pagination through a set of `Account`."""
  allAccounts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AccountCondition
  ): AccountsConnection
  """Reads a set of `Account`."""
  allAccountsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AccountCondition
  ): [Account!]
  """Reads and enables pagination through a set of `Agreement`."""
  allAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): AgreementsConnection
  """Reads a set of `Agreement`."""
  allAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): [Agreement!]
  """Reads and enables pagination through a set of `Analytic`."""
  allAnalytics(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Analytic`."""
    orderBy: [AnalyticsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AnalyticCondition
  ): AnalyticsConnection
  """Reads a set of `Analytic`."""
  allAnalyticsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Analytic`."""
    orderBy: [AnalyticsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AnalyticCondition
  ): [Analytic!]
  """Reads and enables pagination through a set of `Apitoken`."""
  allApitokens(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ApitokenCondition
  ): ApitokensConnection
  """Reads a set of `Apitoken`."""
  allApitokensList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ApitokenCondition
  ): [Apitoken!]
  """Reads and enables pagination through a set of `Article`."""
  allArticles(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ArticleCondition
  ): ArticlesConnection
  """Reads a set of `Article`."""
  allArticlesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ArticleCondition
  ): [Article!]
  """Reads and enables pagination through a set of `Brand`."""
  allBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): BrandsConnection
  """Reads a set of `Brand`."""
  allBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]
  """Reads and enables pagination through a set of `CartPriceRule`."""
  allCartPriceRules(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CartPriceRule`."""
    orderBy: [CartPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CartPriceRuleCondition
  ): CartPriceRulesConnection
  """Reads a set of `CartPriceRule`."""
  allCartPriceRulesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CartPriceRule`."""
    orderBy: [CartPriceRulesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CartPriceRuleCondition
  ): [CartPriceRule!]
  """Reads and enables pagination through a set of `Case`."""
  allCases(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Case`."""
    orderBy: [CasesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CaseCondition
  ): CasesConnection
  """Reads a set of `Case`."""
  allCasesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Case`."""
    orderBy: [CasesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CaseCondition
  ): [Case!]
  """Reads and enables pagination through a set of `CatalogPriceRule`."""
  allCatalogPriceRules(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CatalogPriceRule`."""
    orderBy: [CatalogPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CatalogPriceRuleCondition
  ): CatalogPriceRulesConnection
  """Reads a set of `CatalogPriceRule`."""
  allCatalogPriceRulesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CatalogPriceRule`."""
    orderBy: [CatalogPriceRulesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CatalogPriceRuleCondition
  ): [CatalogPriceRule!]
  """Reads and enables pagination through a set of `Category`."""
  allCategories(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): CategoriesConnection
  """Reads a set of `Category`."""
  allCategoriesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): [Category!]
  """Reads and enables pagination through a set of `Channel`."""
  allChannels(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChannelCondition
  ): ChannelsConnection
  """Reads a set of `Channel`."""
  allChannelsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChannelCondition
  ): [Channel!]
  """Reads and enables pagination through a set of `Checklist`."""
  allChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): ChecklistsConnection
  """Reads a set of `Checklist`."""
  allChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): [Checklist!]
  """Reads and enables pagination through a set of `City`."""
  allCities(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CityCondition
  ): CitiesConnection
  """Reads a set of `City`."""
  allCitiesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CityCondition
  ): [City!]
  """Reads and enables pagination through a set of `Collection`."""
  allCollections(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CollectionCondition
  ): CollectionsConnection
  """Reads a set of `Collection`."""
  allCollectionsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CollectionCondition
  ): [Collection!]
  """Reads and enables pagination through a set of `Comment`."""
  allComments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): CommentsConnection
  """Reads a set of `Comment`."""
  allCommentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]
  """Reads and enables pagination through a set of `ContentType`."""
  allContentTypes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ContentTypeCondition
  ): ContentTypesConnection
  """Reads a set of `ContentType`."""
  allContentTypesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ContentTypeCondition
  ): [ContentType!]
  """Reads and enables pagination through a set of `Contract`."""
  allContracts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Contract`."""
    orderBy: [ContractsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ContractCondition
  ): ContractsConnection
  """Reads a set of `Contract`."""
  allContractsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Contract`."""
    orderBy: [ContractsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ContractCondition
  ): [Contract!]
  """Reads and enables pagination through a set of `Country`."""
  allCountries(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): CountriesConnection
  """Reads a set of `Country`."""
  allCountriesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): [Country!]
  """Reads and enables pagination through a set of `Coupon`."""
  allCoupons(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CouponCondition
  ): CouponsConnection
  """Reads a set of `Coupon`."""
  allCouponsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CouponCondition
  ): [Coupon!]
  """Reads and enables pagination through a set of `CreditMemo`."""
  allCreditMemos(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): CreditMemosConnection
  """Reads a set of `CreditMemo`."""
  allCreditMemosList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): [CreditMemo!]
  """Reads and enables pagination through a set of `Currency`."""
  allCurrencies(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencyCondition
  ): CurrenciesConnection
  """Reads a set of `Currency`."""
  allCurrenciesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencyCondition
  ): [Currency!]
  """Reads and enables pagination through a set of `CurrencyRate`."""
  allCurrencyRates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CurrencyRate`."""
    orderBy: [CurrencyRatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencyRateCondition
  ): CurrencyRatesConnection
  """Reads a set of `CurrencyRate`."""
  allCurrencyRatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CurrencyRate`."""
    orderBy: [CurrencyRatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencyRateCondition
  ): [CurrencyRate!]
  """Reads and enables pagination through a set of `CurrencySymbol`."""
  allCurrencySymbols(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CurrencySymbol`."""
    orderBy: [CurrencySymbolsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencySymbolCondition
  ): CurrencySymbolsConnection
  """Reads a set of `CurrencySymbol`."""
  allCurrencySymbolsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CurrencySymbol`."""
    orderBy: [CurrencySymbolsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencySymbolCondition
  ): [CurrencySymbol!]
  """Reads and enables pagination through a set of `CustomerGroup`."""
  allCustomerGroups(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CustomerGroup`."""
    orderBy: [CustomerGroupsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerGroupCondition
  ): CustomerGroupsConnection
  """Reads a set of `CustomerGroup`."""
  allCustomerGroupsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CustomerGroup`."""
    orderBy: [CustomerGroupsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerGroupCondition
  ): [CustomerGroup!]
  """Reads and enables pagination through a set of `CustomerPayment`."""
  allCustomerPayments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerPaymentCondition
  ): CustomerPaymentsConnection
  """Reads a set of `CustomerPayment`."""
  allCustomerPaymentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerPaymentCondition
  ): [CustomerPayment!]
  """Reads and enables pagination through a set of `Customer`."""
  allCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): CustomersConnection
  """Reads a set of `Customer`."""
  allCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]
  """Reads and enables pagination through a set of `Customization`."""
  allCustomizations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customization`."""
    orderBy: [CustomizationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomizationCondition
  ): CustomizationsConnection
  """Reads a set of `Customization`."""
  allCustomizationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customization`."""
    orderBy: [CustomizationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomizationCondition
  ): [Customization!]
  """Reads and enables pagination through a set of `Dashboard`."""
  allDashboards(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: DashboardCondition
  ): DashboardsConnection
  """Reads a set of `Dashboard`."""
  allDashboardsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: DashboardCondition
  ): [Dashboard!]
  """Reads and enables pagination through a set of `Deepdive`."""
  allDeepdives(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: DeepdiveCondition
  ): DeepdivesConnection
  """Reads a set of `Deepdive`."""
  allDeepdivesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: DeepdiveCondition
  ): [Deepdive!]
  """Reads and enables pagination through a set of `EmailTemplate`."""
  allEmailTemplates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `EmailTemplate`."""
    orderBy: [EmailTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailTemplateCondition
  ): EmailTemplatesConnection
  """Reads a set of `EmailTemplate`."""
  allEmailTemplatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `EmailTemplate`."""
    orderBy: [EmailTemplatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailTemplateCondition
  ): [EmailTemplate!]
  """Reads and enables pagination through a set of `Email`."""
  allEmails(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): EmailsConnection
  """Reads a set of `Email`."""
  allEmailsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): [Email!]
  """Reads and enables pagination through a set of `Event`."""
  allEvents(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EventCondition
  ): EventsConnection
  """Reads a set of `Event`."""
  allEventsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EventCondition
  ): [Event!]
  """Reads and enables pagination through a set of `Fullfillment`."""
  allFullfillments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: FullfillmentCondition
  ): FullfillmentsConnection
  """Reads a set of `Fullfillment`."""
  allFullfillmentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: FullfillmentCondition
  ): [Fullfillment!]
  """Reads and enables pagination through a set of `GeneralSetting`."""
  allGeneralSettings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `GeneralSetting`."""
    orderBy: [GeneralSettingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GeneralSettingCondition
  ): GeneralSettingsConnection
  """Reads a set of `GeneralSetting`."""
  allGeneralSettingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `GeneralSetting`."""
    orderBy: [GeneralSettingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GeneralSettingCondition
  ): [GeneralSetting!]
  """Reads and enables pagination through a set of `GiftCertificate`."""
  allGiftCertificates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `GiftCertificate`."""
    orderBy: [GiftCertificatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GiftCertificateCondition
  ): GiftCertificatesConnection
  """Reads a set of `GiftCertificate`."""
  allGiftCertificatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `GiftCertificate`."""
    orderBy: [GiftCertificatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GiftCertificateCondition
  ): [GiftCertificate!]
  """Reads and enables pagination through a set of `Glossary`."""
  allGlossaries(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GlossaryCondition
  ): GlossariesConnection
  """Reads a set of `Glossary`."""
  allGlossariesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GlossaryCondition
  ): [Glossary!]
  """Reads and enables pagination through a set of `Importm`."""
  allImportms(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Importm`."""
    orderBy: [ImportmsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ImportmCondition
  ): ImportmsConnection
  """Reads a set of `Importm`."""
  allImportmsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Importm`."""
    orderBy: [ImportmsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ImportmCondition
  ): [Importm!]
  """Reads and enables pagination through a set of `Integration`."""
  allIntegrations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: IntegrationCondition
  ): IntegrationsConnection
  """Reads a set of `Integration`."""
  allIntegrationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: IntegrationCondition
  ): [Integration!]
  """Reads and enables pagination through a set of `Internalization`."""
  allInternalizations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InternalizationCondition
  ): InternalizationsConnection
  """Reads a set of `Internalization`."""
  allInternalizationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InternalizationCondition
  ): [Internalization!]
  """Reads and enables pagination through a set of `Invitation`."""
  allInvitations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Invitation`."""
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InvitationCondition
  ): InvitationsConnection
  """Reads a set of `Invitation`."""
  allInvitationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Invitation`."""
    orderBy: [InvitationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InvitationCondition
  ): [Invitation!]
  """Reads and enables pagination through a set of `Invoice`."""
  allInvoices(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InvoiceCondition
  ): InvoicesConnection
  """Reads a set of `Invoice`."""
  allInvoicesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InvoiceCondition
  ): [Invoice!]
  """Reads and enables pagination through a set of `Knowledgebase`."""
  allKnowledgebases(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Knowledgebase`."""
    orderBy: [KnowledgebasesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: KnowledgebaseCondition
  ): KnowledgebasesConnection
  """Reads a set of `Knowledgebase`."""
  allKnowledgebasesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Knowledgebase`."""
    orderBy: [KnowledgebasesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: KnowledgebaseCondition
  ): [Knowledgebase!]
  """Reads and enables pagination through a set of `Lead`."""
  allLeads(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Lead`."""
    orderBy: [LeadsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: LeadCondition
  ): LeadsConnection
  """Reads a set of `Lead`."""
  allLeadsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Lead`."""
    orderBy: [LeadsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: LeadCondition
  ): [Lead!]
  """Reads and enables pagination through a set of `Manufacturer`."""
  allManufacturers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ManufacturerCondition
  ): ManufacturersConnection
  """Reads a set of `Manufacturer`."""
  allManufacturersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ManufacturerCondition
  ): [Manufacturer!]
  """Reads and enables pagination through a set of `Mediamanager`."""
  allMediamanagers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection
  """Reads a set of `Mediamanager`."""
  allMediamanagersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]
  """Reads and enables pagination through a set of `Meeting`."""
  allMeetings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MeetingCondition
  ): MeetingsConnection
  """Reads a set of `Meeting`."""
  allMeetingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MeetingCondition
  ): [Meeting!]
  """Reads and enables pagination through a set of `Message`."""
  allMessages(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): MessagesConnection
  """Reads a set of `Message`."""
  allMessagesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): [Message!]
  """Reads and enables pagination through a set of `NewsletterSubscriber`."""
  allNewsletterSubscribers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `NewsletterSubscriber`."""
    orderBy: [NewsletterSubscribersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: NewsletterSubscriberCondition
  ): NewsletterSubscribersConnection
  """Reads a set of `NewsletterSubscriber`."""
  allNewsletterSubscribersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `NewsletterSubscriber`."""
    orderBy: [NewsletterSubscribersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: NewsletterSubscriberCondition
  ): [NewsletterSubscriber!]
  """Reads and enables pagination through a set of `Occassion`."""
  allOccassions(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): OccassionsConnection
  """Reads a set of `Occassion`."""
  allOccassionsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): [Occassion!]
  """Reads and enables pagination through a set of `Ooto`."""
  allOotos(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OotoCondition
  ): OotosConnection
  """Reads a set of `Ooto`."""
  allOotosList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OotoCondition
  ): [Ooto!]
  """Reads and enables pagination through a set of `Opportunity`."""
  allOpportunities(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Opportunity`."""
    orderBy: [OpportunitiesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OpportunityCondition
  ): OpportunitiesConnection
  """Reads a set of `Opportunity`."""
  allOpportunitiesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Opportunity`."""
    orderBy: [OpportunitiesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OpportunityCondition
  ): [Opportunity!]
  """Reads and enables pagination through a set of `Order`."""
  allOrders(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): OrdersConnection
  """Reads a set of `Order`."""
  allOrdersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): [Order!]
  """Reads and enables pagination through a set of `Page`."""
  allPages(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PageCondition
  ): PagesConnection
  """Reads a set of `Page`."""
  allPagesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PageCondition
  ): [Page!]
  """Reads and enables pagination through a set of `Partner`."""
  allPartners(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PartnerCondition
  ): PartnersConnection
  """Reads a set of `Partner`."""
  allPartnersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PartnerCondition
  ): [Partner!]
  """Reads and enables pagination through a set of `Payment`."""
  allPayments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PaymentCondition
  ): PaymentsConnection
  """Reads a set of `Payment`."""
  allPaymentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PaymentCondition
  ): [Payment!]
  """Reads and enables pagination through a set of `PdfTemplate`."""
  allPdfTemplates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `PdfTemplate`."""
    orderBy: [PdfTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PdfTemplateCondition
  ): PdfTemplatesConnection
  """Reads a set of `PdfTemplate`."""
  allPdfTemplatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `PdfTemplate`."""
    orderBy: [PdfTemplatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PdfTemplateCondition
  ): [PdfTemplate!]
  """Reads and enables pagination through a set of `Permission`."""
  allPermissions(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PermissionCondition
  ): PermissionsConnection
  """Reads a set of `Permission`."""
  allPermissionsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PermissionCondition
  ): [Permission!]
  """Reads and enables pagination through a set of `Plugin`."""
  allPlugins(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PluginCondition
  ): PluginsConnection
  """Reads a set of `Plugin`."""
  allPluginsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PluginCondition
  ): [Plugin!]
  """Reads and enables pagination through a set of `ProductAttribute`."""
  allProductAttributes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ProductAttribute`."""
    orderBy: [ProductAttributesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductAttributeCondition
  ): ProductAttributesConnection
  """Reads a set of `ProductAttribute`."""
  allProductAttributesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ProductAttribute`."""
    orderBy: [ProductAttributesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductAttributeCondition
  ): [ProductAttribute!]
  """Reads and enables pagination through a set of `ProductType`."""
  allProductTypes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductTypeCondition
  ): ProductTypesConnection
  """Reads a set of `ProductType`."""
  allProductTypesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductTypeCondition
  ): [ProductType!]
  """Reads and enables pagination through a set of `Product`."""
  allProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): ProductsConnection
  """Reads a set of `Product`."""
  allProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]
  """Reads and enables pagination through a set of `ProjectTemplate`."""
  allProjectTemplates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ProjectTemplate`."""
    orderBy: [ProjectTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectTemplateCondition
  ): ProjectTemplatesConnection
  """Reads a set of `ProjectTemplate`."""
  allProjectTemplatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ProjectTemplate`."""
    orderBy: [ProjectTemplatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectTemplateCondition
  ): [ProjectTemplate!]
  """Reads and enables pagination through a set of `Project`."""
  allProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection
  """Reads a set of `Project`."""
  allProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]
  """Reads and enables pagination through a set of `Provider`."""
  allProviders(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProviderCondition
  ): ProvidersConnection
  """Reads a set of `Provider`."""
  allProvidersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProviderCondition
  ): [Provider!]
  """Reads and enables pagination through a set of `Quote`."""
  allQuotes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection
  """Reads a set of `Quote`."""
  allQuotesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]
  """Reads and enables pagination through a set of `Rating`."""
  allRatings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Rating`."""
    orderBy: [RatingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RatingCondition
  ): RatingsConnection
  """Reads a set of `Rating`."""
  allRatingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Rating`."""
    orderBy: [RatingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RatingCondition
  ): [Rating!]
  """Reads and enables pagination through a set of `Report`."""
  allReports(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReportCondition
  ): ReportsConnection
  """Reads a set of `Report`."""
  allReportsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReportCondition
  ): [Report!]
  """Reads and enables pagination through a set of `Return`."""
  allReturns(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): ReturnsConnection
  """Reads a set of `Return`."""
  allReturnsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): [Return!]
  """Reads and enables pagination through a set of `Review`."""
  allReviews(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReviewCondition
  ): ReviewsConnection
  """Reads a set of `Review`."""
  allReviewsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReviewCondition
  ): [Review!]
  """Reads and enables pagination through a set of `Reward`."""
  allRewards(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RewardCondition
  ): RewardsConnection
  """Reads a set of `Reward`."""
  allRewardsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RewardCondition
  ): [Reward!]
  """Reads and enables pagination through a set of `Scheduler`."""
  allSchedulers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SchedulerCondition
  ): SchedulersConnection
  """Reads a set of `Scheduler`."""
  allSchedulersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SchedulerCondition
  ): [Scheduler!]
  """Reads and enables pagination through a set of `Segment`."""
  allSegments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SegmentCondition
  ): SegmentsConnection
  """Reads a set of `Segment`."""
  allSegmentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SegmentCondition
  ): [Segment!]
  """Reads and enables pagination through a set of `Settingscustomer`."""
  allSettingscustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingscustomer`."""
    orderBy: [SettingscustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingscustomerCondition
  ): SettingscustomersConnection
  """Reads a set of `Settingscustomer`."""
  allSettingscustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingscustomer`."""
    orderBy: [SettingscustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingscustomerCondition
  ): [Settingscustomer!]
  """Reads and enables pagination through a set of `Settingsgeneral`."""
  allSettingsgenerals(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingsgeneral`."""
    orderBy: [SettingsgeneralsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingsgeneralCondition
  ): SettingsgeneralsConnection
  """Reads a set of `Settingsgeneral`."""
  allSettingsgeneralsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingsgeneral`."""
    orderBy: [SettingsgeneralsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingsgeneralCondition
  ): [Settingsgeneral!]
  """Reads and enables pagination through a set of `Settingshop`."""
  allSettingshops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingshop`."""
    orderBy: [SettingshopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingshopCondition
  ): SettingshopsConnection
  """Reads a set of `Settingshop`."""
  allSettingshopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingshop`."""
    orderBy: [SettingshopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingshopCondition
  ): [Settingshop!]
  """Reads and enables pagination through a set of `Settingsmarketing`."""
  allSettingsmarketings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingsmarketing`."""
    orderBy: [SettingsmarketingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingsmarketingCondition
  ): SettingsmarketingsConnection
  """Reads a set of `Settingsmarketing`."""
  allSettingsmarketingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingsmarketing`."""
    orderBy: [SettingsmarketingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingsmarketingCondition
  ): [Settingsmarketing!]
  """Reads and enables pagination through a set of `Settingssale`."""
  allSettingssales(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingssale`."""
    orderBy: [SettingssalesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingssaleCondition
  ): SettingssalesConnection
  """Reads a set of `Settingssale`."""
  allSettingssalesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingssale`."""
    orderBy: [SettingssalesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingssaleCondition
  ): [Settingssale!]
  """Reads and enables pagination through a set of `Shipment`."""
  allShipments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShipmentCondition
  ): ShipmentsConnection
  """Reads a set of `Shipment`."""
  allShipmentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShipmentCondition
  ): [Shipment!]
  """Reads and enables pagination through a set of `ShopSetting`."""
  allShopSettings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ShopSetting`."""
    orderBy: [ShopSettingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopSettingCondition
  ): ShopSettingsConnection
  """Reads a set of `ShopSetting`."""
  allShopSettingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ShopSetting`."""
    orderBy: [ShopSettingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopSettingCondition
  ): [ShopSetting!]
  """Reads and enables pagination through a set of `Shop`."""
  allShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): ShopsConnection
  """Reads a set of `Shop`."""
  allShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): [Shop!]
  """Reads and enables pagination through a set of `SpecialDiscount`."""
  allSpecialDiscounts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `SpecialDiscount`."""
    orderBy: [SpecialDiscountsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SpecialDiscountCondition
  ): SpecialDiscountsConnection
  """Reads a set of `SpecialDiscount`."""
  allSpecialDiscountsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `SpecialDiscount`."""
    orderBy: [SpecialDiscountsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SpecialDiscountCondition
  ): [SpecialDiscount!]
  """Reads and enables pagination through a set of `State`."""
  allStates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): StatesConnection
  """Reads a set of `State`."""
  allStatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): [State!]
  """Reads and enables pagination through a set of `Statistic`."""
  allStatistics(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Statistic`."""
    orderBy: [StatisticsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StatisticCondition
  ): StatisticsConnection
  """Reads a set of `Statistic`."""
  allStatisticsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Statistic`."""
    orderBy: [StatisticsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StatisticCondition
  ): [Statistic!]
  """Reads and enables pagination through a set of `Stock`."""
  allStocks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Stock`."""
    orderBy: [StocksOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StockCondition
  ): StocksConnection
  """Reads a set of `Stock`."""
  allStocksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Stock`."""
    orderBy: [StocksOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StockCondition
  ): [Stock!]
  """Reads and enables pagination through a set of `Survey`."""
  allSurveys(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Survey`."""
    orderBy: [SurveysOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SurveyCondition
  ): SurveysConnection
  """Reads a set of `Survey`."""
  allSurveysList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Survey`."""
    orderBy: [SurveysOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SurveyCondition
  ): [Survey!]
  """Reads and enables pagination through a set of `Tag`."""
  allTags(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TagCondition
  ): TagsConnection
  """Reads a set of `Tag`."""
  allTagsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TagCondition
  ): [Tag!]
  """Reads and enables pagination through a set of `Target`."""
  allTargets(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Target`."""
    orderBy: [TargetsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TargetCondition
  ): TargetsConnection
  """Reads a set of `Target`."""
  allTargetsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Target`."""
    orderBy: [TargetsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TargetCondition
  ): [Target!]
  """Reads and enables pagination through a set of `TaxCategory`."""
  allTaxCategories(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TaxCategory`."""
    orderBy: [TaxCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxCategoryCondition
  ): TaxCategoriesConnection
  """Reads a set of `TaxCategory`."""
  allTaxCategoriesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TaxCategory`."""
    orderBy: [TaxCategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxCategoryCondition
  ): [TaxCategory!]
  """Reads and enables pagination through a set of `TaxRate`."""
  allTaxRates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TaxRate`."""
    orderBy: [TaxRatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRateCondition
  ): TaxRatesConnection
  """Reads a set of `TaxRate`."""
  allTaxRatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TaxRate`."""
    orderBy: [TaxRatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRateCondition
  ): [TaxRate!]
  """Reads and enables pagination through a set of `TaxRule`."""
  allTaxRules(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TaxRule`."""
    orderBy: [TaxRulesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRuleCondition
  ): TaxRulesConnection
  """Reads a set of `TaxRule`."""
  allTaxRulesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TaxRule`."""
    orderBy: [TaxRulesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRuleCondition
  ): [TaxRule!]
  """Reads and enables pagination through a set of `Theme`."""
  allThemes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ThemeCondition
  ): ThemesConnection
  """Reads a set of `Theme`."""
  allThemesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ThemeCondition
  ): [Theme!]
  """Reads and enables pagination through a set of `Ticketing`."""
  allTicketings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): TicketingsConnection
  """Reads a set of `Ticketing`."""
  allTicketingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): [Ticketing!]
  """Reads and enables pagination through a set of `TodoList`."""
  allTodoLists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): TodoListsConnection
  """Reads a set of `TodoList`."""
  allTodoListsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]
  """Reads and enables pagination through a set of `Training`."""
  allTrainings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection
  """Reads a set of `Training`."""
  allTrainingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]
  """Reads and enables pagination through a set of `Transaction`."""
  allTransactions(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): TransactionsConnection
  """Reads a set of `Transaction`."""
  allTransactionsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): [Transaction!]
  """Reads and enables pagination through a set of `UrlRewrite`."""
  allUrlRewrites(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `UrlRewrite`."""
    orderBy: [UrlRewritesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UrlRewriteCondition
  ): UrlRewritesConnection
  """Reads a set of `UrlRewrite`."""
  allUrlRewritesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `UrlRewrite`."""
    orderBy: [UrlRewritesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UrlRewriteCondition
  ): [UrlRewrite!]
  """Reads and enables pagination through a set of `UserRole`."""
  allUserRoles(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `UserRole`."""
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserRoleCondition
  ): UserRolesConnection
  """Reads a set of `UserRole`."""
  allUserRolesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `UserRole`."""
    orderBy: [UserRolesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserRoleCondition
  ): [UserRole!]
  """Reads and enables pagination through a set of `User`."""
  allUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): UsersConnection
  """Reads a set of `User`."""
  allUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]
  """Reads and enables pagination through a set of `Visit`."""
  allVisits(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: VisitCondition
  ): VisitsConnection
  """Reads a set of `Visit`."""
  allVisitsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: VisitCondition
  ): [Visit!]
  """Reads and enables pagination through a set of `Warehouse`."""
  allWarehouses(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WarehouseCondition
  ): WarehousesConnection
  """Reads a set of `Warehouse`."""
  allWarehousesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WarehouseCondition
  ): [Warehouse!]
  """Reads and enables pagination through a set of `Webhook`."""
  allWebhooks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WebhookCondition
  ): WebhooksConnection
  """Reads a set of `Webhook`."""
  allWebhooksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WebhookCondition
  ): [Webhook!]
  """Reads and enables pagination through a set of `Website`."""
  allWebsites(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WebsiteCondition
  ): WebsitesConnection
  """Reads a set of `Website`."""
  allWebsitesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WebsiteCondition
  ): [Website!]
  """Reads and enables pagination through a set of `Wishlist`."""
  allWishlists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WishlistCondition
  ): WishlistsConnection
  """Reads a set of `Wishlist`."""
  allWishlistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WishlistCondition
  ): [Wishlist!]
  """Reads and enables pagination through a set of `Workspace`."""
  allWorkspaces(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection
  """Reads a set of `Workspace`."""
  allWorkspacesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]
  """Reads and enables pagination through a set of `Zone`."""
  allZones(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ZoneCondition
  ): ZonesConnection
  """Reads a set of `Zone`."""
  allZonesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ZoneCondition
  ): [Zone!]
  endofshiftById(id: BigInt!): Endofshift
  _schemaByClassName(className: String!): _Schema
  _prismaMigrationById(id: String!): _PrismaMigration
  accountById(id: BigInt!): Account
  agreementById(id: BigInt!): Agreement
  analyticById(id: BigInt!): Analytic
  apitokenById(id: BigInt!): Apitoken
  articleById(id: Int!): Article
  brandById(id: BigInt!): Brand
  cartPriceRuleById(id: Int!): CartPriceRule
  caseById(id: BigInt!): Case
  catalogPriceRuleById(id: Int!): CatalogPriceRule
  categoryById(id: Int!): Category
  channelById(id: BigInt!): Channel
  checklistById(id: BigInt!): Checklist
  cityById(id: Int!): City
  collectionById(id: BigInt!): Collection
  commentById(id: Int!): Comment
  contentTypeById(id: BigInt!): ContentType
  contractById(id: BigInt!): Contract
  countryById(id: Int!): Country
  couponById(id: BigInt!): Coupon
  creditMemoByCreditMemoAndId(creditMemo: String!, id: BigInt!): CreditMemo
  currencyById(id: BigInt!): Currency
  currencyRateByImportService(importService: String!): CurrencyRate
  currencyRateById(id: BigInt!): CurrencyRate
  currencySymbolBySymbol(symbol: String!): CurrencySymbol
  currencySymbolById(id: BigInt!): CurrencySymbol
  customerGroupById(id: BigInt!): CustomerGroup
  customerPaymentById(id: BigInt!): CustomerPayment
  customerById(id: Int!): Customer
  customizationById(id: Int!): Customization
  dashboardById(id: BigInt!): Dashboard
  deepdiveById(id: BigInt!): Deepdive
  emailTemplateById(id: BigInt!): EmailTemplate
  emailById(id: Int!): Email
  eventById(id: BigInt!): Event
  fullfillmentById(id: BigInt!): Fullfillment
  generalSettingById(id: BigInt!): GeneralSetting
  giftCertificateById(id: BigInt!): GiftCertificate
  glossaryById(id: Int!): Glossary
  importmById(id: BigInt!): Importm
  integrationById(id: BigInt!): Integration
  internalizationById(id: BigInt!): Internalization
  invitationById(id: BigInt!): Invitation
  invoiceById(id: BigInt!): Invoice
  knowledgebaseById(id: BigInt!): Knowledgebase
  leadById(id: BigInt!): Lead
  manufacturerById(id: BigInt!): Manufacturer
  mediamanagerById(id: Int!): Mediamanager
  meetingById(id: BigInt!): Meeting
  messageById(id: Int!): Message
  newsletterSubscriberById(id: Int!): NewsletterSubscriber
  occassionById(id: BigInt!): Occassion
  ootoById(id: BigInt!): Ooto
  opportunityById(id: BigInt!): Opportunity
  orderById(id: Int!): Order
  pageById(id: BigInt!): Page
  partnerById(id: BigInt!): Partner
  paymentById(id: BigInt!): Payment
  pdfTemplateById(id: BigInt!): PdfTemplate
  permissionById(id: BigInt!): Permission
  pluginById(id: BigInt!): Plugin
  productAttributeById(id: BigInt!): ProductAttribute
  productTypeById(id: BigInt!): ProductType
  productById(id: BigInt!): Product
  projectTemplateById(id: BigInt!): ProjectTemplate
  projectById(id: BigInt!): Project
  providerById(id: BigInt!): Provider
  quoteById(id: BigInt!): Quote
  ratingById(id: BigInt!): Rating
  reportById(id: BigInt!): Report
  returnById(id: BigInt!): Return
  reviewById(id: BigInt!): Review
  rewardById(id: BigInt!): Reward
  schedulerById(id: BigInt!): Scheduler
  segmentById(id: BigInt!): Segment
  settingscustomerById(id: BigInt!): Settingscustomer
  settingsgeneralById(id: BigInt!): Settingsgeneral
  settingshopById(id: BigInt!): Settingshop
  settingsmarketingById(id: BigInt!): Settingsmarketing
  settingssaleById(id: BigInt!): Settingssale
  shipmentById(id: BigInt!): Shipment
  shopSettingById(id: BigInt!): ShopSetting
  shopById(id: BigInt!): Shop
  specialDiscountById(id: BigInt!): SpecialDiscount
  stateById(id: BigInt!): State
  statisticById(id: BigInt!): Statistic
  stockById(id: BigInt!): Stock
  surveyById(id: BigInt!): Survey
  tagById(id: BigInt!): Tag
  targetById(id: BigInt!): Target
  taxCategoryById(id: BigInt!): TaxCategory
  taxRateById(id: BigInt!): TaxRate
  taxRuleById(id: BigInt!): TaxRule
  themeById(id: BigInt!): Theme
  ticketingById(id: BigInt!): Ticketing
  todoListById(id: BigInt!): TodoList
  trainingById(id: BigInt!): Training
  transactionById(id: BigInt!): Transaction
  urlRewriteById(id: BigInt!): UrlRewrite
  userRoleById(id: BigInt!): UserRole
  userById(id: BigInt!): User
  visitById(id: BigInt!): Visit
  warehouseById(id: BigInt!): Warehouse
  webhookById(id: BigInt!): Webhook
  websiteById(id: BigInt!): Website
  wishlistById(id: BigInt!): Wishlist
  workspaceById(id: BigInt!): Workspace
  zoneById(id: BigInt!): Zone
  arrayAdd(array: JSON!, values: JSON!): JSON
  arrayAddUnique(array: JSON!, values: JSON!): JSON
  arrayContains(array: JSON!, values: JSON!): Boolean
  arrayContainsAll(array: JSON!, values: JSON!): Boolean
  arrayContainsAllRegex(array: JSON!, values: JSON!): Boolean
  arrayRemove(array: JSON!, values: JSON!): JSON
  jsonObjectSetKey(json: JSON!, keyToSet: String!, valueToSet: String!): JSON
  """Reads a single `Endofshift` using its globally unique `ID`."""
  endofshift(
    """The globally unique `ID` to be used in selecting a single `Endofshift`."""
    nodeId: ID!
  ): Endofshift
  """Reads a single `_Schema` using its globally unique `ID`."""
  _schema(
    """The globally unique `ID` to be used in selecting a single `_Schema`."""
    nodeId: ID!
  ): _Schema
  """Reads a single `_PrismaMigration` using its globally unique `ID`."""
  _prismaMigration(
    """The globally unique `ID` to be used in selecting a single `_PrismaMigration`."""
    nodeId: ID!
  ): _PrismaMigration
  """Reads a single `Account` using its globally unique `ID`."""
  account(
    """The globally unique `ID` to be used in selecting a single `Account`."""
    nodeId: ID!
  ): Account
  """Reads a single `Agreement` using its globally unique `ID`."""
  agreement(
    """The globally unique `ID` to be used in selecting a single `Agreement`."""
    nodeId: ID!
  ): Agreement
  """Reads a single `Analytic` using its globally unique `ID`."""
  analytic(
    """The globally unique `ID` to be used in selecting a single `Analytic`."""
    nodeId: ID!
  ): Analytic
  """Reads a single `Apitoken` using its globally unique `ID`."""
  apitoken(
    """The globally unique `ID` to be used in selecting a single `Apitoken`."""
    nodeId: ID!
  ): Apitoken
  """Reads a single `Article` using its globally unique `ID`."""
  article(
    """The globally unique `ID` to be used in selecting a single `Article`."""
    nodeId: ID!
  ): Article
  """Reads a single `Brand` using its globally unique `ID`."""
  brand(
    """The globally unique `ID` to be used in selecting a single `Brand`."""
    nodeId: ID!
  ): Brand
  """Reads a single `CartPriceRule` using its globally unique `ID`."""
  cartPriceRule(
    """The globally unique `ID` to be used in selecting a single `CartPriceRule`."""
    nodeId: ID!
  ): CartPriceRule
  """Reads a single `Case` using its globally unique `ID`."""
  case(
    """The globally unique `ID` to be used in selecting a single `Case`."""
    nodeId: ID!
  ): Case
  """Reads a single `CatalogPriceRule` using its globally unique `ID`."""
  catalogPriceRule(
    """The globally unique `ID` to be used in selecting a single `CatalogPriceRule`."""
    nodeId: ID!
  ): CatalogPriceRule
  """Reads a single `Category` using its globally unique `ID`."""
  category(
    """The globally unique `ID` to be used in selecting a single `Category`."""
    nodeId: ID!
  ): Category
  """Reads a single `Channel` using its globally unique `ID`."""
  channel(
    """The globally unique `ID` to be used in selecting a single `Channel`."""
    nodeId: ID!
  ): Channel
  """Reads a single `Checklist` using its globally unique `ID`."""
  checklist(
    """The globally unique `ID` to be used in selecting a single `Checklist`."""
    nodeId: ID!
  ): Checklist
  """Reads a single `City` using its globally unique `ID`."""
  city(
    """The globally unique `ID` to be used in selecting a single `City`."""
    nodeId: ID!
  ): City
  """Reads a single `Collection` using its globally unique `ID`."""
  collection(
    """The globally unique `ID` to be used in selecting a single `Collection`."""
    nodeId: ID!
  ): Collection
  """Reads a single `Comment` using its globally unique `ID`."""
  comment(
    """The globally unique `ID` to be used in selecting a single `Comment`."""
    nodeId: ID!
  ): Comment
  """Reads a single `ContentType` using its globally unique `ID`."""
  contentType(
    """The globally unique `ID` to be used in selecting a single `ContentType`."""
    nodeId: ID!
  ): ContentType
  """Reads a single `Contract` using its globally unique `ID`."""
  contract(
    """The globally unique `ID` to be used in selecting a single `Contract`."""
    nodeId: ID!
  ): Contract
  """Reads a single `Country` using its globally unique `ID`."""
  country(
    """The globally unique `ID` to be used in selecting a single `Country`."""
    nodeId: ID!
  ): Country
  """Reads a single `Coupon` using its globally unique `ID`."""
  coupon(
    """The globally unique `ID` to be used in selecting a single `Coupon`."""
    nodeId: ID!
  ): Coupon
  """Reads a single `CreditMemo` using its globally unique `ID`."""
  creditMemo(
    """The globally unique `ID` to be used in selecting a single `CreditMemo`."""
    nodeId: ID!
  ): CreditMemo
  """Reads a single `Currency` using its globally unique `ID`."""
  currency(
    """The globally unique `ID` to be used in selecting a single `Currency`."""
    nodeId: ID!
  ): Currency
  """Reads a single `CurrencyRate` using its globally unique `ID`."""
  currencyRate(
    """The globally unique `ID` to be used in selecting a single `CurrencyRate`."""
    nodeId: ID!
  ): CurrencyRate
  """Reads a single `CurrencySymbol` using its globally unique `ID`."""
  currencySymbol(
    """The globally unique `ID` to be used in selecting a single `CurrencySymbol`."""
    nodeId: ID!
  ): CurrencySymbol
  """Reads a single `CustomerGroup` using its globally unique `ID`."""
  customerGroup(
    """The globally unique `ID` to be used in selecting a single `CustomerGroup`."""
    nodeId: ID!
  ): CustomerGroup
  """Reads a single `CustomerPayment` using its globally unique `ID`."""
  customerPayment(
    """The globally unique `ID` to be used in selecting a single `CustomerPayment`."""
    nodeId: ID!
  ): CustomerPayment
  """Reads a single `Customer` using its globally unique `ID`."""
  customer(
    """The globally unique `ID` to be used in selecting a single `Customer`."""
    nodeId: ID!
  ): Customer
  """Reads a single `Customization` using its globally unique `ID`."""
  customization(
    """The globally unique `ID` to be used in selecting a single `Customization`."""
    nodeId: ID!
  ): Customization
  """Reads a single `Dashboard` using its globally unique `ID`."""
  dashboard(
    """The globally unique `ID` to be used in selecting a single `Dashboard`."""
    nodeId: ID!
  ): Dashboard
  """Reads a single `Deepdive` using its globally unique `ID`."""
  deepdive(
    """The globally unique `ID` to be used in selecting a single `Deepdive`."""
    nodeId: ID!
  ): Deepdive
  """Reads a single `EmailTemplate` using its globally unique `ID`."""
  emailTemplate(
    """The globally unique `ID` to be used in selecting a single `EmailTemplate`."""
    nodeId: ID!
  ): EmailTemplate
  """Reads a single `Email` using its globally unique `ID`."""
  email(
    """The globally unique `ID` to be used in selecting a single `Email`."""
    nodeId: ID!
  ): Email
  """Reads a single `Event` using its globally unique `ID`."""
  event(
    """The globally unique `ID` to be used in selecting a single `Event`."""
    nodeId: ID!
  ): Event
  """Reads a single `Fullfillment` using its globally unique `ID`."""
  fullfillment(
    """The globally unique `ID` to be used in selecting a single `Fullfillment`."""
    nodeId: ID!
  ): Fullfillment
  """Reads a single `GeneralSetting` using its globally unique `ID`."""
  generalSetting(
    """The globally unique `ID` to be used in selecting a single `GeneralSetting`."""
    nodeId: ID!
  ): GeneralSetting
  """Reads a single `GiftCertificate` using its globally unique `ID`."""
  giftCertificate(
    """The globally unique `ID` to be used in selecting a single `GiftCertificate`."""
    nodeId: ID!
  ): GiftCertificate
  """Reads a single `Glossary` using its globally unique `ID`."""
  glossary(
    """The globally unique `ID` to be used in selecting a single `Glossary`."""
    nodeId: ID!
  ): Glossary
  """Reads a single `Importm` using its globally unique `ID`."""
  importm(
    """The globally unique `ID` to be used in selecting a single `Importm`."""
    nodeId: ID!
  ): Importm
  """Reads a single `Integration` using its globally unique `ID`."""
  integration(
    """The globally unique `ID` to be used in selecting a single `Integration`."""
    nodeId: ID!
  ): Integration
  """Reads a single `Internalization` using its globally unique `ID`."""
  internalization(
    """The globally unique `ID` to be used in selecting a single `Internalization`."""
    nodeId: ID!
  ): Internalization
  """Reads a single `Invitation` using its globally unique `ID`."""
  invitation(
    """The globally unique `ID` to be used in selecting a single `Invitation`."""
    nodeId: ID!
  ): Invitation
  """Reads a single `Invoice` using its globally unique `ID`."""
  invoice(
    """The globally unique `ID` to be used in selecting a single `Invoice`."""
    nodeId: ID!
  ): Invoice
  """Reads a single `Knowledgebase` using its globally unique `ID`."""
  knowledgebase(
    """The globally unique `ID` to be used in selecting a single `Knowledgebase`."""
    nodeId: ID!
  ): Knowledgebase
  """Reads a single `Lead` using its globally unique `ID`."""
  lead(
    """The globally unique `ID` to be used in selecting a single `Lead`."""
    nodeId: ID!
  ): Lead
  """Reads a single `Manufacturer` using its globally unique `ID`."""
  manufacturer(
    """The globally unique `ID` to be used in selecting a single `Manufacturer`."""
    nodeId: ID!
  ): Manufacturer
  """Reads a single `Mediamanager` using its globally unique `ID`."""
  mediamanager(
    """The globally unique `ID` to be used in selecting a single `Mediamanager`."""
    nodeId: ID!
  ): Mediamanager
  """Reads a single `Meeting` using its globally unique `ID`."""
  meeting(
    """The globally unique `ID` to be used in selecting a single `Meeting`."""
    nodeId: ID!
  ): Meeting
  """Reads a single `Message` using its globally unique `ID`."""
  message(
    """The globally unique `ID` to be used in selecting a single `Message`."""
    nodeId: ID!
  ): Message
  """Reads a single `NewsletterSubscriber` using its globally unique `ID`."""
  newsletterSubscriber(
    """The globally unique `ID` to be used in selecting a single `NewsletterSubscriber`."""
    nodeId: ID!
  ): NewsletterSubscriber
  """Reads a single `Occassion` using its globally unique `ID`."""
  occassion(
    """The globally unique `ID` to be used in selecting a single `Occassion`."""
    nodeId: ID!
  ): Occassion
  """Reads a single `Ooto` using its globally unique `ID`."""
  ooto(
    """The globally unique `ID` to be used in selecting a single `Ooto`."""
    nodeId: ID!
  ): Ooto
  """Reads a single `Opportunity` using its globally unique `ID`."""
  opportunity(
    """The globally unique `ID` to be used in selecting a single `Opportunity`."""
    nodeId: ID!
  ): Opportunity
  """Reads a single `Order` using its globally unique `ID`."""
  order(
    """The globally unique `ID` to be used in selecting a single `Order`."""
    nodeId: ID!
  ): Order
  """Reads a single `Page` using its globally unique `ID`."""
  page(
    """The globally unique `ID` to be used in selecting a single `Page`."""
    nodeId: ID!
  ): Page
  """Reads a single `Partner` using its globally unique `ID`."""
  partner(
    """The globally unique `ID` to be used in selecting a single `Partner`."""
    nodeId: ID!
  ): Partner
  """Reads a single `Payment` using its globally unique `ID`."""
  payment(
    """The globally unique `ID` to be used in selecting a single `Payment`."""
    nodeId: ID!
  ): Payment
  """Reads a single `PdfTemplate` using its globally unique `ID`."""
  pdfTemplate(
    """The globally unique `ID` to be used in selecting a single `PdfTemplate`."""
    nodeId: ID!
  ): PdfTemplate
  """Reads a single `Permission` using its globally unique `ID`."""
  permission(
    """The globally unique `ID` to be used in selecting a single `Permission`."""
    nodeId: ID!
  ): Permission
  """Reads a single `Plugin` using its globally unique `ID`."""
  plugin(
    """The globally unique `ID` to be used in selecting a single `Plugin`."""
    nodeId: ID!
  ): Plugin
  """Reads a single `ProductAttribute` using its globally unique `ID`."""
  productAttribute(
    """The globally unique `ID` to be used in selecting a single `ProductAttribute`."""
    nodeId: ID!
  ): ProductAttribute
  """Reads a single `ProductType` using its globally unique `ID`."""
  productType(
    """The globally unique `ID` to be used in selecting a single `ProductType`."""
    nodeId: ID!
  ): ProductType
  """Reads a single `Product` using its globally unique `ID`."""
  product(
    """The globally unique `ID` to be used in selecting a single `Product`."""
    nodeId: ID!
  ): Product
  """Reads a single `ProjectTemplate` using its globally unique `ID`."""
  projectTemplate(
    """The globally unique `ID` to be used in selecting a single `ProjectTemplate`."""
    nodeId: ID!
  ): ProjectTemplate
  """Reads a single `Project` using its globally unique `ID`."""
  project(
    """The globally unique `ID` to be used in selecting a single `Project`."""
    nodeId: ID!
  ): Project
  """Reads a single `Provider` using its globally unique `ID`."""
  provider(
    """The globally unique `ID` to be used in selecting a single `Provider`."""
    nodeId: ID!
  ): Provider
  """Reads a single `Quote` using its globally unique `ID`."""
  quote(
    """The globally unique `ID` to be used in selecting a single `Quote`."""
    nodeId: ID!
  ): Quote
  """Reads a single `Rating` using its globally unique `ID`."""
  rating(
    """The globally unique `ID` to be used in selecting a single `Rating`."""
    nodeId: ID!
  ): Rating
  """Reads a single `Report` using its globally unique `ID`."""
  report(
    """The globally unique `ID` to be used in selecting a single `Report`."""
    nodeId: ID!
  ): Report
  """Reads a single `Return` using its globally unique `ID`."""
  return(
    """The globally unique `ID` to be used in selecting a single `Return`."""
    nodeId: ID!
  ): Return
  """Reads a single `Review` using its globally unique `ID`."""
  review(
    """The globally unique `ID` to be used in selecting a single `Review`."""
    nodeId: ID!
  ): Review
  """Reads a single `Reward` using its globally unique `ID`."""
  reward(
    """The globally unique `ID` to be used in selecting a single `Reward`."""
    nodeId: ID!
  ): Reward
  """Reads a single `Scheduler` using its globally unique `ID`."""
  scheduler(
    """The globally unique `ID` to be used in selecting a single `Scheduler`."""
    nodeId: ID!
  ): Scheduler
  """Reads a single `Segment` using its globally unique `ID`."""
  segment(
    """The globally unique `ID` to be used in selecting a single `Segment`."""
    nodeId: ID!
  ): Segment
  """Reads a single `Settingscustomer` using its globally unique `ID`."""
  settingscustomer(
    """The globally unique `ID` to be used in selecting a single `Settingscustomer`."""
    nodeId: ID!
  ): Settingscustomer
  """Reads a single `Settingsgeneral` using its globally unique `ID`."""
  settingsgeneral(
    """The globally unique `ID` to be used in selecting a single `Settingsgeneral`."""
    nodeId: ID!
  ): Settingsgeneral
  """Reads a single `Settingshop` using its globally unique `ID`."""
  settingshop(
    """The globally unique `ID` to be used in selecting a single `Settingshop`."""
    nodeId: ID!
  ): Settingshop
  """Reads a single `Settingsmarketing` using its globally unique `ID`."""
  settingsmarketing(
    """The globally unique `ID` to be used in selecting a single `Settingsmarketing`."""
    nodeId: ID!
  ): Settingsmarketing
  """Reads a single `Settingssale` using its globally unique `ID`."""
  settingssale(
    """The globally unique `ID` to be used in selecting a single `Settingssale`."""
    nodeId: ID!
  ): Settingssale
  """Reads a single `Shipment` using its globally unique `ID`."""
  shipment(
    """The globally unique `ID` to be used in selecting a single `Shipment`."""
    nodeId: ID!
  ): Shipment
  """Reads a single `ShopSetting` using its globally unique `ID`."""
  shopSetting(
    """The globally unique `ID` to be used in selecting a single `ShopSetting`."""
    nodeId: ID!
  ): ShopSetting
  """Reads a single `Shop` using its globally unique `ID`."""
  shop(
    """The globally unique `ID` to be used in selecting a single `Shop`."""
    nodeId: ID!
  ): Shop
  """Reads a single `SpecialDiscount` using its globally unique `ID`."""
  specialDiscount(
    """The globally unique `ID` to be used in selecting a single `SpecialDiscount`."""
    nodeId: ID!
  ): SpecialDiscount
  """Reads a single `State` using its globally unique `ID`."""
  state(
    """The globally unique `ID` to be used in selecting a single `State`."""
    nodeId: ID!
  ): State
  """Reads a single `Statistic` using its globally unique `ID`."""
  statistic(
    """The globally unique `ID` to be used in selecting a single `Statistic`."""
    nodeId: ID!
  ): Statistic
  """Reads a single `Stock` using its globally unique `ID`."""
  stock(
    """The globally unique `ID` to be used in selecting a single `Stock`."""
    nodeId: ID!
  ): Stock
  """Reads a single `Survey` using its globally unique `ID`."""
  survey(
    """The globally unique `ID` to be used in selecting a single `Survey`."""
    nodeId: ID!
  ): Survey
  """Reads a single `Tag` using its globally unique `ID`."""
  tag(
    """The globally unique `ID` to be used in selecting a single `Tag`."""
    nodeId: ID!
  ): Tag
  """Reads a single `Target` using its globally unique `ID`."""
  target(
    """The globally unique `ID` to be used in selecting a single `Target`."""
    nodeId: ID!
  ): Target
  """Reads a single `TaxCategory` using its globally unique `ID`."""
  taxCategory(
    """The globally unique `ID` to be used in selecting a single `TaxCategory`."""
    nodeId: ID!
  ): TaxCategory
  """Reads a single `TaxRate` using its globally unique `ID`."""
  taxRate(
    """The globally unique `ID` to be used in selecting a single `TaxRate`."""
    nodeId: ID!
  ): TaxRate
  """Reads a single `TaxRule` using its globally unique `ID`."""
  taxRule(
    """The globally unique `ID` to be used in selecting a single `TaxRule`."""
    nodeId: ID!
  ): TaxRule
  """Reads a single `Theme` using its globally unique `ID`."""
  theme(
    """The globally unique `ID` to be used in selecting a single `Theme`."""
    nodeId: ID!
  ): Theme
  """Reads a single `Ticketing` using its globally unique `ID`."""
  ticketing(
    """The globally unique `ID` to be used in selecting a single `Ticketing`."""
    nodeId: ID!
  ): Ticketing
  """Reads a single `TodoList` using its globally unique `ID`."""
  todoList(
    """The globally unique `ID` to be used in selecting a single `TodoList`."""
    nodeId: ID!
  ): TodoList
  """Reads a single `Training` using its globally unique `ID`."""
  training(
    """The globally unique `ID` to be used in selecting a single `Training`."""
    nodeId: ID!
  ): Training
  """Reads a single `Transaction` using its globally unique `ID`."""
  transaction(
    """The globally unique `ID` to be used in selecting a single `Transaction`."""
    nodeId: ID!
  ): Transaction
  """Reads a single `UrlRewrite` using its globally unique `ID`."""
  urlRewrite(
    """The globally unique `ID` to be used in selecting a single `UrlRewrite`."""
    nodeId: ID!
  ): UrlRewrite
  """Reads a single `UserRole` using its globally unique `ID`."""
  userRole(
    """The globally unique `ID` to be used in selecting a single `UserRole`."""
    nodeId: ID!
  ): UserRole
  """Reads a single `User` using its globally unique `ID`."""
  user(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User
  """Reads a single `Visit` using its globally unique `ID`."""
  visit(
    """The globally unique `ID` to be used in selecting a single `Visit`."""
    nodeId: ID!
  ): Visit
  """Reads a single `Warehouse` using its globally unique `ID`."""
  warehouse(
    """The globally unique `ID` to be used in selecting a single `Warehouse`."""
    nodeId: ID!
  ): Warehouse
  """Reads a single `Webhook` using its globally unique `ID`."""
  webhook(
    """The globally unique `ID` to be used in selecting a single `Webhook`."""
    nodeId: ID!
  ): Webhook
  """Reads a single `Website` using its globally unique `ID`."""
  website(
    """The globally unique `ID` to be used in selecting a single `Website`."""
    nodeId: ID!
  ): Website
  """Reads a single `Wishlist` using its globally unique `ID`."""
  wishlist(
    """The globally unique `ID` to be used in selecting a single `Wishlist`."""
    nodeId: ID!
  ): Wishlist
  """Reads a single `Workspace` using its globally unique `ID`."""
  workspace(
    """The globally unique `ID` to be used in selecting a single `Workspace`."""
    nodeId: ID!
  ): Workspace
  """Reads a single `Zone` using its globally unique `ID`."""
  zone(
    """The globally unique `ID` to be used in selecting a single `Zone`."""
    nodeId: ID!
  ): Zone
  """
  Fetches a list of entities using their representations; used for Apollo
  Federation.
  """
  _entities(representations: [_Any!]!): [_Entity]! @deprecated(reason: "Only Apollo Federation should use this")
  """
  Entrypoint for Apollo Federation to determine more information about
  this service.
  """
  _service: _Service! @deprecated(reason: "Only Apollo Federation should use this")
}

"""A connection to a list of `Endofshift` values."""
type EndofshiftsConnection {
  """A list of `Endofshift` objects."""
  nodes: [Endofshift]!
  """A list of edges which contains the `Endofshift` and cursor to aid in pagination."""
  edges: [EndofshiftsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Endofshift` you could get from the connection."""
  totalCount: Int!
}

type Endofshift implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  content: String
  login: String
  mcms: String
  nextShift: String
  projects: String
  tickets: String
  whid: String
}

"""An object with a globally unique `ID`."""
interface Node {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""A `Endofshift` edge in the connection."""
type EndofshiftsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Endofshift` at the end of the edge."""
  node: Endofshift
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!
  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!
  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `Endofshift`."""
enum EndofshiftsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CONTENT_ASC
  CONTENT_DESC
  LOGIN_ASC
  LOGIN_DESC
  MCMS_ASC
  MCMS_DESC
  NEXT_SHIFT_ASC
  NEXT_SHIFT_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  TICKETS_ASC
  TICKETS_DESC
  WHID_ASC
  WHID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Endofshift` object types. All fields are tested
for equality and combined with a logical and.
"""
input EndofshiftCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `login` field."""
  login: String
  """Checks for equality with the objects `mcms` field."""
  mcms: String
  """Checks for equality with the objects `nextShift` field."""
  nextShift: String
  """Checks for equality with the objects `projects` field."""
  projects: String
  """Checks for equality with the objects `tickets` field."""
  tickets: String
  """Checks for equality with the objects `whid` field."""
  whid: String
}

"""A connection to a list of `_Schema` values."""
type _SchemasConnection {
  """A list of `_Schema` objects."""
  nodes: [_Schema]!
  """A list of edges which contains the `_Schema` and cursor to aid in pagination."""
  edges: [_SchemasEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `_Schema` you could get from the connection."""
  totalCount: Int!
}

type _Schema implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  className: String!
  schema: JSON
  isParseClass: Boolean
}

"""The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."""
scalar JSON

"""A `_Schema` edge in the connection."""
type _SchemasEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `_Schema` at the end of the edge."""
  node: _Schema
}

"""Methods to use when ordering `_Schema`."""
enum _SchemasOrderBy {
  NATURAL
  CLASS_NAME_ASC
  CLASS_NAME_DESC
  SCHEMA_ASC
  SCHEMA_DESC
  IS_PARSE_CLASS_ASC
  IS_PARSE_CLASS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `_Schema` object types. All fields are tested for equality and combined with a logical and."""
input _SchemaCondition {
  """Checks for equality with the objects `className` field."""
  className: String
  """Checks for equality with the objects `schema` field."""
  schema: JSON
  """Checks for equality with the objects `isParseClass` field."""
  isParseClass: Boolean
}

"""A connection to a list of `_PrismaMigration` values."""
type _PrismaMigrationsConnection {
  """A list of `_PrismaMigration` objects."""
  nodes: [_PrismaMigration]!
  """A list of edges which contains the `_PrismaMigration` and cursor to aid in pagination."""
  edges: [_PrismaMigrationsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `_PrismaMigration` you could get from the connection."""
  totalCount: Int!
}

type _PrismaMigration implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: String!
  checksum: String!
  finishedAt: Datetime
  migrationName: String!
  logs: String
  rolledBackAt: Datetime
  startedAt: Datetime!
  appliedStepsCount: Int!
}

"""A `_PrismaMigration` edge in the connection."""
type _PrismaMigrationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `_PrismaMigration` at the end of the edge."""
  node: _PrismaMigration
}

"""Methods to use when ordering `_PrismaMigration`."""
enum _PrismaMigrationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CHECKSUM_ASC
  CHECKSUM_DESC
  FINISHED_AT_ASC
  FINISHED_AT_DESC
  MIGRATION_NAME_ASC
  MIGRATION_NAME_DESC
  LOGS_ASC
  LOGS_DESC
  ROLLED_BACK_AT_ASC
  ROLLED_BACK_AT_DESC
  STARTED_AT_ASC
  STARTED_AT_DESC
  APPLIED_STEPS_COUNT_ASC
  APPLIED_STEPS_COUNT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `_PrismaMigration` object types. All fields are
tested for equality and combined with a logical and.
"""
input _PrismaMigrationCondition {
  """Checks for equality with the objects `id` field."""
  id: String
  """Checks for equality with the objects `checksum` field."""
  checksum: String
  """Checks for equality with the objects `finishedAt` field."""
  finishedAt: Datetime
  """Checks for equality with the objects `migrationName` field."""
  migrationName: String
  """Checks for equality with the objects `logs` field."""
  logs: String
  """Checks for equality with the objects `rolledBackAt` field."""
  rolledBackAt: Datetime
  """Checks for equality with the objects `startedAt` field."""
  startedAt: Datetime
  """Checks for equality with the objects `appliedStepsCount` field."""
  appliedStepsCount: Int
}

"""A connection to a list of `Account` values."""
type AccountsConnection {
  """A list of `Account` objects."""
  nodes: [Account]!
  """A list of edges which contains the `Account` and cursor to aid in pagination."""
  edges: [AccountsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Account` you could get from the connection."""
  totalCount: Int!
}

type Account implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  website: String
  officePhone: String
  fax: String
  email: String
  address: String
  postalcode: String
  city: String
  state: String
  country: String
  assignedTo: String
  altAddress: String
  altPostalcode: String
  altCity: String
  altState: String
  altCountry: String
  type: String
  industry: String
  employees: String
  annualRevenue: String
  memberOf: String
  campaign: String
}

"""A `Account` edge in the connection."""
type AccountsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Account` at the end of the edge."""
  node: Account
}

"""Methods to use when ordering `Account`."""
enum AccountsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  OFFICE_PHONE_ASC
  OFFICE_PHONE_DESC
  FAX_ASC
  FAX_DESC
  EMAIL_ASC
  EMAIL_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  POSTALCODE_ASC
  POSTALCODE_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  ALT_ADDRESS_ASC
  ALT_ADDRESS_DESC
  ALT_POSTALCODE_ASC
  ALT_POSTALCODE_DESC
  ALT_CITY_ASC
  ALT_CITY_DESC
  ALT_STATE_ASC
  ALT_STATE_DESC
  ALT_COUNTRY_ASC
  ALT_COUNTRY_DESC
  TYPE_ASC
  TYPE_DESC
  INDUSTRY_ASC
  INDUSTRY_DESC
  EMPLOYEES_ASC
  EMPLOYEES_DESC
  ANNUAL_REVENUE_ASC
  ANNUAL_REVENUE_DESC
  MEMBER_OF_ASC
  MEMBER_OF_DESC
  CAMPAIGN_ASC
  CAMPAIGN_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Account` object types. All fields are tested for equality and combined with a logical and."""
input AccountCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `website` field."""
  website: String
  """Checks for equality with the objects `officePhone` field."""
  officePhone: String
  """Checks for equality with the objects `fax` field."""
  fax: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `address` field."""
  address: String
  """Checks for equality with the objects `postalcode` field."""
  postalcode: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `altAddress` field."""
  altAddress: String
  """Checks for equality with the objects `altPostalcode` field."""
  altPostalcode: String
  """Checks for equality with the objects `altCity` field."""
  altCity: String
  """Checks for equality with the objects `altState` field."""
  altState: String
  """Checks for equality with the objects `altCountry` field."""
  altCountry: String
  """Checks for equality with the objects `type` field."""
  type: String
  """Checks for equality with the objects `industry` field."""
  industry: String
  """Checks for equality with the objects `employees` field."""
  employees: String
  """Checks for equality with the objects `annualRevenue` field."""
  annualRevenue: String
  """Checks for equality with the objects `memberOf` field."""
  memberOf: String
  """Checks for equality with the objects `campaign` field."""
  campaign: String
}

"""A connection to a list of `Agreement` values."""
type AgreementsConnection {
  """A list of `Agreement` objects."""
  nodes: [Agreement]!
  """A list of edges which contains the `Agreement` and cursor to aid in pagination."""
  edges: [AgreementsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Agreement` you could get from the connection."""
  totalCount: Int!
}

type Agreement implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  referenceId: String!
  created: Datetime
  updated: Datetime
  content: String
  name: String
  image: String
  excerpt: String
  type: String
  userId: String!
  shopId: String!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerAgreementsAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): AgreementBrandsByMediamanagerAgreementsAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerAgreementsAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerAgreementsAndAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): AgreementCustomersByMediamanagerAgreementsAndAuthorManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerAgreementsAndAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerAgreementsAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): AgreementCommentsByMediamanagerAgreementsAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerAgreementsAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerAgreementsAndTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): AgreementTodoListsByMediamanagerAgreementsAndTaskNameManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerAgreementsAndTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerAgreementsAndMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): AgreementUsersByMediamanagerAgreementsAndMembersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerAgreementsAndMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerAgreementsAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): AgreementProductsByMediamanagerAgreementsAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerAgreementsAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
}

"""A connection to a list of `Mediamanager` values."""
type MediamanagersConnection {
  """A list of `Mediamanager` objects."""
  nodes: [Mediamanager]!
  """A list of edges which contains the `Mediamanager` and cursor to aid in pagination."""
  edges: [MediamanagersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Mediamanager` you could get from the connection."""
  totalCount: Int!
}

type Mediamanager implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  createdAt: Datetime
  name: String
  description: String
  media: String
  keywords: String
  tags: String
  brands: BigInt
  status: String
  expirationDate: String
  copyright: String
  dimensions: String
  author: Int
  contentType: String
  versions: String
  watermarkName: String
  watermarkDescription: String
  watermarkMedia: String
  agreements: Int
  albums: String
  comment: Int
  workspace: String
  taskName: BigInt
  taskDescription: String
  taskType: String
  members: Int
  products: BigInt
  """Reads a single `Brand` that is related to this `Mediamanager`."""
  brandByBrands: Brand
  """Reads a single `Customer` that is related to this `Mediamanager`."""
  customerByAuthor: Customer
  """Reads a single `Agreement` that is related to this `Mediamanager`."""
  agreementByAgreements: Agreement
  """Reads a single `Comment` that is related to this `Mediamanager`."""
  commentByComment: Comment
  """Reads a single `TodoList` that is related to this `Mediamanager`."""
  todoListByTaskName: TodoList
  """Reads a single `User` that is related to this `Mediamanager`."""
  userByMembers: User
  """Reads a single `Product` that is related to this `Mediamanager`."""
  productByProducts: Product
}

type Brand implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
  """Reads a single `Product` that is related to this `Brand`."""
  productByProduct: Product
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerBrandsAndAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): BrandCustomersByMediamanagerBrandsAndAuthorManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerBrandsAndAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerBrandsAndAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): BrandAgreementsByMediamanagerBrandsAndAgreementsManyToManyConnection!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerBrandsAndAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): [Agreement!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerBrandsAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): BrandCommentsByMediamanagerBrandsAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerBrandsAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerBrandsAndTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): BrandTodoListsByMediamanagerBrandsAndTaskNameManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerBrandsAndTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerBrandsAndMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): BrandUsersByMediamanagerBrandsAndMembersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerBrandsAndMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerBrandsAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): BrandProductsByMediamanagerBrandsAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerBrandsAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceBrandsAndCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): BrandCustomersByWorkspaceBrandsAndCustomersManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceBrandsAndCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceBrandsAndUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): BrandUsersByWorkspaceBrandsAndUsersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceBrandsAndUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceBrandsAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): BrandProductsByWorkspaceBrandsAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceBrandsAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceBrandsAndTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): BrandTodoListsByWorkspaceBrandsAndTasksManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceBrandsAndTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceBrandsAndShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): BrandShopsByWorkspaceBrandsAndShopsManyToManyConnection!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceBrandsAndShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): [Shop!]!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceBrandsAndCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): BrandCategoriesByWorkspaceBrandsAndCategoryManyToManyConnection!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceBrandsAndCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): [Category!]!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceBrandsAndProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): BrandProjectsByWorkspaceBrandsAndProjectsManyToManyConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceBrandsAndProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

type Product implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  sku: BigInt!
  thumbnail: String
  name: String!
  types: String
  attributes: String
  price: String
  quantityPerSource: String
  salableQuantity: String
  visibility: String
  status: Boolean
  websites: String
  product: String
  taxClass: String
  stockStatus: String
  weight: String
  categories: String
  createdAt: Datetime
  country: String
  size: String
  format: String
  height: String
  content: String
  shortDescription: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  file: String
  manufacture: String
  partNumber: String
  contract: String
  costString: String
  manufacturerPartNumber: String
  relatedProduct: BigInt
  tags: String
  brand: String
  occassions: String
  customerType: String
  family: String
  zone: String
  variants: String
  """Reads a single `Product` that is related to this `Product`."""
  productByRelatedProduct: Product
  """Reads and enables pagination through a set of `Coupon`."""
  couponsByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CouponCondition
  ): CouponsConnection!
  """Reads and enables pagination through a set of `Coupon`."""
  couponsByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CouponCondition
  ): [Coupon!]!
  """Reads and enables pagination through a set of `CreditMemo`."""
  creditMemosByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): CreditMemosConnection!
  """Reads and enables pagination through a set of `CreditMemo`."""
  creditMemosByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): [CreditMemo!]!
  """Reads and enables pagination through a set of `Order`."""
  ordersByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): OrdersConnection!
  """Reads and enables pagination through a set of `Order`."""
  ordersByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): [Order!]!
  """Reads and enables pagination through a set of `ProductAttribute`."""
  productAttributesByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ProductAttribute`."""
    orderBy: [ProductAttributesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductAttributeCondition
  ): ProductAttributesConnection!
  """Reads and enables pagination through a set of `ProductAttribute`."""
  productAttributesByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ProductAttribute`."""
    orderBy: [ProductAttributesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductAttributeCondition
  ): [ProductAttribute!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByRelatedProduct(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): ProductsConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByRelatedProductList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]!
  """Reads and enables pagination through a set of `Rating`."""
  ratingsByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Rating`."""
    orderBy: [RatingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RatingCondition
  ): RatingsConnection!
  """Reads and enables pagination through a set of `Rating`."""
  ratingsByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Rating`."""
    orderBy: [RatingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RatingCondition
  ): [Rating!]!
  """Reads and enables pagination through a set of `TaxRate`."""
  taxRatesByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TaxRate`."""
    orderBy: [TaxRatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRateCondition
  ): TaxRatesConnection!
  """Reads and enables pagination through a set of `TaxRate`."""
  taxRatesByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TaxRate`."""
    orderBy: [TaxRatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRateCondition
  ): [TaxRate!]!
  """Reads and enables pagination through a set of `TaxRule`."""
  taxRulesByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TaxRule`."""
    orderBy: [TaxRulesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRuleCondition
  ): TaxRulesConnection!
  """Reads and enables pagination through a set of `TaxRule`."""
  taxRulesByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TaxRule`."""
    orderBy: [TaxRulesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRuleCondition
  ): [TaxRule!]!
  """Reads and enables pagination through a set of `Return`."""
  returnsByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): ReturnsConnection!
  """Reads and enables pagination through a set of `Return`."""
  returnsByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): [Return!]!
  """Reads and enables pagination through a set of `ProductType`."""
  productTypesByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductTypeCondition
  ): ProductTypesConnection!
  """Reads and enables pagination through a set of `ProductType`."""
  productTypesByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductTypeCondition
  ): [ProductType!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByProduct(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): BrandsConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByProductList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Occassion`."""
  occassionsByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): OccassionsConnection!
  """Reads and enables pagination through a set of `Occassion`."""
  occassionsByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): [Occassion!]!
  """Reads and enables pagination through a set of `Manufacturer`."""
  manufacturersByProduct(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ManufacturerCondition
  ): ManufacturersConnection!
  """Reads and enables pagination through a set of `Manufacturer`."""
  manufacturersByProductList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ManufacturerCondition
  ): [Manufacturer!]!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByCreditMemoProdIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): ProductCustomersByCreditMemoProdIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByCreditMemoProdIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByOrderProdIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): ProductCustomersByOrderProdIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByOrderProdIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByQuoteProdIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): ProductCustomersByQuoteProdIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByQuoteProdIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Order`."""
  ordersByQuoteProdIdAndOrderId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): ProductOrdersByQuoteProdIdAndOrderIdManyToManyConnection!
  """Reads and enables pagination through a set of `Order`."""
  ordersByQuoteProdIdAndOrderIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): [Order!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByReturnProdIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): ProductCustomersByReturnProdIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByReturnProdIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Wishlist`."""
  wishlistsByOccassionProductsAndWishlists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WishlistCondition
  ): ProductWishlistsByOccassionProductsAndWishlistsManyToManyConnection!
  """Reads and enables pagination through a set of `Wishlist`."""
  wishlistsByOccassionProductsAndWishlistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WishlistCondition
  ): [Wishlist!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerProductsAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): ProductBrandsByMediamanagerProductsAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerProductsAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerProductsAndAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): ProductCustomersByMediamanagerProductsAndAuthorManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerProductsAndAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerProductsAndAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): ProductAgreementsByMediamanagerProductsAndAgreementsManyToManyConnection!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerProductsAndAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): [Agreement!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerProductsAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): ProductCommentsByMediamanagerProductsAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerProductsAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerProductsAndTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): ProductTodoListsByMediamanagerProductsAndTaskNameManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerProductsAndTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerProductsAndMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): ProductUsersByMediamanagerProductsAndMembersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerProductsAndMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceProductsAndCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): ProductCustomersByWorkspaceProductsAndCustomersManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceProductsAndCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceProductsAndUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): ProductUsersByWorkspaceProductsAndUsersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceProductsAndUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceProductsAndTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): ProductTodoListsByWorkspaceProductsAndTasksManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceProductsAndTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceProductsAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): ProductBrandsByWorkspaceProductsAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceProductsAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceProductsAndShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): ProductShopsByWorkspaceProductsAndShopsManyToManyConnection!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceProductsAndShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): [Shop!]!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceProductsAndCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): ProductCategoriesByWorkspaceProductsAndCategoryManyToManyConnection!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceProductsAndCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): [Category!]!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceProductsAndProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProductProjectsByWorkspaceProductsAndProjectsManyToManyConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceProductsAndProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByTrainingProductsAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): ProductCommentsByTrainingProductsAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByTrainingProductsAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `Country`."""
  countriesByTrainingProductsAndCountry(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): ProductCountriesByTrainingProductsAndCountryManyToManyConnection!
  """Reads and enables pagination through a set of `Country`."""
  countriesByTrainingProductsAndCountryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): [Country!]!
  """Reads and enables pagination through a set of `State`."""
  statesByTrainingProductsAndState(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): ProductStatesByTrainingProductsAndStateManyToManyConnection!
  """Reads and enables pagination through a set of `State`."""
  statesByTrainingProductsAndStateList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): [State!]!
  """Reads and enables pagination through a set of `Checklist`."""
  checklistsByTrainingProductsAndChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): ProductChecklistsByTrainingProductsAndChecklistsManyToManyConnection!
  """Reads and enables pagination through a set of `Checklist`."""
  checklistsByTrainingProductsAndChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): [Checklist!]!
}

"""A connection to a list of `Coupon` values."""
type CouponsConnection {
  """A list of `Coupon` objects."""
  nodes: [Coupon]!
  """A list of edges which contains the `Coupon` and cursor to aid in pagination."""
  edges: [CouponsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Coupon` you could get from the connection."""
  totalCount: Int!
}

type Coupon implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  excerpt: String
  discount: String
  image: String
  published: Datetime
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  prodId: BigInt!
  """Reads a single `Product` that is related to this `Coupon`."""
  productByProdId: Product
}

"""A `Coupon` edge in the connection."""
type CouponsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Coupon` at the end of the edge."""
  node: Coupon
}

"""Methods to use when ordering `Coupon`."""
enum CouponsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  DISCOUNT_ASC
  DISCOUNT_DESC
  IMAGE_ASC
  IMAGE_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  EXPIRATION_ASC
  EXPIRATION_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Coupon` object types. All fields are tested for equality and combined with a logical and."""
input CouponCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `excerpt` field."""
  excerpt: String
  """Checks for equality with the objects `discount` field."""
  discount: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `published` field."""
  published: Datetime
  """Checks for equality with the objects `expiration` field."""
  expiration: String
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `articles` field."""
  articles: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `users` field."""
  users: String
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
}

"""A connection to a list of `CreditMemo` values."""
type CreditMemosConnection {
  """A list of `CreditMemo` objects."""
  nodes: [CreditMemo]!
  """A list of edges which contains the `CreditMemo` and cursor to aid in pagination."""
  edges: [CreditMemosEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `CreditMemo` you could get from the connection."""
  totalCount: Int!
}

type CreditMemo implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  creditMemo: String!
  orderNumber: Int!
  created: Datetime
  billToName: String!
  status: String
  refunded: String
  action: String
  id: BigInt!
  custId: Int!
  prodId: BigInt!
  """Reads a single `Customer` that is related to this `CreditMemo`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `CreditMemo`."""
  productByProdId: Product
}

type Customer implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  thumbnail: String
  namePrefix: String
  firstName: String!
  middleName: String
  lastName: String!
  email: String!
  customerGroup: String
  phone: String
  zipcode: String
  nameSuffix: String
  websites: String
  product: String
  country: String
  state: String
  customerSince: Datetime
  confirmedEmail: String
  dateOfBirth: String
  taxVatNumber: String
  gender: String
  description: String
  shortDescription: String
  image: String
  address: String
  addressTwo: String
  paymentType: String
  username: String
  password: String
  """Reads and enables pagination through a set of `Comment`."""
  commentsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): CommentsConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `CreditMemo`."""
  creditMemosByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): CreditMemosConnection!
  """Reads and enables pagination through a set of `CreditMemo`."""
  creditMemosByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): [CreditMemo!]!
  """Reads and enables pagination through a set of `NewsletterSubscriber`."""
  newsletterSubscribersByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `NewsletterSubscriber`."""
    orderBy: [NewsletterSubscribersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: NewsletterSubscriberCondition
  ): NewsletterSubscribersConnection!
  """Reads and enables pagination through a set of `NewsletterSubscriber`."""
  newsletterSubscribersByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `NewsletterSubscriber`."""
    orderBy: [NewsletterSubscribersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: NewsletterSubscriberCondition
  ): [NewsletterSubscriber!]!
  """Reads and enables pagination through a set of `Order`."""
  ordersByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): OrdersConnection!
  """Reads and enables pagination through a set of `Order`."""
  ordersByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): [Order!]!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]!
  """Reads and enables pagination through a set of `CustomerGroup`."""
  customerGroupsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CustomerGroup`."""
    orderBy: [CustomerGroupsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerGroupCondition
  ): CustomerGroupsConnection!
  """Reads and enables pagination through a set of `CustomerGroup`."""
  customerGroupsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CustomerGroup`."""
    orderBy: [CustomerGroupsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerGroupCondition
  ): [CustomerGroup!]!
  """Reads and enables pagination through a set of `Email`."""
  emailsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): EmailsConnection!
  """Reads and enables pagination through a set of `Email`."""
  emailsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): [Email!]!
  """Reads and enables pagination through a set of `Return`."""
  returnsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): ReturnsConnection!
  """Reads and enables pagination through a set of `Return`."""
  returnsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): [Return!]!
  """Reads and enables pagination through a set of `CustomerPayment`."""
  customerPaymentsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerPaymentCondition
  ): CustomerPaymentsConnection!
  """Reads and enables pagination through a set of `CustomerPayment`."""
  customerPaymentsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerPaymentCondition
  ): [CustomerPayment!]!
  """Reads and enables pagination through a set of `Project`."""
  projectsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
  """Reads and enables pagination through a set of `Message`."""
  messagesByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): MessagesConnection!
  """Reads and enables pagination through a set of `Message`."""
  messagesByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): [Message!]!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByCreditMemoCustIdAndProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CustomerProductsByCreditMemoCustIdAndProdIdManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByCreditMemoCustIdAndProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByOrderCustIdAndProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CustomerProductsByOrderCustIdAndProdIdManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByOrderCustIdAndProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByQuoteCustIdAndProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CustomerProductsByQuoteCustIdAndProdIdManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByQuoteCustIdAndProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Order`."""
  ordersByQuoteCustIdAndOrderId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): CustomerOrdersByQuoteCustIdAndOrderIdManyToManyConnection!
  """Reads and enables pagination through a set of `Order`."""
  ordersByQuoteCustIdAndOrderIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): [Order!]!
  """Reads and enables pagination through a set of `User`."""
  usersByEmailCustIdAndStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): CustomerUsersByEmailCustIdAndStaffIdManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByEmailCustIdAndStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByReturnCustIdAndProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CustomerProductsByReturnCustIdAndProdIdManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByReturnCustIdAndProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `User`."""
  usersByProjectCustIdAndStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): CustomerUsersByProjectCustIdAndStaffIdManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByProjectCustIdAndStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByProjectCustIdAndTaskId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): CustomerTodoListsByProjectCustIdAndTaskIdManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByProjectCustIdAndTaskIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Ticketing`."""
  ticketingsByProjectCustIdAndTicketId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): CustomerTicketingsByProjectCustIdAndTicketIdManyToManyConnection!
  """Reads and enables pagination through a set of `Ticketing`."""
  ticketingsByProjectCustIdAndTicketIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): [Ticketing!]!
  """Reads and enables pagination through a set of `User`."""
  usersByMessageCustIdAndStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): CustomerUsersByMessageCustIdAndStaffIdManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByMessageCustIdAndStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerAuthorAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): CustomerBrandsByMediamanagerAuthorAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerAuthorAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerAuthorAndAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): CustomerAgreementsByMediamanagerAuthorAndAgreementsManyToManyConnection!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerAuthorAndAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): [Agreement!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerAuthorAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): CustomerCommentsByMediamanagerAuthorAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerAuthorAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerAuthorAndTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): CustomerTodoListsByMediamanagerAuthorAndTaskNameManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerAuthorAndTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerAuthorAndMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): CustomerUsersByMediamanagerAuthorAndMembersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerAuthorAndMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerAuthorAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CustomerProductsByMediamanagerAuthorAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerAuthorAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceCustomersAndUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): CustomerUsersByWorkspaceCustomersAndUsersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceCustomersAndUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceCustomersAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CustomerProductsByWorkspaceCustomersAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceCustomersAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceCustomersAndTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): CustomerTodoListsByWorkspaceCustomersAndTasksManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceCustomersAndTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceCustomersAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): CustomerBrandsByWorkspaceCustomersAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceCustomersAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceCustomersAndShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): CustomerShopsByWorkspaceCustomersAndShopsManyToManyConnection!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceCustomersAndShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): [Shop!]!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceCustomersAndCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): CustomerCategoriesByWorkspaceCustomersAndCategoryManyToManyConnection!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceCustomersAndCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): [Category!]!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceCustomersAndProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): CustomerProjectsByWorkspaceCustomersAndProjectsManyToManyConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceCustomersAndProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `Comment` values."""
type CommentsConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment` and cursor to aid in pagination."""
  edges: [CommentsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

type Comment implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  customerName: String!
  description: String
  image: String
  response: String
  published: Datetime
  custId: Int!
  """Reads a single `Customer` that is related to this `Comment`."""
  customerByCustId: Customer
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerCommentAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): CommentBrandsByMediamanagerCommentAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerCommentAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerCommentAndAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): CommentCustomersByMediamanagerCommentAndAuthorManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerCommentAndAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerCommentAndAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): CommentAgreementsByMediamanagerCommentAndAgreementsManyToManyConnection!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerCommentAndAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): [Agreement!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerCommentAndTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): CommentTodoListsByMediamanagerCommentAndTaskNameManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerCommentAndTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerCommentAndMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): CommentUsersByMediamanagerCommentAndMembersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerCommentAndMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerCommentAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CommentProductsByMediamanagerCommentAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerCommentAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Country`."""
  countriesByTrainingCommentAndCountry(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): CommentCountriesByTrainingCommentAndCountryManyToManyConnection!
  """Reads and enables pagination through a set of `Country`."""
  countriesByTrainingCommentAndCountryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): [Country!]!
  """Reads and enables pagination through a set of `State`."""
  statesByTrainingCommentAndState(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): CommentStatesByTrainingCommentAndStateManyToManyConnection!
  """Reads and enables pagination through a set of `State`."""
  statesByTrainingCommentAndStateList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): [State!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByTrainingCommentAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CommentProductsByTrainingCommentAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByTrainingCommentAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Checklist`."""
  checklistsByTrainingCommentAndChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): CommentChecklistsByTrainingCommentAndChecklistsManyToManyConnection!
  """Reads and enables pagination through a set of `Checklist`."""
  checklistsByTrainingCommentAndChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): [Checklist!]!
}

"""Methods to use when ordering `Mediamanager`."""
enum MediamanagersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  MEDIA_ASC
  MEDIA_DESC
  KEYWORDS_ASC
  KEYWORDS_DESC
  TAGS_ASC
  TAGS_DESC
  BRANDS_ASC
  BRANDS_DESC
  STATUS_ASC
  STATUS_DESC
  EXPIRATION_DATE_ASC
  EXPIRATION_DATE_DESC
  COPYRIGHT_ASC
  COPYRIGHT_DESC
  DIMENSIONS_ASC
  DIMENSIONS_DESC
  AUTHOR_ASC
  AUTHOR_DESC
  CONTENT_TYPE_ASC
  CONTENT_TYPE_DESC
  VERSIONS_ASC
  VERSIONS_DESC
  WATERMARK_NAME_ASC
  WATERMARK_NAME_DESC
  WATERMARK_DESCRIPTION_ASC
  WATERMARK_DESCRIPTION_DESC
  WATERMARK_MEDIA_ASC
  WATERMARK_MEDIA_DESC
  AGREEMENTS_ASC
  AGREEMENTS_DESC
  ALBUMS_ASC
  ALBUMS_DESC
  COMMENT_ASC
  COMMENT_DESC
  WORKSPACE_ASC
  WORKSPACE_DESC
  TASK_NAME_ASC
  TASK_NAME_DESC
  TASK_DESCRIPTION_ASC
  TASK_DESCRIPTION_DESC
  TASK_TYPE_ASC
  TASK_TYPE_DESC
  MEMBERS_ASC
  MEMBERS_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Mediamanager` object types. All fields are
tested for equality and combined with a logical and.
"""
input MediamanagerCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `keywords` field."""
  keywords: String
  """Checks for equality with the objects `tags` field."""
  tags: String
  """Checks for equality with the objects `brands` field."""
  brands: BigInt
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `expirationDate` field."""
  expirationDate: String
  """Checks for equality with the objects `copyright` field."""
  copyright: String
  """Checks for equality with the objects `dimensions` field."""
  dimensions: String
  """Checks for equality with the objects `author` field."""
  author: Int
  """Checks for equality with the objects `contentType` field."""
  contentType: String
  """Checks for equality with the objects `versions` field."""
  versions: String
  """Checks for equality with the objects `watermarkName` field."""
  watermarkName: String
  """Checks for equality with the objects `watermarkDescription` field."""
  watermarkDescription: String
  """Checks for equality with the objects `watermarkMedia` field."""
  watermarkMedia: String
  """Checks for equality with the objects `agreements` field."""
  agreements: Int
  """Checks for equality with the objects `albums` field."""
  albums: String
  """Checks for equality with the objects `comment` field."""
  comment: Int
  """Checks for equality with the objects `workspace` field."""
  workspace: String
  """Checks for equality with the objects `taskName` field."""
  taskName: BigInt
  """Checks for equality with the objects `taskDescription` field."""
  taskDescription: String
  """Checks for equality with the objects `taskType` field."""
  taskType: String
  """Checks for equality with the objects `members` field."""
  members: Int
  """Checks for equality with the objects `products` field."""
  products: BigInt
}

"""A connection to a list of `Training` values."""
type TrainingsConnection {
  """A list of `Training` objects."""
  nodes: [Training]!
  """A list of edges which contains the `Training` and cursor to aid in pagination."""
  edges: [TrainingsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Training` you could get from the connection."""
  totalCount: Int!
}

type Training implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  subject: String
  content: String
  media: String
  link: String
  steps: String
  updated: Datetime
  analytics: String
  competency: String
  course: String
  grade: String
  school: String
  comment: Int
  address: String
  country: Int
  state: Int
  postal: String
  teacher: String
  student: String
  anncouncement: String
  resource: String
  badges: String
  isPublic: String
  isCompleted: String
  speakers: String
  fieldTrips: String
  assignments: String
  assignmentsDueDate: String
  origanlityReport: String
  products: BigInt
  faqs: String
  languages: String
  checklists: BigInt
  city: String
  meetups: String
  lab: String
  digiboards: String
  """Reads a single `Comment` that is related to this `Training`."""
  commentByComment: Comment
  """Reads a single `Country` that is related to this `Training`."""
  countryByCountry: Country
  """Reads a single `State` that is related to this `Training`."""
  stateByState: State
  """Reads a single `Product` that is related to this `Training`."""
  productByProducts: Product
  """Reads a single `Checklist` that is related to this `Training`."""
  checklistByChecklists: Checklist
}

type Country implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  name: String!
  description: String
  image: String
  region: String
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountry(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByTrainingCountryAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): CountryCommentsByTrainingCountryAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByTrainingCountryAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `State`."""
  statesByTrainingCountryAndState(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): CountryStatesByTrainingCountryAndStateManyToManyConnection!
  """Reads and enables pagination through a set of `State`."""
  statesByTrainingCountryAndStateList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): [State!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByTrainingCountryAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CountryProductsByTrainingCountryAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByTrainingCountryAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Checklist`."""
  checklistsByTrainingCountryAndChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): CountryChecklistsByTrainingCountryAndChecklistsManyToManyConnection!
  """Reads and enables pagination through a set of `Checklist`."""
  checklistsByTrainingCountryAndChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): [Checklist!]!
}

"""Methods to use when ordering `Training`."""
enum TrainingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  SUBJECT_ASC
  SUBJECT_DESC
  CONTENT_ASC
  CONTENT_DESC
  MEDIA_ASC
  MEDIA_DESC
  LINK_ASC
  LINK_DESC
  STEPS_ASC
  STEPS_DESC
  UPDATED_ASC
  UPDATED_DESC
  ANALYTICS_ASC
  ANALYTICS_DESC
  COMPETENCY_ASC
  COMPETENCY_DESC
  COURSE_ASC
  COURSE_DESC
  GRADE_ASC
  GRADE_DESC
  SCHOOL_ASC
  SCHOOL_DESC
  COMMENT_ASC
  COMMENT_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  STATE_ASC
  STATE_DESC
  POSTAL_ASC
  POSTAL_DESC
  TEACHER_ASC
  TEACHER_DESC
  STUDENT_ASC
  STUDENT_DESC
  ANNCOUNCEMENT_ASC
  ANNCOUNCEMENT_DESC
  RESOURCE_ASC
  RESOURCE_DESC
  BADGES_ASC
  BADGES_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  IS_COMPLETED_ASC
  IS_COMPLETED_DESC
  SPEAKERS_ASC
  SPEAKERS_DESC
  FIELD_TRIPS_ASC
  FIELD_TRIPS_DESC
  ASSIGNMENTS_ASC
  ASSIGNMENTS_DESC
  ASSIGNMENTS_DUE_DATE_ASC
  ASSIGNMENTS_DUE_DATE_DESC
  ORIGANLITY_REPORT_ASC
  ORIGANLITY_REPORT_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  FAQS_ASC
  FAQS_DESC
  LANGUAGES_ASC
  LANGUAGES_DESC
  CHECKLISTS_ASC
  CHECKLISTS_DESC
  CITY_ASC
  CITY_DESC
  MEETUPS_ASC
  MEETUPS_DESC
  LAB_ASC
  LAB_DESC
  DIGIBOARDS_ASC
  DIGIBOARDS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Training` object types. All fields are tested
for equality and combined with a logical and.
"""
input TrainingCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `subject` field."""
  subject: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `link` field."""
  link: String
  """Checks for equality with the objects `steps` field."""
  steps: String
  """Checks for equality with the objects `updated` field."""
  updated: Datetime
  """Checks for equality with the objects `analytics` field."""
  analytics: String
  """Checks for equality with the objects `competency` field."""
  competency: String
  """Checks for equality with the objects `course` field."""
  course: String
  """Checks for equality with the objects `grade` field."""
  grade: String
  """Checks for equality with the objects `school` field."""
  school: String
  """Checks for equality with the objects `comment` field."""
  comment: Int
  """Checks for equality with the objects `address` field."""
  address: String
  """Checks for equality with the objects `country` field."""
  country: Int
  """Checks for equality with the objects `state` field."""
  state: Int
  """Checks for equality with the objects `postal` field."""
  postal: String
  """Checks for equality with the objects `teacher` field."""
  teacher: String
  """Checks for equality with the objects `student` field."""
  student: String
  """Checks for equality with the objects `anncouncement` field."""
  anncouncement: String
  """Checks for equality with the objects `resource` field."""
  resource: String
  """Checks for equality with the objects `badges` field."""
  badges: String
  """Checks for equality with the objects `isPublic` field."""
  isPublic: String
  """Checks for equality with the objects `isCompleted` field."""
  isCompleted: String
  """Checks for equality with the objects `speakers` field."""
  speakers: String
  """Checks for equality with the objects `fieldTrips` field."""
  fieldTrips: String
  """Checks for equality with the objects `assignments` field."""
  assignments: String
  """Checks for equality with the objects `assignmentsDueDate` field."""
  assignmentsDueDate: String
  """Checks for equality with the objects `origanlityReport` field."""
  origanlityReport: String
  """Checks for equality with the objects `products` field."""
  products: BigInt
  """Checks for equality with the objects `faqs` field."""
  faqs: String
  """Checks for equality with the objects `languages` field."""
  languages: String
  """Checks for equality with the objects `checklists` field."""
  checklists: BigInt
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `meetups` field."""
  meetups: String
  """Checks for equality with the objects `lab` field."""
  lab: String
  """Checks for equality with the objects `digiboards` field."""
  digiboards: String
}

"""A connection to a list of `Comment` values, with data from `Training`."""
type CountryCommentsByTrainingCountryAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [CountryCommentsByTrainingCountryAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Training`."""
type CountryCommentsByTrainingCountryAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Training`."""
  trainingsByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""Methods to use when ordering `Comment`."""
enum CommentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CUSTOMER_NAME_ASC
  CUSTOMER_NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  RESPONSE_ASC
  RESPONSE_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Comment` object types. All fields are tested for equality and combined with a logical and."""
input CommentCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `customerName` field."""
  customerName: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `response` field."""
  response: String
  """Checks for equality with the objects `published` field."""
  published: Datetime
  """Checks for equality with the objects `custId` field."""
  custId: Int
}

"""A connection to a list of `State` values, with data from `Training`."""
type CountryStatesByTrainingCountryAndStateManyToManyConnection {
  """A list of `State` objects."""
  nodes: [State]!
  """A list of edges which contains the `State`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [CountryStatesByTrainingCountryAndStateManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `State` you could get from the connection."""
  totalCount: Int!
}

type State implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  description: String
  country: String
  image: String
  """Reads and enables pagination through a set of `Training`."""
  trainingsByState(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByStateList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByTrainingStateAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): StateCommentsByTrainingStateAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByTrainingStateAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `Country`."""
  countriesByTrainingStateAndCountry(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): StateCountriesByTrainingStateAndCountryManyToManyConnection!
  """Reads and enables pagination through a set of `Country`."""
  countriesByTrainingStateAndCountryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): [Country!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByTrainingStateAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): StateProductsByTrainingStateAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByTrainingStateAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Checklist`."""
  checklistsByTrainingStateAndChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): StateChecklistsByTrainingStateAndChecklistsManyToManyConnection!
  """Reads and enables pagination through a set of `Checklist`."""
  checklistsByTrainingStateAndChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): [Checklist!]!
}

"""A connection to a list of `Comment` values, with data from `Training`."""
type StateCommentsByTrainingStateAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [StateCommentsByTrainingStateAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Training`."""
type StateCommentsByTrainingStateAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Training`."""
  trainingsByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `Country` values, with data from `Training`."""
type StateCountriesByTrainingStateAndCountryManyToManyConnection {
  """A list of `Country` objects."""
  nodes: [Country]!
  """A list of edges which contains the `Country`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [StateCountriesByTrainingStateAndCountryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Country` you could get from the connection."""
  totalCount: Int!
}

"""A `Country` edge in the connection, with data from `Training`."""
type StateCountriesByTrainingStateAndCountryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Country` at the end of the edge."""
  node: Country
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountry(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""Methods to use when ordering `Country`."""
enum CountriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  REGION_ASC
  REGION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical and."""
input CountryCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `region` field."""
  region: String
}

"""A connection to a list of `Product` values, with data from `Training`."""
type StateProductsByTrainingStateAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [StateProductsByTrainingStateAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Training`."""
type StateProductsByTrainingStateAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""Methods to use when ordering `Product`."""
enum ProductsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  SKU_ASC
  SKU_DESC
  THUMBNAIL_ASC
  THUMBNAIL_DESC
  NAME_ASC
  NAME_DESC
  TYPES_ASC
  TYPES_DESC
  ATTRIBUTES_ASC
  ATTRIBUTES_DESC
  PRICE_ASC
  PRICE_DESC
  QUANTITY_PER_SOURCE_ASC
  QUANTITY_PER_SOURCE_DESC
  SALABLE_QUANTITY_ASC
  SALABLE_QUANTITY_DESC
  VISIBILITY_ASC
  VISIBILITY_DESC
  STATUS_ASC
  STATUS_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  TAX_CLASS_ASC
  TAX_CLASS_DESC
  STOCK_STATUS_ASC
  STOCK_STATUS_DESC
  WEIGHT_ASC
  WEIGHT_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  SIZE_ASC
  SIZE_DESC
  FORMAT_ASC
  FORMAT_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  CONTENT_ASC
  CONTENT_DESC
  SHORT_DESCRIPTION_ASC
  SHORT_DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  META_TITLE_ASC
  META_TITLE_DESC
  META_KEYWORDS_ASC
  META_KEYWORDS_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  META_URL_ASC
  META_URL_DESC
  FILE_ASC
  FILE_DESC
  MANUFACTURE_ASC
  MANUFACTURE_DESC
  PART_NUMBER_ASC
  PART_NUMBER_DESC
  CONTRACT_ASC
  CONTRACT_DESC
  COST_STRING_ASC
  COST_STRING_DESC
  MANUFACTURER_PART_NUMBER_ASC
  MANUFACTURER_PART_NUMBER_DESC
  RELATED_PRODUCT_ASC
  RELATED_PRODUCT_DESC
  TAGS_ASC
  TAGS_DESC
  BRAND_ASC
  BRAND_DESC
  OCCASSIONS_ASC
  OCCASSIONS_DESC
  CUSTOMER_TYPE_ASC
  CUSTOMER_TYPE_DESC
  FAMILY_ASC
  FAMILY_DESC
  ZONE_ASC
  ZONE_DESC
  VARIANTS_ASC
  VARIANTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Product` object types. All fields are tested for equality and combined with a logical and."""
input ProductCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `sku` field."""
  sku: BigInt
  """Checks for equality with the objects `thumbnail` field."""
  thumbnail: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `types` field."""
  types: String
  """Checks for equality with the objects `attributes` field."""
  attributes: String
  """Checks for equality with the objects `price` field."""
  price: String
  """Checks for equality with the objects `quantityPerSource` field."""
  quantityPerSource: String
  """Checks for equality with the objects `salableQuantity` field."""
  salableQuantity: String
  """Checks for equality with the objects `visibility` field."""
  visibility: String
  """Checks for equality with the objects `status` field."""
  status: Boolean
  """Checks for equality with the objects `websites` field."""
  websites: String
  """Checks for equality with the objects `product` field."""
  product: String
  """Checks for equality with the objects `taxClass` field."""
  taxClass: String
  """Checks for equality with the objects `stockStatus` field."""
  stockStatus: String
  """Checks for equality with the objects `weight` field."""
  weight: String
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `size` field."""
  size: String
  """Checks for equality with the objects `format` field."""
  format: String
  """Checks for equality with the objects `height` field."""
  height: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `shortDescription` field."""
  shortDescription: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `metaTitle` field."""
  metaTitle: String
  """Checks for equality with the objects `metaKeywords` field."""
  metaKeywords: String
  """Checks for equality with the objects `metaDescription` field."""
  metaDescription: String
  """Checks for equality with the objects `metaUrl` field."""
  metaUrl: String
  """Checks for equality with the objects `file` field."""
  file: String
  """Checks for equality with the objects `manufacture` field."""
  manufacture: String
  """Checks for equality with the objects `partNumber` field."""
  partNumber: String
  """Checks for equality with the objects `contract` field."""
  contract: String
  """Checks for equality with the objects `costString` field."""
  costString: String
  """Checks for equality with the objects `manufacturerPartNumber` field."""
  manufacturerPartNumber: String
  """Checks for equality with the objects `relatedProduct` field."""
  relatedProduct: BigInt
  """Checks for equality with the objects `tags` field."""
  tags: String
  """Checks for equality with the objects `brand` field."""
  brand: String
  """Checks for equality with the objects `occassions` field."""
  occassions: String
  """Checks for equality with the objects `customerType` field."""
  customerType: String
  """Checks for equality with the objects `family` field."""
  family: String
  """Checks for equality with the objects `zone` field."""
  zone: String
  """Checks for equality with the objects `variants` field."""
  variants: String
}

"""A connection to a list of `Checklist` values, with data from `Training`."""
type StateChecklistsByTrainingStateAndChecklistsManyToManyConnection {
  """A list of `Checklist` objects."""
  nodes: [Checklist]!
  """A list of edges which contains the `Checklist`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [StateChecklistsByTrainingStateAndChecklistsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Checklist` you could get from the connection."""
  totalCount: Int!
}

type Checklist implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  username: String
  location: String
  regionalManager: String
  manager: String
  description: String
  ticket: String
  project: String
  region: String
  country: String
  media: String
  prodId: String
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByTrainingChecklistsAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): ChecklistCommentsByTrainingChecklistsAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByTrainingChecklistsAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `Country`."""
  countriesByTrainingChecklistsAndCountry(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): ChecklistCountriesByTrainingChecklistsAndCountryManyToManyConnection!
  """Reads and enables pagination through a set of `Country`."""
  countriesByTrainingChecklistsAndCountryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): [Country!]!
  """Reads and enables pagination through a set of `State`."""
  statesByTrainingChecklistsAndState(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): ChecklistStatesByTrainingChecklistsAndStateManyToManyConnection!
  """Reads and enables pagination through a set of `State`."""
  statesByTrainingChecklistsAndStateList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): [State!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByTrainingChecklistsAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): ChecklistProductsByTrainingChecklistsAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByTrainingChecklistsAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
}

"""A connection to a list of `Comment` values, with data from `Training`."""
type ChecklistCommentsByTrainingChecklistsAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [ChecklistCommentsByTrainingChecklistsAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Training`."""
type ChecklistCommentsByTrainingChecklistsAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Training`."""
  trainingsByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `Country` values, with data from `Training`."""
type ChecklistCountriesByTrainingChecklistsAndCountryManyToManyConnection {
  """A list of `Country` objects."""
  nodes: [Country]!
  """A list of edges which contains the `Country`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [ChecklistCountriesByTrainingChecklistsAndCountryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Country` you could get from the connection."""
  totalCount: Int!
}

"""A `Country` edge in the connection, with data from `Training`."""
type ChecklistCountriesByTrainingChecklistsAndCountryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Country` at the end of the edge."""
  node: Country
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountry(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `State` values, with data from `Training`."""
type ChecklistStatesByTrainingChecklistsAndStateManyToManyConnection {
  """A list of `State` objects."""
  nodes: [State]!
  """A list of edges which contains the `State`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [ChecklistStatesByTrainingChecklistsAndStateManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `State` you could get from the connection."""
  totalCount: Int!
}

"""A `State` edge in the connection, with data from `Training`."""
type ChecklistStatesByTrainingChecklistsAndStateManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `State` at the end of the edge."""
  node: State
  """Reads and enables pagination through a set of `Training`."""
  trainingsByState(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByStateList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""Methods to use when ordering `State`."""
enum StatesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  IMAGE_ASC
  IMAGE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `State` object types. All fields are tested for equality and combined with a logical and."""
input StateCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `image` field."""
  image: String
}

"""A connection to a list of `Product` values, with data from `Training`."""
type ChecklistProductsByTrainingChecklistsAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [ChecklistProductsByTrainingChecklistsAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Training`."""
type ChecklistProductsByTrainingChecklistsAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A `Checklist` edge in the connection, with data from `Training`."""
type StateChecklistsByTrainingStateAndChecklistsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Checklist` at the end of the edge."""
  node: Checklist
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""Methods to use when ordering `Checklist`."""
enum ChecklistsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  USERNAME_ASC
  USERNAME_DESC
  LOCATION_ASC
  LOCATION_DESC
  REGIONAL_MANAGER_ASC
  REGIONAL_MANAGER_DESC
  MANAGER_ASC
  MANAGER_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  TICKET_ASC
  TICKET_DESC
  PROJECT_ASC
  PROJECT_DESC
  REGION_ASC
  REGION_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  MEDIA_ASC
  MEDIA_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Checklist` object types. All fields are tested
for equality and combined with a logical and.
"""
input ChecklistCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `username` field."""
  username: String
  """Checks for equality with the objects `location` field."""
  location: String
  """Checks for equality with the objects `regionalManager` field."""
  regionalManager: String
  """Checks for equality with the objects `manager` field."""
  manager: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `ticket` field."""
  ticket: String
  """Checks for equality with the objects `project` field."""
  project: String
  """Checks for equality with the objects `region` field."""
  region: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `prodId` field."""
  prodId: String
}

"""A `State` edge in the connection, with data from `Training`."""
type CountryStatesByTrainingCountryAndStateManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `State` at the end of the edge."""
  node: State
  """Reads and enables pagination through a set of `Training`."""
  trainingsByState(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByStateList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `Product` values, with data from `Training`."""
type CountryProductsByTrainingCountryAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [CountryProductsByTrainingCountryAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Training`."""
type CountryProductsByTrainingCountryAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `Checklist` values, with data from `Training`."""
type CountryChecklistsByTrainingCountryAndChecklistsManyToManyConnection {
  """A list of `Checklist` objects."""
  nodes: [Checklist]!
  """A list of edges which contains the `Checklist`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [CountryChecklistsByTrainingCountryAndChecklistsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Checklist` you could get from the connection."""
  totalCount: Int!
}

"""A `Checklist` edge in the connection, with data from `Training`."""
type CountryChecklistsByTrainingCountryAndChecklistsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Checklist` at the end of the edge."""
  node: Checklist
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A `Training` edge in the connection."""
type TrainingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Training` at the end of the edge."""
  node: Training
}

"""A connection to a list of `Brand` values, with data from `Mediamanager`."""
type CommentBrandsByMediamanagerCommentAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CommentBrandsByMediamanagerCommentAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Mediamanager`."""
type CommentBrandsByMediamanagerCommentAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""Methods to use when ordering `Brand`."""
enum BrandsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  STATE_ASC
  STATE_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  CITY_ASC
  CITY_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  MEDIA_ASC
  MEDIA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Brand` object types. All fields are tested for equality and combined with a logical and."""
input BrandCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `code` field."""
  code: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `isPublic` field."""
  isPublic: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `product` field."""
  product: BigInt
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `media` field."""
  media: String
}

"""A connection to a list of `Customer` values, with data from `Mediamanager`."""
type CommentCustomersByMediamanagerCommentAndAuthorManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CommentCustomersByMediamanagerCommentAndAuthorManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Mediamanager`."""
type CommentCustomersByMediamanagerCommentAndAuthorManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""Methods to use when ordering `Customer`."""
enum CustomersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  THUMBNAIL_ASC
  THUMBNAIL_DESC
  NAME_PREFIX_ASC
  NAME_PREFIX_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  MIDDLE_NAME_ASC
  MIDDLE_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  CUSTOMER_GROUP_ASC
  CUSTOMER_GROUP_DESC
  PHONE_ASC
  PHONE_DESC
  ZIPCODE_ASC
  ZIPCODE_DESC
  NAME_SUFFIX_ASC
  NAME_SUFFIX_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  STATE_ASC
  STATE_DESC
  CUSTOMER_SINCE_ASC
  CUSTOMER_SINCE_DESC
  CONFIRMED_EMAIL_ASC
  CONFIRMED_EMAIL_DESC
  DATE_OF_BIRTH_ASC
  DATE_OF_BIRTH_DESC
  TAX_VAT_NUMBER_ASC
  TAX_VAT_NUMBER_DESC
  GENDER_ASC
  GENDER_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  SHORT_DESCRIPTION_ASC
  SHORT_DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ADDRESS_TWO_ASC
  ADDRESS_TWO_DESC
  PAYMENT_TYPE_ASC
  PAYMENT_TYPE_DESC
  USERNAME_ASC
  USERNAME_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Customer` object types. All fields are tested
for equality and combined with a logical and.
"""
input CustomerCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `thumbnail` field."""
  thumbnail: String
  """Checks for equality with the objects `namePrefix` field."""
  namePrefix: String
  """Checks for equality with the objects `firstName` field."""
  firstName: String
  """Checks for equality with the objects `middleName` field."""
  middleName: String
  """Checks for equality with the objects `lastName` field."""
  lastName: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `customerGroup` field."""
  customerGroup: String
  """Checks for equality with the objects `phone` field."""
  phone: String
  """Checks for equality with the objects `zipcode` field."""
  zipcode: String
  """Checks for equality with the objects `nameSuffix` field."""
  nameSuffix: String
  """Checks for equality with the objects `websites` field."""
  websites: String
  """Checks for equality with the objects `product` field."""
  product: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `customerSince` field."""
  customerSince: Datetime
  """Checks for equality with the objects `confirmedEmail` field."""
  confirmedEmail: String
  """Checks for equality with the objects `dateOfBirth` field."""
  dateOfBirth: String
  """Checks for equality with the objects `taxVatNumber` field."""
  taxVatNumber: String
  """Checks for equality with the objects `gender` field."""
  gender: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `shortDescription` field."""
  shortDescription: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `address` field."""
  address: String
  """Checks for equality with the objects `addressTwo` field."""
  addressTwo: String
  """Checks for equality with the objects `paymentType` field."""
  paymentType: String
  """Checks for equality with the objects `username` field."""
  username: String
  """Checks for equality with the objects `password` field."""
  password: String
}

"""A connection to a list of `Agreement` values, with data from `Mediamanager`."""
type CommentAgreementsByMediamanagerCommentAndAgreementsManyToManyConnection {
  """A list of `Agreement` objects."""
  nodes: [Agreement]!
  """A list of edges which contains the `Agreement`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CommentAgreementsByMediamanagerCommentAndAgreementsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Agreement` you could get from the connection."""
  totalCount: Int!
}

"""A `Agreement` edge in the connection, with data from `Mediamanager`."""
type CommentAgreementsByMediamanagerCommentAndAgreementsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Agreement` at the end of the edge."""
  node: Agreement
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""Methods to use when ordering `Agreement`."""
enum AgreementsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  REFERENCE_ID_ASC
  REFERENCE_ID_DESC
  CREATED_ASC
  CREATED_DESC
  UPDATED_ASC
  UPDATED_DESC
  CONTENT_ASC
  CONTENT_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  TYPE_ASC
  TYPE_DESC
  USER_ID_ASC
  USER_ID_DESC
  SHOP_ID_ASC
  SHOP_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Agreement` object types. All fields are tested
for equality and combined with a logical and.
"""
input AgreementCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `referenceId` field."""
  referenceId: String
  """Checks for equality with the objects `created` field."""
  created: Datetime
  """Checks for equality with the objects `updated` field."""
  updated: Datetime
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `excerpt` field."""
  excerpt: String
  """Checks for equality with the objects `type` field."""
  type: String
  """Checks for equality with the objects `userId` field."""
  userId: String
  """Checks for equality with the objects `shopId` field."""
  shopId: String
}

"""A connection to a list of `TodoList` values, with data from `Mediamanager`."""
type CommentTodoListsByMediamanagerCommentAndTaskNameManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CommentTodoListsByMediamanagerCommentAndTaskNameManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

type TodoList implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  subject: String
  startDate: String
  dueDate: String
  priority: String
  description: String
  status: String
  relatedTo: String
  contact: String
  assignedTo: String
  dateModified: Datetime
  task: String
  checklists: String
  visits: String
  projects: String
  tickets: String
  cases: String
  surveys: String
  articles: String
  endofshift: String
  name: String
  """Reads and enables pagination through a set of `Project`."""
  projectsByTaskId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByTaskIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByProjectTaskIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): TodoListCustomersByProjectTaskIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByProjectTaskIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `User`."""
  usersByProjectTaskIdAndStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): TodoListUsersByProjectTaskIdAndStaffIdManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByProjectTaskIdAndStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Ticketing`."""
  ticketingsByProjectTaskIdAndTicketId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): TodoListTicketingsByProjectTaskIdAndTicketIdManyToManyConnection!
  """Reads and enables pagination through a set of `Ticketing`."""
  ticketingsByProjectTaskIdAndTicketIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): [Ticketing!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerTaskNameAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): TodoListBrandsByMediamanagerTaskNameAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerTaskNameAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerTaskNameAndAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): TodoListCustomersByMediamanagerTaskNameAndAuthorManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerTaskNameAndAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerTaskNameAndAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): TodoListAgreementsByMediamanagerTaskNameAndAgreementsManyToManyConnection!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerTaskNameAndAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): [Agreement!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerTaskNameAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): TodoListCommentsByMediamanagerTaskNameAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerTaskNameAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerTaskNameAndMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): TodoListUsersByMediamanagerTaskNameAndMembersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByMediamanagerTaskNameAndMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerTaskNameAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): TodoListProductsByMediamanagerTaskNameAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerTaskNameAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceTasksAndCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): TodoListCustomersByWorkspaceTasksAndCustomersManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceTasksAndCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceTasksAndUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): TodoListUsersByWorkspaceTasksAndUsersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceTasksAndUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceTasksAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): TodoListProductsByWorkspaceTasksAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceTasksAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceTasksAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): TodoListBrandsByWorkspaceTasksAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceTasksAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceTasksAndShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): TodoListShopsByWorkspaceTasksAndShopsManyToManyConnection!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceTasksAndShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): [Shop!]!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceTasksAndCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): TodoListCategoriesByWorkspaceTasksAndCategoryManyToManyConnection!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceTasksAndCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): [Category!]!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceTasksAndProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): TodoListProjectsByWorkspaceTasksAndProjectsManyToManyConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceTasksAndProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `Project` values."""
type ProjectsConnection {
  """A list of `Project` objects."""
  nodes: [Project]!
  """A list of edges which contains the `Project` and cursor to aid in pagination."""
  edges: [ProjectsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

type Project implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String
  projectManager: String
  startDate: String
  endDate: String
  resource: String
  considerworkingdays: String
  projectTemplate: String
  status: String
  createdAt: Datetime
  priority: String
  assignee: String
  doing: String
  done: String
  sectionRule: String
  goalName: String
  goalTimeperiod: String
  goalPrivacy: String
  goalCollaborators: String
  goalUpdatemethod: String
  goalProgressSource: String
  goalMeasurement: String
  custId: Int
  staffId: Int
  taskId: BigInt
  ticketId: BigInt
  """Reads a single `Customer` that is related to this `Project`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Project`."""
  userByStaffId: User
  """Reads a single `TodoList` that is related to this `Project`."""
  todoListByTaskId: TodoList
  """Reads a single `Ticketing` that is related to this `Project`."""
  ticketingByTicketId: Ticketing
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceProjectsAndCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): ProjectCustomersByWorkspaceProjectsAndCustomersManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceProjectsAndCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceProjectsAndUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): ProjectUsersByWorkspaceProjectsAndUsersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceProjectsAndUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceProjectsAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): ProjectProductsByWorkspaceProjectsAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceProjectsAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceProjectsAndTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): ProjectTodoListsByWorkspaceProjectsAndTasksManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceProjectsAndTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceProjectsAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): ProjectBrandsByWorkspaceProjectsAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceProjectsAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceProjectsAndShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): ProjectShopsByWorkspaceProjectsAndShopsManyToManyConnection!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceProjectsAndShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): [Shop!]!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceProjectsAndCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): ProjectCategoriesByWorkspaceProjectsAndCategoryManyToManyConnection!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceProjectsAndCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): [Category!]!
}

type User implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  username: String!
  firstName: String!
  lastName: String
  email: String!
  password: String!
  interfaceLocale: String
  value: String
  permissions: String
  createdAt: Datetime
  """Reads and enables pagination through a set of `Email`."""
  emailsByStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): EmailsConnection!
  """Reads and enables pagination through a set of `Email`."""
  emailsByStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): [Email!]!
  """Reads and enables pagination through a set of `Project`."""
  projectsByStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
  """Reads and enables pagination through a set of `Message`."""
  messagesByStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): MessagesConnection!
  """Reads and enables pagination through a set of `Message`."""
  messagesByStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): [Message!]!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByEmailStaffIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): UserCustomersByEmailStaffIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByEmailStaffIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByProjectStaffIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): UserCustomersByProjectStaffIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByProjectStaffIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByProjectStaffIdAndTaskId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): UserTodoListsByProjectStaffIdAndTaskIdManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByProjectStaffIdAndTaskIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Ticketing`."""
  ticketingsByProjectStaffIdAndTicketId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): UserTicketingsByProjectStaffIdAndTicketIdManyToManyConnection!
  """Reads and enables pagination through a set of `Ticketing`."""
  ticketingsByProjectStaffIdAndTicketIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): [Ticketing!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMessageStaffIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): UserCustomersByMessageStaffIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMessageStaffIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerMembersAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): UserBrandsByMediamanagerMembersAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByMediamanagerMembersAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerMembersAndAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): UserCustomersByMediamanagerMembersAndAuthorManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByMediamanagerMembersAndAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerMembersAndAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): UserAgreementsByMediamanagerMembersAndAgreementsManyToManyConnection!
  """Reads and enables pagination through a set of `Agreement`."""
  agreementsByMediamanagerMembersAndAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): [Agreement!]!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerMembersAndComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): UserCommentsByMediamanagerMembersAndCommentManyToManyConnection!
  """Reads and enables pagination through a set of `Comment`."""
  commentsByMediamanagerMembersAndCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerMembersAndTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): UserTodoListsByMediamanagerMembersAndTaskNameManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByMediamanagerMembersAndTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerMembersAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): UserProductsByMediamanagerMembersAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByMediamanagerMembersAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceUsersAndCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): UserCustomersByWorkspaceUsersAndCustomersManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceUsersAndCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceUsersAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): UserProductsByWorkspaceUsersAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceUsersAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceUsersAndTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): UserTodoListsByWorkspaceUsersAndTasksManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceUsersAndTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceUsersAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): UserBrandsByWorkspaceUsersAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceUsersAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceUsersAndShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): UserShopsByWorkspaceUsersAndShopsManyToManyConnection!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceUsersAndShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): [Shop!]!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceUsersAndCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): UserCategoriesByWorkspaceUsersAndCategoryManyToManyConnection!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceUsersAndCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): [Category!]!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceUsersAndProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): UserProjectsByWorkspaceUsersAndProjectsManyToManyConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceUsersAndProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `Email` values."""
type EmailsConnection {
  """A list of `Email` objects."""
  nodes: [Email]!
  """A list of edges which contains the `Email` and cursor to aid in pagination."""
  edges: [EmailsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Email` you could get from the connection."""
  totalCount: Int!
}

type Email implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  createdAt: Datetime
  subject: String
  content: String
  custId: Int!
  bcc: String
  cc: String
  from: String
  media: String
  staffId: Int
  """Reads a single `Customer` that is related to this `Email`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Email`."""
  userByStaffId: User
}

"""A `Email` edge in the connection."""
type EmailsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Email` at the end of the edge."""
  node: Email
}

"""Methods to use when ordering `Email`."""
enum EmailsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  SUBJECT_ASC
  SUBJECT_DESC
  CONTENT_ASC
  CONTENT_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  BCC_ASC
  BCC_DESC
  CC_ASC
  CC_DESC
  FROM_ASC
  FROM_DESC
  MEDIA_ASC
  MEDIA_DESC
  STAFF_ID_ASC
  STAFF_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Email` object types. All fields are tested for equality and combined with a logical and."""
input EmailCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `subject` field."""
  subject: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `custId` field."""
  custId: Int
  """Checks for equality with the objects `bcc` field."""
  bcc: String
  """Checks for equality with the objects `cc` field."""
  cc: String
  """Checks for equality with the objects `from` field."""
  from: String
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `staffId` field."""
  staffId: Int
}

"""Methods to use when ordering `Project`."""
enum ProjectsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PROJECT_MANAGER_ASC
  PROJECT_MANAGER_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  RESOURCE_ASC
  RESOURCE_DESC
  CONSIDERWORKINGDAYS_ASC
  CONSIDERWORKINGDAYS_DESC
  PROJECT_TEMPLATE_ASC
  PROJECT_TEMPLATE_DESC
  STATUS_ASC
  STATUS_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  ASSIGNEE_ASC
  ASSIGNEE_DESC
  DOING_ASC
  DOING_DESC
  DONE_ASC
  DONE_DESC
  SECTION_RULE_ASC
  SECTION_RULE_DESC
  GOAL_NAME_ASC
  GOAL_NAME_DESC
  GOAL_TIMEPERIOD_ASC
  GOAL_TIMEPERIOD_DESC
  GOAL_PRIVACY_ASC
  GOAL_PRIVACY_DESC
  GOAL_COLLABORATORS_ASC
  GOAL_COLLABORATORS_DESC
  GOAL_UPDATEMETHOD_ASC
  GOAL_UPDATEMETHOD_DESC
  GOAL_PROGRESS_SOURCE_ASC
  GOAL_PROGRESS_SOURCE_DESC
  GOAL_MEASUREMENT_ASC
  GOAL_MEASUREMENT_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  STAFF_ID_ASC
  STAFF_ID_DESC
  TASK_ID_ASC
  TASK_ID_DESC
  TICKET_ID_ASC
  TICKET_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical and."""
input ProjectCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `projectManager` field."""
  projectManager: String
  """Checks for equality with the objects `startDate` field."""
  startDate: String
  """Checks for equality with the objects `endDate` field."""
  endDate: String
  """Checks for equality with the objects `resource` field."""
  resource: String
  """Checks for equality with the objects `considerworkingdays` field."""
  considerworkingdays: String
  """Checks for equality with the objects `projectTemplate` field."""
  projectTemplate: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `priority` field."""
  priority: String
  """Checks for equality with the objects `assignee` field."""
  assignee: String
  """Checks for equality with the objects `doing` field."""
  doing: String
  """Checks for equality with the objects `done` field."""
  done: String
  """Checks for equality with the objects `sectionRule` field."""
  sectionRule: String
  """Checks for equality with the objects `goalName` field."""
  goalName: String
  """Checks for equality with the objects `goalTimeperiod` field."""
  goalTimeperiod: String
  """Checks for equality with the objects `goalPrivacy` field."""
  goalPrivacy: String
  """Checks for equality with the objects `goalCollaborators` field."""
  goalCollaborators: String
  """Checks for equality with the objects `goalUpdatemethod` field."""
  goalUpdatemethod: String
  """Checks for equality with the objects `goalProgressSource` field."""
  goalProgressSource: String
  """Checks for equality with the objects `goalMeasurement` field."""
  goalMeasurement: String
  """Checks for equality with the objects `custId` field."""
  custId: Int
  """Checks for equality with the objects `staffId` field."""
  staffId: Int
  """Checks for equality with the objects `taskId` field."""
  taskId: BigInt
  """Checks for equality with the objects `ticketId` field."""
  ticketId: BigInt
}

"""A connection to a list of `Message` values."""
type MessagesConnection {
  """A list of `Message` objects."""
  nodes: [Message]!
  """A list of edges which contains the `Message` and cursor to aid in pagination."""
  edges: [MessagesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Message` you could get from the connection."""
  totalCount: Int!
}

type Message implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  from: String
  createdAt: Datetime
  subject: String
  content: String
  sender: String
  custId: Int!
  media: String
  staffId: Int
  """Reads a single `Customer` that is related to this `Message`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Message`."""
  userByStaffId: User
}

"""A `Message` edge in the connection."""
type MessagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Message` at the end of the edge."""
  node: Message
}

"""Methods to use when ordering `Message`."""
enum MessagesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FROM_ASC
  FROM_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  SUBJECT_ASC
  SUBJECT_DESC
  CONTENT_ASC
  CONTENT_DESC
  SENDER_ASC
  SENDER_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  MEDIA_ASC
  MEDIA_DESC
  STAFF_ID_ASC
  STAFF_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical and."""
input MessageCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `from` field."""
  from: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `subject` field."""
  subject: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `sender` field."""
  sender: String
  """Checks for equality with the objects `custId` field."""
  custId: Int
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `staffId` field."""
  staffId: Int
}

"""A connection to a list of `Workspace` values."""
type WorkspacesConnection {
  """A list of `Workspace` objects."""
  nodes: [Workspace]!
  """A list of edges which contains the `Workspace` and cursor to aid in pagination."""
  edges: [WorkspacesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Workspace` you could get from the connection."""
  totalCount: Int!
}

type Workspace implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  description: String
  customers: Int
  users: Int
  products: BigInt
  tasks: BigInt
  brands: BigInt
  shops: Int
  category: Int
  isPublic: Boolean
  projects: BigInt
  author: String
  media: String
  """Reads a single `Customer` that is related to this `Workspace`."""
  customerByCustomers: Customer
  """Reads a single `User` that is related to this `Workspace`."""
  userByUsers: User
  """Reads a single `Product` that is related to this `Workspace`."""
  productByProducts: Product
  """Reads a single `TodoList` that is related to this `Workspace`."""
  todoListByTasks: TodoList
  """Reads a single `Brand` that is related to this `Workspace`."""
  brandByBrands: Brand
  """Reads a single `Shop` that is related to this `Workspace`."""
  shopByShops: Shop
  """Reads a single `Category` that is related to this `Workspace`."""
  categoryByCategory: Category
  """Reads a single `Project` that is related to this `Workspace`."""
  projectByProjects: Project
}

type Shop implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  description: String
  image: String
  website: String
  products: String
  articles: String
  customers: String
  comments: String
  coupons: String
  categories: String
  polls: String
  quotes: String
  reviews: String
  giftCertificates: String
  rating: String
  tags: String
  users: String
  invoices: String
  reports: String
  rewardPoints: String
  specialDiscounts: String
  statistics: String
  stocks: String
  country: String
  physicalStore: String
  type: String
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceShopsAndCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): ShopCustomersByWorkspaceShopsAndCustomersManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceShopsAndCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceShopsAndUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): ShopUsersByWorkspaceShopsAndUsersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceShopsAndUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceShopsAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): ShopProductsByWorkspaceShopsAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceShopsAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceShopsAndTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): ShopTodoListsByWorkspaceShopsAndTasksManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceShopsAndTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceShopsAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): ShopBrandsByWorkspaceShopsAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceShopsAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceShopsAndCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): ShopCategoriesByWorkspaceShopsAndCategoryManyToManyConnection!
  """Reads and enables pagination through a set of `Category`."""
  categoriesByWorkspaceShopsAndCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): [Category!]!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceShopsAndProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ShopProjectsByWorkspaceShopsAndProjectsManyToManyConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceShopsAndProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""Methods to use when ordering `Workspace`."""
enum WorkspacesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  TASKS_ASC
  TASKS_DESC
  BRANDS_ASC
  BRANDS_DESC
  SHOPS_ASC
  SHOPS_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  AUTHOR_ASC
  AUTHOR_DESC
  MEDIA_ASC
  MEDIA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Workspace` object types. All fields are tested
for equality and combined with a logical and.
"""
input WorkspaceCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `code` field."""
  code: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `customers` field."""
  customers: Int
  """Checks for equality with the objects `users` field."""
  users: Int
  """Checks for equality with the objects `products` field."""
  products: BigInt
  """Checks for equality with the objects `tasks` field."""
  tasks: BigInt
  """Checks for equality with the objects `brands` field."""
  brands: BigInt
  """Checks for equality with the objects `shops` field."""
  shops: Int
  """Checks for equality with the objects `category` field."""
  category: Int
  """Checks for equality with the objects `isPublic` field."""
  isPublic: Boolean
  """Checks for equality with the objects `projects` field."""
  projects: BigInt
  """Checks for equality with the objects `author` field."""
  author: String
  """Checks for equality with the objects `media` field."""
  media: String
}

"""A connection to a list of `Customer` values, with data from `Workspace`."""
type ShopCustomersByWorkspaceShopsAndCustomersManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ShopCustomersByWorkspaceShopsAndCustomersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Workspace`."""
type ShopCustomersByWorkspaceShopsAndCustomersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `User` values, with data from `Workspace`."""
type ShopUsersByWorkspaceShopsAndUsersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ShopUsersByWorkspaceShopsAndUsersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Workspace`."""
type ShopUsersByWorkspaceShopsAndUsersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USERNAME_ASC
  USERNAME_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  INTERFACE_LOCALE_ASC
  INTERFACE_LOCALE_DESC
  VALUE_ASC
  VALUE_DESC
  PERMISSIONS_ASC
  PERMISSIONS_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `User` object types. All fields are tested for equality and combined with a logical and."""
input UserCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `username` field."""
  username: String
  """Checks for equality with the objects `firstName` field."""
  firstName: String
  """Checks for equality with the objects `lastName` field."""
  lastName: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `password` field."""
  password: String
  """Checks for equality with the objects `interfaceLocale` field."""
  interfaceLocale: String
  """Checks for equality with the objects `value` field."""
  value: String
  """Checks for equality with the objects `permissions` field."""
  permissions: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
}

"""A connection to a list of `Product` values, with data from `Workspace`."""
type ShopProductsByWorkspaceShopsAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ShopProductsByWorkspaceShopsAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Workspace`."""
type ShopProductsByWorkspaceShopsAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `TodoList` values, with data from `Workspace`."""
type ShopTodoListsByWorkspaceShopsAndTasksManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ShopTodoListsByWorkspaceShopsAndTasksManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Workspace`."""
type ShopTodoListsByWorkspaceShopsAndTasksManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""Methods to use when ordering `TodoList`."""
enum TodoListsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  SUBJECT_ASC
  SUBJECT_DESC
  START_DATE_ASC
  START_DATE_DESC
  DUE_DATE_ASC
  DUE_DATE_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  STATUS_ASC
  STATUS_DESC
  RELATED_TO_ASC
  RELATED_TO_DESC
  CONTACT_ASC
  CONTACT_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  DATE_MODIFIED_ASC
  DATE_MODIFIED_DESC
  TASK_ASC
  TASK_DESC
  CHECKLISTS_ASC
  CHECKLISTS_DESC
  VISITS_ASC
  VISITS_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  TICKETS_ASC
  TICKETS_DESC
  CASES_ASC
  CASES_DESC
  SURVEYS_ASC
  SURVEYS_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  ENDOFSHIFT_ASC
  ENDOFSHIFT_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TodoList` object types. All fields are tested
for equality and combined with a logical and.
"""
input TodoListCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `subject` field."""
  subject: String
  """Checks for equality with the objects `startDate` field."""
  startDate: String
  """Checks for equality with the objects `dueDate` field."""
  dueDate: String
  """Checks for equality with the objects `priority` field."""
  priority: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `relatedTo` field."""
  relatedTo: String
  """Checks for equality with the objects `contact` field."""
  contact: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `dateModified` field."""
  dateModified: Datetime
  """Checks for equality with the objects `task` field."""
  task: String
  """Checks for equality with the objects `checklists` field."""
  checklists: String
  """Checks for equality with the objects `visits` field."""
  visits: String
  """Checks for equality with the objects `projects` field."""
  projects: String
  """Checks for equality with the objects `tickets` field."""
  tickets: String
  """Checks for equality with the objects `cases` field."""
  cases: String
  """Checks for equality with the objects `surveys` field."""
  surveys: String
  """Checks for equality with the objects `articles` field."""
  articles: String
  """Checks for equality with the objects `endofshift` field."""
  endofshift: String
  """Checks for equality with the objects `name` field."""
  name: String
}

"""A connection to a list of `Brand` values, with data from `Workspace`."""
type ShopBrandsByWorkspaceShopsAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ShopBrandsByWorkspaceShopsAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Workspace`."""
type ShopBrandsByWorkspaceShopsAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Category` values, with data from `Workspace`."""
type ShopCategoriesByWorkspaceShopsAndCategoryManyToManyConnection {
  """A list of `Category` objects."""
  nodes: [Category]!
  """A list of edges which contains the `Category`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ShopCategoriesByWorkspaceShopsAndCategoryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

type Category implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  thumbnail: String
  name: String!
  visibility: String
  status: Boolean
  websites: String
  product: String
  country: String
  description: String
  content: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceCategoryAndCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): CategoryCustomersByWorkspaceCategoryAndCustomersManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByWorkspaceCategoryAndCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceCategoryAndUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): CategoryUsersByWorkspaceCategoryAndUsersManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByWorkspaceCategoryAndUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceCategoryAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): CategoryProductsByWorkspaceCategoryAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByWorkspaceCategoryAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceCategoryAndTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): CategoryTodoListsByWorkspaceCategoryAndTasksManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByWorkspaceCategoryAndTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceCategoryAndBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): CategoryBrandsByWorkspaceCategoryAndBrandsManyToManyConnection!
  """Reads and enables pagination through a set of `Brand`."""
  brandsByWorkspaceCategoryAndBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceCategoryAndShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): CategoryShopsByWorkspaceCategoryAndShopsManyToManyConnection!
  """Reads and enables pagination through a set of `Shop`."""
  shopsByWorkspaceCategoryAndShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): [Shop!]!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceCategoryAndProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): CategoryProjectsByWorkspaceCategoryAndProjectsManyToManyConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByWorkspaceCategoryAndProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `Customer` values, with data from `Workspace`."""
type CategoryCustomersByWorkspaceCategoryAndCustomersManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CategoryCustomersByWorkspaceCategoryAndCustomersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Workspace`."""
type CategoryCustomersByWorkspaceCategoryAndCustomersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `User` values, with data from `Workspace`."""
type CategoryUsersByWorkspaceCategoryAndUsersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CategoryUsersByWorkspaceCategoryAndUsersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Workspace`."""
type CategoryUsersByWorkspaceCategoryAndUsersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Product` values, with data from `Workspace`."""
type CategoryProductsByWorkspaceCategoryAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CategoryProductsByWorkspaceCategoryAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Workspace`."""
type CategoryProductsByWorkspaceCategoryAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `TodoList` values, with data from `Workspace`."""
type CategoryTodoListsByWorkspaceCategoryAndTasksManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CategoryTodoListsByWorkspaceCategoryAndTasksManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Workspace`."""
type CategoryTodoListsByWorkspaceCategoryAndTasksManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Brand` values, with data from `Workspace`."""
type CategoryBrandsByWorkspaceCategoryAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CategoryBrandsByWorkspaceCategoryAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Workspace`."""
type CategoryBrandsByWorkspaceCategoryAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Shop` values, with data from `Workspace`."""
type CategoryShopsByWorkspaceCategoryAndShopsManyToManyConnection {
  """A list of `Shop` objects."""
  nodes: [Shop]!
  """A list of edges which contains the `Shop`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CategoryShopsByWorkspaceCategoryAndShopsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Shop` you could get from the connection."""
  totalCount: Int!
}

"""A `Shop` edge in the connection, with data from `Workspace`."""
type CategoryShopsByWorkspaceCategoryAndShopsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Shop` at the end of the edge."""
  node: Shop
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""Methods to use when ordering `Shop`."""
enum ShopsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  COMMENTS_ASC
  COMMENTS_DESC
  COUPONS_ASC
  COUPONS_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  POLLS_ASC
  POLLS_DESC
  QUOTES_ASC
  QUOTES_DESC
  REVIEWS_ASC
  REVIEWS_DESC
  GIFT_CERTIFICATES_ASC
  GIFT_CERTIFICATES_DESC
  RATING_ASC
  RATING_DESC
  TAGS_ASC
  TAGS_DESC
  USERS_ASC
  USERS_DESC
  INVOICES_ASC
  INVOICES_DESC
  REPORTS_ASC
  REPORTS_DESC
  REWARD_POINTS_ASC
  REWARD_POINTS_DESC
  SPECIAL_DISCOUNTS_ASC
  SPECIAL_DISCOUNTS_DESC
  STATISTICS_ASC
  STATISTICS_DESC
  STOCKS_ASC
  STOCKS_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  PHYSICAL_STORE_ASC
  PHYSICAL_STORE_DESC
  TYPE_ASC
  TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Shop` object types. All fields are tested for equality and combined with a logical and."""
input ShopCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `website` field."""
  website: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `articles` field."""
  articles: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `comments` field."""
  comments: String
  """Checks for equality with the objects `coupons` field."""
  coupons: String
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `polls` field."""
  polls: String
  """Checks for equality with the objects `quotes` field."""
  quotes: String
  """Checks for equality with the objects `reviews` field."""
  reviews: String
  """Checks for equality with the objects `giftCertificates` field."""
  giftCertificates: String
  """Checks for equality with the objects `rating` field."""
  rating: String
  """Checks for equality with the objects `tags` field."""
  tags: String
  """Checks for equality with the objects `users` field."""
  users: String
  """Checks for equality with the objects `invoices` field."""
  invoices: String
  """Checks for equality with the objects `reports` field."""
  reports: String
  """Checks for equality with the objects `rewardPoints` field."""
  rewardPoints: String
  """Checks for equality with the objects `specialDiscounts` field."""
  specialDiscounts: String
  """Checks for equality with the objects `statistics` field."""
  statistics: String
  """Checks for equality with the objects `stocks` field."""
  stocks: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `physicalStore` field."""
  physicalStore: String
  """Checks for equality with the objects `type` field."""
  type: String
}

"""A connection to a list of `Project` values, with data from `Workspace`."""
type CategoryProjectsByWorkspaceCategoryAndProjectsManyToManyConnection {
  """A list of `Project` objects."""
  nodes: [Project]!
  """A list of edges which contains the `Project`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CategoryProjectsByWorkspaceCategoryAndProjectsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

"""A `Project` edge in the connection, with data from `Workspace`."""
type CategoryProjectsByWorkspaceCategoryAndProjectsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Project` at the end of the edge."""
  node: Project
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A `Category` edge in the connection, with data from `Workspace`."""
type ShopCategoriesByWorkspaceShopsAndCategoryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Category` at the end of the edge."""
  node: Category
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""Methods to use when ordering `Category`."""
enum CategoriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  THUMBNAIL_ASC
  THUMBNAIL_DESC
  NAME_ASC
  NAME_DESC
  VISIBILITY_ASC
  VISIBILITY_DESC
  STATUS_ASC
  STATUS_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CONTENT_ASC
  CONTENT_DESC
  IMAGE_ASC
  IMAGE_DESC
  META_TITLE_ASC
  META_TITLE_DESC
  META_KEYWORDS_ASC
  META_KEYWORDS_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  META_URL_ASC
  META_URL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Category` object types. All fields are tested
for equality and combined with a logical and.
"""
input CategoryCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `thumbnail` field."""
  thumbnail: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `visibility` field."""
  visibility: String
  """Checks for equality with the objects `status` field."""
  status: Boolean
  """Checks for equality with the objects `websites` field."""
  websites: String
  """Checks for equality with the objects `product` field."""
  product: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `metaTitle` field."""
  metaTitle: String
  """Checks for equality with the objects `metaKeywords` field."""
  metaKeywords: String
  """Checks for equality with the objects `metaDescription` field."""
  metaDescription: String
  """Checks for equality with the objects `metaUrl` field."""
  metaUrl: String
}

"""A connection to a list of `Project` values, with data from `Workspace`."""
type ShopProjectsByWorkspaceShopsAndProjectsManyToManyConnection {
  """A list of `Project` objects."""
  nodes: [Project]!
  """A list of edges which contains the `Project`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ShopProjectsByWorkspaceShopsAndProjectsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

"""A `Project` edge in the connection, with data from `Workspace`."""
type ShopProjectsByWorkspaceShopsAndProjectsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Project` at the end of the edge."""
  node: Project
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A `Workspace` edge in the connection."""
type WorkspacesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Workspace` at the end of the edge."""
  node: Workspace
}

"""A connection to a list of `Customer` values, with data from `Email`."""
type UserCustomersByEmailStaffIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Email`, and the cursor to aid in pagination."""
  edges: [UserCustomersByEmailStaffIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Email`."""
type UserCustomersByEmailStaffIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Email`."""
  emailsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): EmailsConnection!
  """Reads and enables pagination through a set of `Email`."""
  emailsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): [Email!]!
}

"""A connection to a list of `Customer` values, with data from `Project`."""
type UserCustomersByProjectStaffIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [UserCustomersByProjectStaffIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Project`."""
type UserCustomersByProjectStaffIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Project`."""
  projectsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `TodoList` values, with data from `Project`."""
type UserTodoListsByProjectStaffIdAndTaskIdManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [UserTodoListsByProjectStaffIdAndTaskIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Project`."""
type UserTodoListsByProjectStaffIdAndTaskIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Project`."""
  projectsByTaskId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByTaskIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `Ticketing` values, with data from `Project`."""
type UserTicketingsByProjectStaffIdAndTicketIdManyToManyConnection {
  """A list of `Ticketing` objects."""
  nodes: [Ticketing]!
  """A list of edges which contains the `Ticketing`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [UserTicketingsByProjectStaffIdAndTicketIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Ticketing` you could get from the connection."""
  totalCount: Int!
}

type Ticketing implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  location: String
  date: String
  severity: String
  team: String
  requester: String
  requesterEmail: String
  content: String
  department: String
  media: String
  projects: String
  ticketType: String
  comment: String
  products: String
  priority: String
  status: String
  resolution: String
  assignedTo: String
  dateModified: Datetime
  accountName: String
  level: String
  """Reads and enables pagination through a set of `Project`."""
  projectsByTicketId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByTicketIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByProjectTicketIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): TicketingCustomersByProjectTicketIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByProjectTicketIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `User`."""
  usersByProjectTicketIdAndStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): TicketingUsersByProjectTicketIdAndStaffIdManyToManyConnection!
  """Reads and enables pagination through a set of `User`."""
  usersByProjectTicketIdAndStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByProjectTicketIdAndTaskId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): TicketingTodoListsByProjectTicketIdAndTaskIdManyToManyConnection!
  """Reads and enables pagination through a set of `TodoList`."""
  todoListsByProjectTicketIdAndTaskIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]!
}

"""A connection to a list of `Customer` values, with data from `Project`."""
type TicketingCustomersByProjectTicketIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [TicketingCustomersByProjectTicketIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Project`."""
type TicketingCustomersByProjectTicketIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Project`."""
  projectsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `User` values, with data from `Project`."""
type TicketingUsersByProjectTicketIdAndStaffIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [TicketingUsersByProjectTicketIdAndStaffIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Project`."""
type TicketingUsersByProjectTicketIdAndStaffIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Project`."""
  projectsByStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `TodoList` values, with data from `Project`."""
type TicketingTodoListsByProjectTicketIdAndTaskIdManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [TicketingTodoListsByProjectTicketIdAndTaskIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Project`."""
type TicketingTodoListsByProjectTicketIdAndTaskIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Project`."""
  projectsByTaskId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByTaskIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A `Ticketing` edge in the connection, with data from `Project`."""
type UserTicketingsByProjectStaffIdAndTicketIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Ticketing` at the end of the edge."""
  node: Ticketing
  """Reads and enables pagination through a set of `Project`."""
  projectsByTicketId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByTicketIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""Methods to use when ordering `Ticketing`."""
enum TicketingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  LOCATION_ASC
  LOCATION_DESC
  DATE_ASC
  DATE_DESC
  SEVERITY_ASC
  SEVERITY_DESC
  TEAM_ASC
  TEAM_DESC
  REQUESTER_ASC
  REQUESTER_DESC
  REQUESTER_EMAIL_ASC
  REQUESTER_EMAIL_DESC
  CONTENT_ASC
  CONTENT_DESC
  DEPARTMENT_ASC
  DEPARTMENT_DESC
  MEDIA_ASC
  MEDIA_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  TICKET_TYPE_ASC
  TICKET_TYPE_DESC
  COMMENT_ASC
  COMMENT_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  STATUS_ASC
  STATUS_DESC
  RESOLUTION_ASC
  RESOLUTION_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  DATE_MODIFIED_ASC
  DATE_MODIFIED_DESC
  ACCOUNT_NAME_ASC
  ACCOUNT_NAME_DESC
  LEVEL_ASC
  LEVEL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Ticketing` object types. All fields are tested
for equality and combined with a logical and.
"""
input TicketingCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `location` field."""
  location: String
  """Checks for equality with the objects `date` field."""
  date: String
  """Checks for equality with the objects `severity` field."""
  severity: String
  """Checks for equality with the objects `team` field."""
  team: String
  """Checks for equality with the objects `requester` field."""
  requester: String
  """Checks for equality with the objects `requesterEmail` field."""
  requesterEmail: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `department` field."""
  department: String
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `projects` field."""
  projects: String
  """Checks for equality with the objects `ticketType` field."""
  ticketType: String
  """Checks for equality with the objects `comment` field."""
  comment: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `priority` field."""
  priority: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `resolution` field."""
  resolution: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `dateModified` field."""
  dateModified: Datetime
  """Checks for equality with the objects `accountName` field."""
  accountName: String
  """Checks for equality with the objects `level` field."""
  level: String
}

"""A connection to a list of `Customer` values, with data from `Message`."""
type UserCustomersByMessageStaffIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Message`, and the cursor to aid in pagination."""
  edges: [UserCustomersByMessageStaffIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Message`."""
type UserCustomersByMessageStaffIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Message`."""
  messagesByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): MessagesConnection!
  """Reads and enables pagination through a set of `Message`."""
  messagesByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): [Message!]!
}

"""A connection to a list of `Brand` values, with data from `Mediamanager`."""
type UserBrandsByMediamanagerMembersAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [UserBrandsByMediamanagerMembersAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Mediamanager`."""
type UserBrandsByMediamanagerMembersAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Customer` values, with data from `Mediamanager`."""
type UserCustomersByMediamanagerMembersAndAuthorManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [UserCustomersByMediamanagerMembersAndAuthorManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Mediamanager`."""
type UserCustomersByMediamanagerMembersAndAuthorManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Agreement` values, with data from `Mediamanager`."""
type UserAgreementsByMediamanagerMembersAndAgreementsManyToManyConnection {
  """A list of `Agreement` objects."""
  nodes: [Agreement]!
  """A list of edges which contains the `Agreement`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [UserAgreementsByMediamanagerMembersAndAgreementsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Agreement` you could get from the connection."""
  totalCount: Int!
}

"""A `Agreement` edge in the connection, with data from `Mediamanager`."""
type UserAgreementsByMediamanagerMembersAndAgreementsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Agreement` at the end of the edge."""
  node: Agreement
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Comment` values, with data from `Mediamanager`."""
type UserCommentsByMediamanagerMembersAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [UserCommentsByMediamanagerMembersAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Mediamanager`."""
type UserCommentsByMediamanagerMembersAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `TodoList` values, with data from `Mediamanager`."""
type UserTodoListsByMediamanagerMembersAndTaskNameManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [UserTodoListsByMediamanagerMembersAndTaskNameManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Mediamanager`."""
type UserTodoListsByMediamanagerMembersAndTaskNameManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Product` values, with data from `Mediamanager`."""
type UserProductsByMediamanagerMembersAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [UserProductsByMediamanagerMembersAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Mediamanager`."""
type UserProductsByMediamanagerMembersAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Customer` values, with data from `Workspace`."""
type UserCustomersByWorkspaceUsersAndCustomersManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [UserCustomersByWorkspaceUsersAndCustomersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Workspace`."""
type UserCustomersByWorkspaceUsersAndCustomersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Product` values, with data from `Workspace`."""
type UserProductsByWorkspaceUsersAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [UserProductsByWorkspaceUsersAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Workspace`."""
type UserProductsByWorkspaceUsersAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `TodoList` values, with data from `Workspace`."""
type UserTodoListsByWorkspaceUsersAndTasksManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [UserTodoListsByWorkspaceUsersAndTasksManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Workspace`."""
type UserTodoListsByWorkspaceUsersAndTasksManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Brand` values, with data from `Workspace`."""
type UserBrandsByWorkspaceUsersAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [UserBrandsByWorkspaceUsersAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Workspace`."""
type UserBrandsByWorkspaceUsersAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Shop` values, with data from `Workspace`."""
type UserShopsByWorkspaceUsersAndShopsManyToManyConnection {
  """A list of `Shop` objects."""
  nodes: [Shop]!
  """A list of edges which contains the `Shop`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [UserShopsByWorkspaceUsersAndShopsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Shop` you could get from the connection."""
  totalCount: Int!
}

"""A `Shop` edge in the connection, with data from `Workspace`."""
type UserShopsByWorkspaceUsersAndShopsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Shop` at the end of the edge."""
  node: Shop
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Category` values, with data from `Workspace`."""
type UserCategoriesByWorkspaceUsersAndCategoryManyToManyConnection {
  """A list of `Category` objects."""
  nodes: [Category]!
  """A list of edges which contains the `Category`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [UserCategoriesByWorkspaceUsersAndCategoryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection, with data from `Workspace`."""
type UserCategoriesByWorkspaceUsersAndCategoryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Category` at the end of the edge."""
  node: Category
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Project` values, with data from `Workspace`."""
type UserProjectsByWorkspaceUsersAndProjectsManyToManyConnection {
  """A list of `Project` objects."""
  nodes: [Project]!
  """A list of edges which contains the `Project`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [UserProjectsByWorkspaceUsersAndProjectsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

"""A `Project` edge in the connection, with data from `Workspace`."""
type UserProjectsByWorkspaceUsersAndProjectsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Project` at the end of the edge."""
  node: Project
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Customer` values, with data from `Workspace`."""
type ProjectCustomersByWorkspaceProjectsAndCustomersManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProjectCustomersByWorkspaceProjectsAndCustomersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Workspace`."""
type ProjectCustomersByWorkspaceProjectsAndCustomersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `User` values, with data from `Workspace`."""
type ProjectUsersByWorkspaceProjectsAndUsersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProjectUsersByWorkspaceProjectsAndUsersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Workspace`."""
type ProjectUsersByWorkspaceProjectsAndUsersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Product` values, with data from `Workspace`."""
type ProjectProductsByWorkspaceProjectsAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProjectProductsByWorkspaceProjectsAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Workspace`."""
type ProjectProductsByWorkspaceProjectsAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `TodoList` values, with data from `Workspace`."""
type ProjectTodoListsByWorkspaceProjectsAndTasksManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProjectTodoListsByWorkspaceProjectsAndTasksManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Workspace`."""
type ProjectTodoListsByWorkspaceProjectsAndTasksManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Brand` values, with data from `Workspace`."""
type ProjectBrandsByWorkspaceProjectsAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProjectBrandsByWorkspaceProjectsAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Workspace`."""
type ProjectBrandsByWorkspaceProjectsAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Shop` values, with data from `Workspace`."""
type ProjectShopsByWorkspaceProjectsAndShopsManyToManyConnection {
  """A list of `Shop` objects."""
  nodes: [Shop]!
  """A list of edges which contains the `Shop`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProjectShopsByWorkspaceProjectsAndShopsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Shop` you could get from the connection."""
  totalCount: Int!
}

"""A `Shop` edge in the connection, with data from `Workspace`."""
type ProjectShopsByWorkspaceProjectsAndShopsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Shop` at the end of the edge."""
  node: Shop
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Category` values, with data from `Workspace`."""
type ProjectCategoriesByWorkspaceProjectsAndCategoryManyToManyConnection {
  """A list of `Category` objects."""
  nodes: [Category]!
  """A list of edges which contains the `Category`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProjectCategoriesByWorkspaceProjectsAndCategoryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection, with data from `Workspace`."""
type ProjectCategoriesByWorkspaceProjectsAndCategoryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Category` at the end of the edge."""
  node: Category
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A `Project` edge in the connection."""
type ProjectsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Project` at the end of the edge."""
  node: Project
}

"""A connection to a list of `Customer` values, with data from `Project`."""
type TodoListCustomersByProjectTaskIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [TodoListCustomersByProjectTaskIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Project`."""
type TodoListCustomersByProjectTaskIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Project`."""
  projectsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `User` values, with data from `Project`."""
type TodoListUsersByProjectTaskIdAndStaffIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [TodoListUsersByProjectTaskIdAndStaffIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Project`."""
type TodoListUsersByProjectTaskIdAndStaffIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Project`."""
  projectsByStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `Ticketing` values, with data from `Project`."""
type TodoListTicketingsByProjectTaskIdAndTicketIdManyToManyConnection {
  """A list of `Ticketing` objects."""
  nodes: [Ticketing]!
  """A list of edges which contains the `Ticketing`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [TodoListTicketingsByProjectTaskIdAndTicketIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Ticketing` you could get from the connection."""
  totalCount: Int!
}

"""A `Ticketing` edge in the connection, with data from `Project`."""
type TodoListTicketingsByProjectTaskIdAndTicketIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Ticketing` at the end of the edge."""
  node: Ticketing
  """Reads and enables pagination through a set of `Project`."""
  projectsByTicketId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByTicketIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `Brand` values, with data from `Mediamanager`."""
type TodoListBrandsByMediamanagerTaskNameAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [TodoListBrandsByMediamanagerTaskNameAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Mediamanager`."""
type TodoListBrandsByMediamanagerTaskNameAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Customer` values, with data from `Mediamanager`."""
type TodoListCustomersByMediamanagerTaskNameAndAuthorManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [TodoListCustomersByMediamanagerTaskNameAndAuthorManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Mediamanager`."""
type TodoListCustomersByMediamanagerTaskNameAndAuthorManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Agreement` values, with data from `Mediamanager`."""
type TodoListAgreementsByMediamanagerTaskNameAndAgreementsManyToManyConnection {
  """A list of `Agreement` objects."""
  nodes: [Agreement]!
  """A list of edges which contains the `Agreement`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [TodoListAgreementsByMediamanagerTaskNameAndAgreementsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Agreement` you could get from the connection."""
  totalCount: Int!
}

"""A `Agreement` edge in the connection, with data from `Mediamanager`."""
type TodoListAgreementsByMediamanagerTaskNameAndAgreementsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Agreement` at the end of the edge."""
  node: Agreement
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Comment` values, with data from `Mediamanager`."""
type TodoListCommentsByMediamanagerTaskNameAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [TodoListCommentsByMediamanagerTaskNameAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Mediamanager`."""
type TodoListCommentsByMediamanagerTaskNameAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `User` values, with data from `Mediamanager`."""
type TodoListUsersByMediamanagerTaskNameAndMembersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [TodoListUsersByMediamanagerTaskNameAndMembersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Mediamanager`."""
type TodoListUsersByMediamanagerTaskNameAndMembersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Product` values, with data from `Mediamanager`."""
type TodoListProductsByMediamanagerTaskNameAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [TodoListProductsByMediamanagerTaskNameAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Mediamanager`."""
type TodoListProductsByMediamanagerTaskNameAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Customer` values, with data from `Workspace`."""
type TodoListCustomersByWorkspaceTasksAndCustomersManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [TodoListCustomersByWorkspaceTasksAndCustomersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Workspace`."""
type TodoListCustomersByWorkspaceTasksAndCustomersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `User` values, with data from `Workspace`."""
type TodoListUsersByWorkspaceTasksAndUsersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [TodoListUsersByWorkspaceTasksAndUsersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Workspace`."""
type TodoListUsersByWorkspaceTasksAndUsersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Product` values, with data from `Workspace`."""
type TodoListProductsByWorkspaceTasksAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [TodoListProductsByWorkspaceTasksAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Workspace`."""
type TodoListProductsByWorkspaceTasksAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Brand` values, with data from `Workspace`."""
type TodoListBrandsByWorkspaceTasksAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [TodoListBrandsByWorkspaceTasksAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Workspace`."""
type TodoListBrandsByWorkspaceTasksAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Shop` values, with data from `Workspace`."""
type TodoListShopsByWorkspaceTasksAndShopsManyToManyConnection {
  """A list of `Shop` objects."""
  nodes: [Shop]!
  """A list of edges which contains the `Shop`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [TodoListShopsByWorkspaceTasksAndShopsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Shop` you could get from the connection."""
  totalCount: Int!
}

"""A `Shop` edge in the connection, with data from `Workspace`."""
type TodoListShopsByWorkspaceTasksAndShopsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Shop` at the end of the edge."""
  node: Shop
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Category` values, with data from `Workspace`."""
type TodoListCategoriesByWorkspaceTasksAndCategoryManyToManyConnection {
  """A list of `Category` objects."""
  nodes: [Category]!
  """A list of edges which contains the `Category`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [TodoListCategoriesByWorkspaceTasksAndCategoryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection, with data from `Workspace`."""
type TodoListCategoriesByWorkspaceTasksAndCategoryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Category` at the end of the edge."""
  node: Category
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Project` values, with data from `Workspace`."""
type TodoListProjectsByWorkspaceTasksAndProjectsManyToManyConnection {
  """A list of `Project` objects."""
  nodes: [Project]!
  """A list of edges which contains the `Project`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [TodoListProjectsByWorkspaceTasksAndProjectsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

"""A `Project` edge in the connection, with data from `Workspace`."""
type TodoListProjectsByWorkspaceTasksAndProjectsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Project` at the end of the edge."""
  node: Project
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A `TodoList` edge in the connection, with data from `Mediamanager`."""
type CommentTodoListsByMediamanagerCommentAndTaskNameManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `User` values, with data from `Mediamanager`."""
type CommentUsersByMediamanagerCommentAndMembersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CommentUsersByMediamanagerCommentAndMembersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Mediamanager`."""
type CommentUsersByMediamanagerCommentAndMembersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Product` values, with data from `Mediamanager`."""
type CommentProductsByMediamanagerCommentAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CommentProductsByMediamanagerCommentAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Mediamanager`."""
type CommentProductsByMediamanagerCommentAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Country` values, with data from `Training`."""
type CommentCountriesByTrainingCommentAndCountryManyToManyConnection {
  """A list of `Country` objects."""
  nodes: [Country]!
  """A list of edges which contains the `Country`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [CommentCountriesByTrainingCommentAndCountryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Country` you could get from the connection."""
  totalCount: Int!
}

"""A `Country` edge in the connection, with data from `Training`."""
type CommentCountriesByTrainingCommentAndCountryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Country` at the end of the edge."""
  node: Country
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountry(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `State` values, with data from `Training`."""
type CommentStatesByTrainingCommentAndStateManyToManyConnection {
  """A list of `State` objects."""
  nodes: [State]!
  """A list of edges which contains the `State`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [CommentStatesByTrainingCommentAndStateManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `State` you could get from the connection."""
  totalCount: Int!
}

"""A `State` edge in the connection, with data from `Training`."""
type CommentStatesByTrainingCommentAndStateManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `State` at the end of the edge."""
  node: State
  """Reads and enables pagination through a set of `Training`."""
  trainingsByState(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByStateList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `Product` values, with data from `Training`."""
type CommentProductsByTrainingCommentAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [CommentProductsByTrainingCommentAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Training`."""
type CommentProductsByTrainingCommentAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `Checklist` values, with data from `Training`."""
type CommentChecklistsByTrainingCommentAndChecklistsManyToManyConnection {
  """A list of `Checklist` objects."""
  nodes: [Checklist]!
  """A list of edges which contains the `Checklist`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [CommentChecklistsByTrainingCommentAndChecklistsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Checklist` you could get from the connection."""
  totalCount: Int!
}

"""A `Checklist` edge in the connection, with data from `Training`."""
type CommentChecklistsByTrainingCommentAndChecklistsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Checklist` at the end of the edge."""
  node: Checklist
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A `Comment` edge in the connection."""
type CommentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
}

"""Methods to use when ordering `CreditMemo`."""
enum CreditMemosOrderBy {
  NATURAL
  CREDIT_MEMO_ASC
  CREDIT_MEMO_DESC
  ORDER_NUMBER_ASC
  ORDER_NUMBER_DESC
  CREATED_ASC
  CREATED_DESC
  BILL_TO_NAME_ASC
  BILL_TO_NAME_DESC
  STATUS_ASC
  STATUS_DESC
  REFUNDED_ASC
  REFUNDED_DESC
  ACTION_ASC
  ACTION_DESC
  ID_ASC
  ID_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CreditMemo` object types. All fields are tested
for equality and combined with a logical and.
"""
input CreditMemoCondition {
  """Checks for equality with the objects `creditMemo` field."""
  creditMemo: String
  """Checks for equality with the objects `orderNumber` field."""
  orderNumber: Int
  """Checks for equality with the objects `created` field."""
  created: Datetime
  """Checks for equality with the objects `billToName` field."""
  billToName: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `refunded` field."""
  refunded: String
  """Checks for equality with the objects `action` field."""
  action: String
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `custId` field."""
  custId: Int
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
}

"""A connection to a list of `NewsletterSubscriber` values."""
type NewsletterSubscribersConnection {
  """A list of `NewsletterSubscriber` objects."""
  nodes: [NewsletterSubscriber]!
  """A list of edges which contains the `NewsletterSubscriber` and cursor to aid in pagination."""
  edges: [NewsletterSubscribersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `NewsletterSubscriber` you could get from the connection."""
  totalCount: Int!
}

type NewsletterSubscriber implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  email: String!
  customerFirstName: String
  customerLastName: String
  store: String
  status: String
  websites: String
  createdAt: Datetime
  custId: Int!
  """Reads a single `Customer` that is related to this `NewsletterSubscriber`."""
  customerByCustId: Customer
}

"""A `NewsletterSubscriber` edge in the connection."""
type NewsletterSubscribersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `NewsletterSubscriber` at the end of the edge."""
  node: NewsletterSubscriber
}

"""Methods to use when ordering `NewsletterSubscriber`."""
enum NewsletterSubscribersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  CUSTOMER_FIRST_NAME_ASC
  CUSTOMER_FIRST_NAME_DESC
  CUSTOMER_LAST_NAME_ASC
  CUSTOMER_LAST_NAME_DESC
  STORE_ASC
  STORE_DESC
  STATUS_ASC
  STATUS_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `NewsletterSubscriber` object types. All fields
are tested for equality and combined with a logical and.
"""
input NewsletterSubscriberCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `customerFirstName` field."""
  customerFirstName: String
  """Checks for equality with the objects `customerLastName` field."""
  customerLastName: String
  """Checks for equality with the objects `store` field."""
  store: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `websites` field."""
  websites: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `custId` field."""
  custId: Int
}

"""A connection to a list of `Order` values."""
type OrdersConnection {
  """A list of `Order` objects."""
  nodes: [Order]!
  """A list of edges which contains the `Order` and cursor to aid in pagination."""
  edges: [OrdersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Order` you could get from the connection."""
  totalCount: Int!
}

type Order implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  purchasePoint: Int
  purchaseDate: Datetime
  billToName: String!
  shipToName: String
  grandTotalBase: Int
  grandTotalPurchased: Int
  status: Boolean
  action: Boolean
  allocatedSources: String
  braintreeTransactionSource: String
  custId: Int!
  prodId: BigInt!
  """Reads a single `Customer` that is related to this `Order`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `Order`."""
  productByProdId: Product
  """Reads and enables pagination through a set of `Quote`."""
  quotesByOrderId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByOrderIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]!
  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByOrderId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): TransactionsConnection!
  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByOrderIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): [Transaction!]!
  """Reads and enables pagination through a set of `Customer`."""
  customersByQuoteOrderIdAndCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): OrderCustomersByQuoteOrderIdAndCustIdManyToManyConnection!
  """Reads and enables pagination through a set of `Customer`."""
  customersByQuoteOrderIdAndCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByQuoteOrderIdAndProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): OrderProductsByQuoteOrderIdAndProdIdManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByQuoteOrderIdAndProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
  """Reads and enables pagination through a set of `CustomerPayment`."""
  customerPaymentsByTransactionOrderIdAndPaymentMethod(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerPaymentCondition
  ): OrderCustomerPaymentsByTransactionOrderIdAndPaymentMethodManyToManyConnection!
  """Reads and enables pagination through a set of `CustomerPayment`."""
  customerPaymentsByTransactionOrderIdAndPaymentMethodList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerPaymentCondition
  ): [CustomerPayment!]!
}

"""A connection to a list of `Quote` values."""
type QuotesConnection {
  """A list of `Quote` objects."""
  nodes: [Quote]!
  """A list of edges which contains the `Quote` and cursor to aid in pagination."""
  edges: [QuotesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Quote` you could get from the connection."""
  totalCount: Int!
}

type Quote implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  grandTotal: String
  createdAt: Datetime
  categories: String
  validUntil: String
  quoteStage: String
  customers: String
  custId: Int!
  prodId: BigInt!
  orderId: Int!
  account: String
  approvalIssues: String
  approvalStatus: String
  assignedTo: String
  billingCity: String
  billingCountry: String
  billingPostal: String
  billingState: String
  billingStreet: String
  contact: String
  currency: String
  discount: String
  invoiceStatus: String
  lineItemDiscount: String
  lineItemGroupTotal: String
  lineItemName: String
  lineItemSubtotal: String
  lineItemTax: String
  lineItemTotal: String
  paymentTerms: String
  shipping: String
  shippingCity: String
  shippingCountry: String
  shippingPostal: String
  shippingState: String
  shippingStreet: String
  shippingTax: String
  subtotal: String
  tax: String
  total: String
  """Reads a single `Customer` that is related to this `Quote`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `Quote`."""
  productByProdId: Product
  """Reads a single `Order` that is related to this `Quote`."""
  orderByOrderId: Order
}

"""A `Quote` edge in the connection."""
type QuotesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Quote` at the end of the edge."""
  node: Quote
}

"""Methods to use when ordering `Quote`."""
enum QuotesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  GRAND_TOTAL_ASC
  GRAND_TOTAL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  VALID_UNTIL_ASC
  VALID_UNTIL_DESC
  QUOTE_STAGE_ASC
  QUOTE_STAGE_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  ORDER_ID_ASC
  ORDER_ID_DESC
  ACCOUNT_ASC
  ACCOUNT_DESC
  APPROVAL_ISSUES_ASC
  APPROVAL_ISSUES_DESC
  APPROVAL_STATUS_ASC
  APPROVAL_STATUS_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  BILLING_CITY_ASC
  BILLING_CITY_DESC
  BILLING_COUNTRY_ASC
  BILLING_COUNTRY_DESC
  BILLING_POSTAL_ASC
  BILLING_POSTAL_DESC
  BILLING_STATE_ASC
  BILLING_STATE_DESC
  BILLING_STREET_ASC
  BILLING_STREET_DESC
  CONTACT_ASC
  CONTACT_DESC
  CURRENCY_ASC
  CURRENCY_DESC
  DISCOUNT_ASC
  DISCOUNT_DESC
  INVOICE_STATUS_ASC
  INVOICE_STATUS_DESC
  LINE_ITEM_DISCOUNT_ASC
  LINE_ITEM_DISCOUNT_DESC
  LINE_ITEM_GROUP_TOTAL_ASC
  LINE_ITEM_GROUP_TOTAL_DESC
  LINE_ITEM_NAME_ASC
  LINE_ITEM_NAME_DESC
  LINE_ITEM_SUBTOTAL_ASC
  LINE_ITEM_SUBTOTAL_DESC
  LINE_ITEM_TAX_ASC
  LINE_ITEM_TAX_DESC
  LINE_ITEM_TOTAL_ASC
  LINE_ITEM_TOTAL_DESC
  PAYMENT_TERMS_ASC
  PAYMENT_TERMS_DESC
  SHIPPING_ASC
  SHIPPING_DESC
  SHIPPING_CITY_ASC
  SHIPPING_CITY_DESC
  SHIPPING_COUNTRY_ASC
  SHIPPING_COUNTRY_DESC
  SHIPPING_POSTAL_ASC
  SHIPPING_POSTAL_DESC
  SHIPPING_STATE_ASC
  SHIPPING_STATE_DESC
  SHIPPING_STREET_ASC
  SHIPPING_STREET_DESC
  SHIPPING_TAX_ASC
  SHIPPING_TAX_DESC
  SUBTOTAL_ASC
  SUBTOTAL_DESC
  TAX_ASC
  TAX_DESC
  TOTAL_ASC
  TOTAL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Quote` object types. All fields are tested for equality and combined with a logical and."""
input QuoteCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `grandTotal` field."""
  grandTotal: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `validUntil` field."""
  validUntil: String
  """Checks for equality with the objects `quoteStage` field."""
  quoteStage: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `custId` field."""
  custId: Int
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
  """Checks for equality with the objects `orderId` field."""
  orderId: Int
  """Checks for equality with the objects `account` field."""
  account: String
  """Checks for equality with the objects `approvalIssues` field."""
  approvalIssues: String
  """Checks for equality with the objects `approvalStatus` field."""
  approvalStatus: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `billingCity` field."""
  billingCity: String
  """Checks for equality with the objects `billingCountry` field."""
  billingCountry: String
  """Checks for equality with the objects `billingPostal` field."""
  billingPostal: String
  """Checks for equality with the objects `billingState` field."""
  billingState: String
  """Checks for equality with the objects `billingStreet` field."""
  billingStreet: String
  """Checks for equality with the objects `contact` field."""
  contact: String
  """Checks for equality with the objects `currency` field."""
  currency: String
  """Checks for equality with the objects `discount` field."""
  discount: String
  """Checks for equality with the objects `invoiceStatus` field."""
  invoiceStatus: String
  """Checks for equality with the objects `lineItemDiscount` field."""
  lineItemDiscount: String
  """Checks for equality with the objects `lineItemGroupTotal` field."""
  lineItemGroupTotal: String
  """Checks for equality with the objects `lineItemName` field."""
  lineItemName: String
  """Checks for equality with the objects `lineItemSubtotal` field."""
  lineItemSubtotal: String
  """Checks for equality with the objects `lineItemTax` field."""
  lineItemTax: String
  """Checks for equality with the objects `lineItemTotal` field."""
  lineItemTotal: String
  """Checks for equality with the objects `paymentTerms` field."""
  paymentTerms: String
  """Checks for equality with the objects `shipping` field."""
  shipping: String
  """Checks for equality with the objects `shippingCity` field."""
  shippingCity: String
  """Checks for equality with the objects `shippingCountry` field."""
  shippingCountry: String
  """Checks for equality with the objects `shippingPostal` field."""
  shippingPostal: String
  """Checks for equality with the objects `shippingState` field."""
  shippingState: String
  """Checks for equality with the objects `shippingStreet` field."""
  shippingStreet: String
  """Checks for equality with the objects `shippingTax` field."""
  shippingTax: String
  """Checks for equality with the objects `subtotal` field."""
  subtotal: String
  """Checks for equality with the objects `tax` field."""
  tax: String
  """Checks for equality with the objects `total` field."""
  total: String
}

"""A connection to a list of `Transaction` values."""
type TransactionsConnection {
  """A list of `Transaction` objects."""
  nodes: [Transaction]!
  """A list of edges which contains the `Transaction` and cursor to aid in pagination."""
  edges: [TransactionsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Transaction` you could get from the connection."""
  totalCount: Int!
}

type Transaction implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  orderId: Int!
  transactionId: Int!
  parentTransactionId: Int!
  created: Datetime
  paymentMethod: BigInt!
  closed: String
  """Reads a single `Order` that is related to this `Transaction`."""
  orderByOrderId: Order
  """Reads a single `CustomerPayment` that is related to this `Transaction`."""
  customerPaymentByPaymentMethod: CustomerPayment
}

type CustomerPayment implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  custId: Int!
  paymentInfo: String
  provider: String
  accountNo: BigInt!
  expiry: BigInt
  """Reads a single `Customer` that is related to this `CustomerPayment`."""
  customerByCustId: Customer
  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByPaymentMethod(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): TransactionsConnection!
  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByPaymentMethodList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): [Transaction!]!
  """Reads and enables pagination through a set of `Order`."""
  ordersByTransactionPaymentMethodAndOrderId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): CustomerPaymentOrdersByTransactionPaymentMethodAndOrderIdManyToManyConnection!
  """Reads and enables pagination through a set of `Order`."""
  ordersByTransactionPaymentMethodAndOrderIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): [Order!]!
}

"""Methods to use when ordering `Transaction`."""
enum TransactionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ORDER_ID_ASC
  ORDER_ID_DESC
  TRANSACTION_ID_ASC
  TRANSACTION_ID_DESC
  PARENT_TRANSACTION_ID_ASC
  PARENT_TRANSACTION_ID_DESC
  CREATED_ASC
  CREATED_DESC
  PAYMENT_METHOD_ASC
  PAYMENT_METHOD_DESC
  CLOSED_ASC
  CLOSED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Transaction` object types. All fields are tested
for equality and combined with a logical and.
"""
input TransactionCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `orderId` field."""
  orderId: Int
  """Checks for equality with the objects `transactionId` field."""
  transactionId: Int
  """Checks for equality with the objects `parentTransactionId` field."""
  parentTransactionId: Int
  """Checks for equality with the objects `created` field."""
  created: Datetime
  """Checks for equality with the objects `paymentMethod` field."""
  paymentMethod: BigInt
  """Checks for equality with the objects `closed` field."""
  closed: String
}

"""A connection to a list of `Order` values, with data from `Transaction`."""
type CustomerPaymentOrdersByTransactionPaymentMethodAndOrderIdManyToManyConnection {
  """A list of `Order` objects."""
  nodes: [Order]!
  """A list of edges which contains the `Order`, info from the `Transaction`, and the cursor to aid in pagination."""
  edges: [CustomerPaymentOrdersByTransactionPaymentMethodAndOrderIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Order` you could get from the connection."""
  totalCount: Int!
}

"""A `Order` edge in the connection, with data from `Transaction`."""
type CustomerPaymentOrdersByTransactionPaymentMethodAndOrderIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Order` at the end of the edge."""
  node: Order
  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByOrderId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): TransactionsConnection!
  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByOrderIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): [Transaction!]!
}

"""Methods to use when ordering `Order`."""
enum OrdersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PURCHASE_POINT_ASC
  PURCHASE_POINT_DESC
  PURCHASE_DATE_ASC
  PURCHASE_DATE_DESC
  BILL_TO_NAME_ASC
  BILL_TO_NAME_DESC
  SHIP_TO_NAME_ASC
  SHIP_TO_NAME_DESC
  GRAND_TOTAL_BASE_ASC
  GRAND_TOTAL_BASE_DESC
  GRAND_TOTAL_PURCHASED_ASC
  GRAND_TOTAL_PURCHASED_DESC
  STATUS_ASC
  STATUS_DESC
  ACTION_ASC
  ACTION_DESC
  ALLOCATED_SOURCES_ASC
  ALLOCATED_SOURCES_DESC
  BRAINTREE_TRANSACTION_SOURCE_ASC
  BRAINTREE_TRANSACTION_SOURCE_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Order` object types. All fields are tested for equality and combined with a logical and."""
input OrderCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `purchasePoint` field."""
  purchasePoint: Int
  """Checks for equality with the objects `purchaseDate` field."""
  purchaseDate: Datetime
  """Checks for equality with the objects `billToName` field."""
  billToName: String
  """Checks for equality with the objects `shipToName` field."""
  shipToName: String
  """Checks for equality with the objects `grandTotalBase` field."""
  grandTotalBase: Int
  """Checks for equality with the objects `grandTotalPurchased` field."""
  grandTotalPurchased: Int
  """Checks for equality with the objects `status` field."""
  status: Boolean
  """Checks for equality with the objects `action` field."""
  action: Boolean
  """Checks for equality with the objects `allocatedSources` field."""
  allocatedSources: String
  """Checks for equality with the objects `braintreeTransactionSource` field."""
  braintreeTransactionSource: String
  """Checks for equality with the objects `custId` field."""
  custId: Int
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
}

"""A `Transaction` edge in the connection."""
type TransactionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Transaction` at the end of the edge."""
  node: Transaction
}

"""A connection to a list of `Customer` values, with data from `Quote`."""
type OrderCustomersByQuoteOrderIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Quote`, and the cursor to aid in pagination."""
  edges: [OrderCustomersByQuoteOrderIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Quote`."""
type OrderCustomersByQuoteOrderIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Quote`."""
  quotesByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]!
}

"""A connection to a list of `Product` values, with data from `Quote`."""
type OrderProductsByQuoteOrderIdAndProdIdManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Quote`, and the cursor to aid in pagination."""
  edges: [OrderProductsByQuoteOrderIdAndProdIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Quote`."""
type OrderProductsByQuoteOrderIdAndProdIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Quote`."""
  quotesByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]!
}

"""A connection to a list of `CustomerPayment` values, with data from `Transaction`."""
type OrderCustomerPaymentsByTransactionOrderIdAndPaymentMethodManyToManyConnection {
  """A list of `CustomerPayment` objects."""
  nodes: [CustomerPayment]!
  """A list of edges which contains the `CustomerPayment`, info from the `Transaction`, and the cursor to aid in pagination."""
  edges: [OrderCustomerPaymentsByTransactionOrderIdAndPaymentMethodManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `CustomerPayment` you could get from the connection."""
  totalCount: Int!
}

"""A `CustomerPayment` edge in the connection, with data from `Transaction`."""
type OrderCustomerPaymentsByTransactionOrderIdAndPaymentMethodManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `CustomerPayment` at the end of the edge."""
  node: CustomerPayment
  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByPaymentMethod(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): TransactionsConnection!
  """Reads and enables pagination through a set of `Transaction`."""
  transactionsByPaymentMethodList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): [Transaction!]!
}

"""Methods to use when ordering `CustomerPayment`."""
enum CustomerPaymentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PAYMENT_INFO_ASC
  PAYMENT_INFO_DESC
  PROVIDER_ASC
  PROVIDER_DESC
  ACCOUNT_NO_ASC
  ACCOUNT_NO_DESC
  EXPIRY_ASC
  EXPIRY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CustomerPayment` object types. All fields are
tested for equality and combined with a logical and.
"""
input CustomerPaymentCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `custId` field."""
  custId: Int
  """Checks for equality with the objects `paymentInfo` field."""
  paymentInfo: String
  """Checks for equality with the objects `provider` field."""
  provider: String
  """Checks for equality with the objects `accountNo` field."""
  accountNo: BigInt
  """Checks for equality with the objects `expiry` field."""
  expiry: BigInt
}

"""A `Order` edge in the connection."""
type OrdersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Order` at the end of the edge."""
  node: Order
}

"""A connection to a list of `CustomerGroup` values."""
type CustomerGroupsConnection {
  """A list of `CustomerGroup` objects."""
  nodes: [CustomerGroup]!
  """A list of edges which contains the `CustomerGroup` and cursor to aid in pagination."""
  edges: [CustomerGroupsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `CustomerGroup` you could get from the connection."""
  totalCount: Int!
}

type CustomerGroup implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  taxClass: String
  custId: Int!
  """Reads a single `Customer` that is related to this `CustomerGroup`."""
  customerByCustId: Customer
}

"""A `CustomerGroup` edge in the connection."""
type CustomerGroupsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `CustomerGroup` at the end of the edge."""
  node: CustomerGroup
}

"""Methods to use when ordering `CustomerGroup`."""
enum CustomerGroupsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  TAX_CLASS_ASC
  TAX_CLASS_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CustomerGroup` object types. All fields are
tested for equality and combined with a logical and.
"""
input CustomerGroupCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `taxClass` field."""
  taxClass: String
  """Checks for equality with the objects `custId` field."""
  custId: Int
}

"""A connection to a list of `Return` values."""
type ReturnsConnection {
  """A list of `Return` objects."""
  nodes: [Return]!
  """A list of edges which contains the `Return` and cursor to aid in pagination."""
  edges: [ReturnsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Return` you could get from the connection."""
  totalCount: Int!
}

type Return implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  validity: String
  returnPrefix: String
  prodId: BigInt!
  custId: Int!
  """Reads a single `Product` that is related to this `Return`."""
  productByProdId: Product
  """Reads a single `Customer` that is related to this `Return`."""
  customerByCustId: Customer
}

"""A `Return` edge in the connection."""
type ReturnsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Return` at the end of the edge."""
  node: Return
}

"""Methods to use when ordering `Return`."""
enum ReturnsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  VALIDITY_ASC
  VALIDITY_DESC
  RETURN_PREFIX_ASC
  RETURN_PREFIX_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Return` object types. All fields are tested for equality and combined with a logical and."""
input ReturnCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `validity` field."""
  validity: String
  """Checks for equality with the objects `returnPrefix` field."""
  returnPrefix: String
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
  """Checks for equality with the objects `custId` field."""
  custId: Int
}

"""A connection to a list of `CustomerPayment` values."""
type CustomerPaymentsConnection {
  """A list of `CustomerPayment` objects."""
  nodes: [CustomerPayment]!
  """A list of edges which contains the `CustomerPayment` and cursor to aid in pagination."""
  edges: [CustomerPaymentsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `CustomerPayment` you could get from the connection."""
  totalCount: Int!
}

"""A `CustomerPayment` edge in the connection."""
type CustomerPaymentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `CustomerPayment` at the end of the edge."""
  node: CustomerPayment
}

"""A connection to a list of `Product` values, with data from `CreditMemo`."""
type CustomerProductsByCreditMemoCustIdAndProdIdManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `CreditMemo`, and the cursor to aid in pagination."""
  edges: [CustomerProductsByCreditMemoCustIdAndProdIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `CreditMemo`."""
type CustomerProductsByCreditMemoCustIdAndProdIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `CreditMemo`."""
  creditMemosByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): CreditMemosConnection!
  """Reads and enables pagination through a set of `CreditMemo`."""
  creditMemosByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): [CreditMemo!]!
}

"""A connection to a list of `Product` values, with data from `Order`."""
type CustomerProductsByOrderCustIdAndProdIdManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Order`, and the cursor to aid in pagination."""
  edges: [CustomerProductsByOrderCustIdAndProdIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Order`."""
type CustomerProductsByOrderCustIdAndProdIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Order`."""
  ordersByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): OrdersConnection!
  """Reads and enables pagination through a set of `Order`."""
  ordersByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): [Order!]!
}

"""A connection to a list of `Product` values, with data from `Quote`."""
type CustomerProductsByQuoteCustIdAndProdIdManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Quote`, and the cursor to aid in pagination."""
  edges: [CustomerProductsByQuoteCustIdAndProdIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Quote`."""
type CustomerProductsByQuoteCustIdAndProdIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Quote`."""
  quotesByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]!
}

"""A connection to a list of `Order` values, with data from `Quote`."""
type CustomerOrdersByQuoteCustIdAndOrderIdManyToManyConnection {
  """A list of `Order` objects."""
  nodes: [Order]!
  """A list of edges which contains the `Order`, info from the `Quote`, and the cursor to aid in pagination."""
  edges: [CustomerOrdersByQuoteCustIdAndOrderIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Order` you could get from the connection."""
  totalCount: Int!
}

"""A `Order` edge in the connection, with data from `Quote`."""
type CustomerOrdersByQuoteCustIdAndOrderIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Order` at the end of the edge."""
  node: Order
  """Reads and enables pagination through a set of `Quote`."""
  quotesByOrderId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByOrderIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]!
}

"""A connection to a list of `User` values, with data from `Email`."""
type CustomerUsersByEmailCustIdAndStaffIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Email`, and the cursor to aid in pagination."""
  edges: [CustomerUsersByEmailCustIdAndStaffIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Email`."""
type CustomerUsersByEmailCustIdAndStaffIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Email`."""
  emailsByStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): EmailsConnection!
  """Reads and enables pagination through a set of `Email`."""
  emailsByStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): [Email!]!
}

"""A connection to a list of `Product` values, with data from `Return`."""
type CustomerProductsByReturnCustIdAndProdIdManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Return`, and the cursor to aid in pagination."""
  edges: [CustomerProductsByReturnCustIdAndProdIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Return`."""
type CustomerProductsByReturnCustIdAndProdIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Return`."""
  returnsByProdId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): ReturnsConnection!
  """Reads and enables pagination through a set of `Return`."""
  returnsByProdIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): [Return!]!
}

"""A connection to a list of `User` values, with data from `Project`."""
type CustomerUsersByProjectCustIdAndStaffIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [CustomerUsersByProjectCustIdAndStaffIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Project`."""
type CustomerUsersByProjectCustIdAndStaffIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Project`."""
  projectsByStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `TodoList` values, with data from `Project`."""
type CustomerTodoListsByProjectCustIdAndTaskIdManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [CustomerTodoListsByProjectCustIdAndTaskIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Project`."""
type CustomerTodoListsByProjectCustIdAndTaskIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Project`."""
  projectsByTaskId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByTaskIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `Ticketing` values, with data from `Project`."""
type CustomerTicketingsByProjectCustIdAndTicketIdManyToManyConnection {
  """A list of `Ticketing` objects."""
  nodes: [Ticketing]!
  """A list of edges which contains the `Ticketing`, info from the `Project`, and the cursor to aid in pagination."""
  edges: [CustomerTicketingsByProjectCustIdAndTicketIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Ticketing` you could get from the connection."""
  totalCount: Int!
}

"""A `Ticketing` edge in the connection, with data from `Project`."""
type CustomerTicketingsByProjectCustIdAndTicketIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Ticketing` at the end of the edge."""
  node: Ticketing
  """Reads and enables pagination through a set of `Project`."""
  projectsByTicketId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection!
  """Reads and enables pagination through a set of `Project`."""
  projectsByTicketIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]!
}

"""A connection to a list of `User` values, with data from `Message`."""
type CustomerUsersByMessageCustIdAndStaffIdManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Message`, and the cursor to aid in pagination."""
  edges: [CustomerUsersByMessageCustIdAndStaffIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Message`."""
type CustomerUsersByMessageCustIdAndStaffIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Message`."""
  messagesByStaffId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): MessagesConnection!
  """Reads and enables pagination through a set of `Message`."""
  messagesByStaffIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): [Message!]!
}

"""A connection to a list of `Brand` values, with data from `Mediamanager`."""
type CustomerBrandsByMediamanagerAuthorAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CustomerBrandsByMediamanagerAuthorAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Mediamanager`."""
type CustomerBrandsByMediamanagerAuthorAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Agreement` values, with data from `Mediamanager`."""
type CustomerAgreementsByMediamanagerAuthorAndAgreementsManyToManyConnection {
  """A list of `Agreement` objects."""
  nodes: [Agreement]!
  """A list of edges which contains the `Agreement`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CustomerAgreementsByMediamanagerAuthorAndAgreementsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Agreement` you could get from the connection."""
  totalCount: Int!
}

"""A `Agreement` edge in the connection, with data from `Mediamanager`."""
type CustomerAgreementsByMediamanagerAuthorAndAgreementsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Agreement` at the end of the edge."""
  node: Agreement
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Comment` values, with data from `Mediamanager`."""
type CustomerCommentsByMediamanagerAuthorAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CustomerCommentsByMediamanagerAuthorAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Mediamanager`."""
type CustomerCommentsByMediamanagerAuthorAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `TodoList` values, with data from `Mediamanager`."""
type CustomerTodoListsByMediamanagerAuthorAndTaskNameManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CustomerTodoListsByMediamanagerAuthorAndTaskNameManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Mediamanager`."""
type CustomerTodoListsByMediamanagerAuthorAndTaskNameManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `User` values, with data from `Mediamanager`."""
type CustomerUsersByMediamanagerAuthorAndMembersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CustomerUsersByMediamanagerAuthorAndMembersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Mediamanager`."""
type CustomerUsersByMediamanagerAuthorAndMembersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Product` values, with data from `Mediamanager`."""
type CustomerProductsByMediamanagerAuthorAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [CustomerProductsByMediamanagerAuthorAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Mediamanager`."""
type CustomerProductsByMediamanagerAuthorAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `User` values, with data from `Workspace`."""
type CustomerUsersByWorkspaceCustomersAndUsersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CustomerUsersByWorkspaceCustomersAndUsersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Workspace`."""
type CustomerUsersByWorkspaceCustomersAndUsersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Product` values, with data from `Workspace`."""
type CustomerProductsByWorkspaceCustomersAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CustomerProductsByWorkspaceCustomersAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Workspace`."""
type CustomerProductsByWorkspaceCustomersAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `TodoList` values, with data from `Workspace`."""
type CustomerTodoListsByWorkspaceCustomersAndTasksManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CustomerTodoListsByWorkspaceCustomersAndTasksManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Workspace`."""
type CustomerTodoListsByWorkspaceCustomersAndTasksManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Brand` values, with data from `Workspace`."""
type CustomerBrandsByWorkspaceCustomersAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CustomerBrandsByWorkspaceCustomersAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Workspace`."""
type CustomerBrandsByWorkspaceCustomersAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Shop` values, with data from `Workspace`."""
type CustomerShopsByWorkspaceCustomersAndShopsManyToManyConnection {
  """A list of `Shop` objects."""
  nodes: [Shop]!
  """A list of edges which contains the `Shop`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CustomerShopsByWorkspaceCustomersAndShopsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Shop` you could get from the connection."""
  totalCount: Int!
}

"""A `Shop` edge in the connection, with data from `Workspace`."""
type CustomerShopsByWorkspaceCustomersAndShopsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Shop` at the end of the edge."""
  node: Shop
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Category` values, with data from `Workspace`."""
type CustomerCategoriesByWorkspaceCustomersAndCategoryManyToManyConnection {
  """A list of `Category` objects."""
  nodes: [Category]!
  """A list of edges which contains the `Category`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CustomerCategoriesByWorkspaceCustomersAndCategoryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection, with data from `Workspace`."""
type CustomerCategoriesByWorkspaceCustomersAndCategoryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Category` at the end of the edge."""
  node: Category
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Project` values, with data from `Workspace`."""
type CustomerProjectsByWorkspaceCustomersAndProjectsManyToManyConnection {
  """A list of `Project` objects."""
  nodes: [Project]!
  """A list of edges which contains the `Project`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [CustomerProjectsByWorkspaceCustomersAndProjectsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

"""A `Project` edge in the connection, with data from `Workspace`."""
type CustomerProjectsByWorkspaceCustomersAndProjectsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Project` at the end of the edge."""
  node: Project
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A `CreditMemo` edge in the connection."""
type CreditMemosEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `CreditMemo` at the end of the edge."""
  node: CreditMemo
}

"""A connection to a list of `ProductAttribute` values."""
type ProductAttributesConnection {
  """A list of `ProductAttribute` objects."""
  nodes: [ProductAttribute]!
  """A list of edges which contains the `ProductAttribute` and cursor to aid in pagination."""
  edges: [ProductAttributesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `ProductAttribute` you could get from the connection."""
  totalCount: Int!
}

type ProductAttribute implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  defaultLabel: String
  attributeCode: String
  filterOptions: String
  useSearch: String
  layeredNavigation: Boolean
  searchResultsLayeredNavigation: Boolean
  position: String
  promoRuleConditions: Boolean
  allowHtmlTagsStorefront: Boolean
  visibleCatalogPagesStorefront: Boolean
  usedProductListing: Boolean
  usedSortingProductListing: Boolean
  prodId: BigInt!
  attributeClass: String
  attributeValue: String
  columnOptions: String
  facetedNavigation: Boolean
  isPublic: String
  metaDescription: String
  metaName: Boolean
  metaUrl: String
  """Reads a single `Product` that is related to this `ProductAttribute`."""
  productByProdId: Product
}

"""A `ProductAttribute` edge in the connection."""
type ProductAttributesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `ProductAttribute` at the end of the edge."""
  node: ProductAttribute
}

"""Methods to use when ordering `ProductAttribute`."""
enum ProductAttributesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  DEFAULT_LABEL_ASC
  DEFAULT_LABEL_DESC
  ATTRIBUTE_CODE_ASC
  ATTRIBUTE_CODE_DESC
  FILTER_OPTIONS_ASC
  FILTER_OPTIONS_DESC
  USE_SEARCH_ASC
  USE_SEARCH_DESC
  LAYERED_NAVIGATION_ASC
  LAYERED_NAVIGATION_DESC
  SEARCH_RESULTS_LAYERED_NAVIGATION_ASC
  SEARCH_RESULTS_LAYERED_NAVIGATION_DESC
  POSITION_ASC
  POSITION_DESC
  PROMO_RULE_CONDITIONS_ASC
  PROMO_RULE_CONDITIONS_DESC
  ALLOW_HTML_TAGS_STOREFRONT_ASC
  ALLOW_HTML_TAGS_STOREFRONT_DESC
  VISIBLE_CATALOG_PAGES_STOREFRONT_ASC
  VISIBLE_CATALOG_PAGES_STOREFRONT_DESC
  USED_PRODUCT_LISTING_ASC
  USED_PRODUCT_LISTING_DESC
  USED_SORTING_PRODUCT_LISTING_ASC
  USED_SORTING_PRODUCT_LISTING_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  ATTRIBUTE_CLASS_ASC
  ATTRIBUTE_CLASS_DESC
  ATTRIBUTE_VALUE_ASC
  ATTRIBUTE_VALUE_DESC
  COLUMN_OPTIONS_ASC
  COLUMN_OPTIONS_DESC
  FACETED_NAVIGATION_ASC
  FACETED_NAVIGATION_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  META_NAME_ASC
  META_NAME_DESC
  META_URL_ASC
  META_URL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ProductAttribute` object types. All fields are
tested for equality and combined with a logical and.
"""
input ProductAttributeCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `defaultLabel` field."""
  defaultLabel: String
  """Checks for equality with the objects `attributeCode` field."""
  attributeCode: String
  """Checks for equality with the objects `filterOptions` field."""
  filterOptions: String
  """Checks for equality with the objects `useSearch` field."""
  useSearch: String
  """Checks for equality with the objects `layeredNavigation` field."""
  layeredNavigation: Boolean
  """Checks for equality with the objects `searchResultsLayeredNavigation` field."""
  searchResultsLayeredNavigation: Boolean
  """Checks for equality with the objects `position` field."""
  position: String
  """Checks for equality with the objects `promoRuleConditions` field."""
  promoRuleConditions: Boolean
  """Checks for equality with the objects `allowHtmlTagsStorefront` field."""
  allowHtmlTagsStorefront: Boolean
  """Checks for equality with the objects `visibleCatalogPagesStorefront` field."""
  visibleCatalogPagesStorefront: Boolean
  """Checks for equality with the objects `usedProductListing` field."""
  usedProductListing: Boolean
  """Checks for equality with the objects `usedSortingProductListing` field."""
  usedSortingProductListing: Boolean
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
  """Checks for equality with the objects `attributeClass` field."""
  attributeClass: String
  """Checks for equality with the objects `attributeValue` field."""
  attributeValue: String
  """Checks for equality with the objects `columnOptions` field."""
  columnOptions: String
  """Checks for equality with the objects `facetedNavigation` field."""
  facetedNavigation: Boolean
  """Checks for equality with the objects `isPublic` field."""
  isPublic: String
  """Checks for equality with the objects `metaDescription` field."""
  metaDescription: String
  """Checks for equality with the objects `metaName` field."""
  metaName: Boolean
  """Checks for equality with the objects `metaUrl` field."""
  metaUrl: String
}

"""A connection to a list of `Product` values."""
type ProductsConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product` and cursor to aid in pagination."""
  edges: [ProductsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection."""
type ProductsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
}

"""A connection to a list of `Rating` values."""
type RatingsConnection {
  """A list of `Rating` objects."""
  nodes: [Rating]!
  """A list of edges which contains the `Rating` and cursor to aid in pagination."""
  edges: [RatingsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Rating` you could get from the connection."""
  totalCount: Int!
}

type Rating implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  defaultValue: String
  defaultStoreView: String
  ratingVisibility: String
  active: Boolean
  sortOrder: BigFloat
  prodId: BigInt!
  """Reads a single `Product` that is related to this `Rating`."""
  productByProdId: Product
}

"""A floating point number that requires more precision than IEEE 754 binary 64"""
scalar BigFloat

"""A `Rating` edge in the connection."""
type RatingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Rating` at the end of the edge."""
  node: Rating
}

"""Methods to use when ordering `Rating`."""
enum RatingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  DEFAULT_VALUE_ASC
  DEFAULT_VALUE_DESC
  DEFAULT_STORE_VIEW_ASC
  DEFAULT_STORE_VIEW_DESC
  RATING_VISIBILITY_ASC
  RATING_VISIBILITY_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Rating` object types. All fields are tested for equality and combined with a logical and."""
input RatingCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `defaultValue` field."""
  defaultValue: String
  """Checks for equality with the objects `defaultStoreView` field."""
  defaultStoreView: String
  """Checks for equality with the objects `ratingVisibility` field."""
  ratingVisibility: String
  """Checks for equality with the objects `active` field."""
  active: Boolean
  """Checks for equality with the objects `sortOrder` field."""
  sortOrder: BigFloat
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
}

"""A connection to a list of `TaxRate` values."""
type TaxRatesConnection {
  """A list of `TaxRate` objects."""
  nodes: [TaxRate]!
  """A list of edges which contains the `TaxRate` and cursor to aid in pagination."""
  edges: [TaxRatesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TaxRate` you could get from the connection."""
  totalCount: Int!
}

type TaxRate implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  taxIdentifier: String!
  zipPostIsRange: Boolean
  postcode: String
  state: String
  country: String
  ratePercent: String
  defaultStoreView: String
  prodId: BigInt!
  """Reads a single `Product` that is related to this `TaxRate`."""
  productByProdId: Product
}

"""A `TaxRate` edge in the connection."""
type TaxRatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TaxRate` at the end of the edge."""
  node: TaxRate
}

"""Methods to use when ordering `TaxRate`."""
enum TaxRatesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TAX_IDENTIFIER_ASC
  TAX_IDENTIFIER_DESC
  ZIP_POST_IS_RANGE_ASC
  ZIP_POST_IS_RANGE_DESC
  POSTCODE_ASC
  POSTCODE_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  RATE_PERCENT_ASC
  RATE_PERCENT_DESC
  DEFAULT_STORE_VIEW_ASC
  DEFAULT_STORE_VIEW_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `TaxRate` object types. All fields are tested for equality and combined with a logical and."""
input TaxRateCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `taxIdentifier` field."""
  taxIdentifier: String
  """Checks for equality with the objects `zipPostIsRange` field."""
  zipPostIsRange: Boolean
  """Checks for equality with the objects `postcode` field."""
  postcode: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `ratePercent` field."""
  ratePercent: String
  """Checks for equality with the objects `defaultStoreView` field."""
  defaultStoreView: String
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
}

"""A connection to a list of `TaxRule` values."""
type TaxRulesConnection {
  """A list of `TaxRule` objects."""
  nodes: [TaxRule]!
  """A list of edges which contains the `TaxRule` and cursor to aid in pagination."""
  edges: [TaxRulesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TaxRule` you could get from the connection."""
  totalCount: Int!
}

type TaxRule implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  taxRate: String
  prodId: BigInt!
  """Reads a single `Product` that is related to this `TaxRule`."""
  productByProdId: Product
}

"""A `TaxRule` edge in the connection."""
type TaxRulesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TaxRule` at the end of the edge."""
  node: TaxRule
}

"""Methods to use when ordering `TaxRule`."""
enum TaxRulesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  TAX_RATE_ASC
  TAX_RATE_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `TaxRule` object types. All fields are tested for equality and combined with a logical and."""
input TaxRuleCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `taxRate` field."""
  taxRate: String
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
}

"""A connection to a list of `ProductType` values."""
type ProductTypesConnection {
  """A list of `ProductType` objects."""
  nodes: [ProductType]!
  """A list of edges which contains the `ProductType` and cursor to aid in pagination."""
  edges: [ProductTypesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `ProductType` you could get from the connection."""
  totalCount: Int!
}

type ProductType implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  typeName: String
  taxes: String
  isShippable: String
  metaUrl: String
  metaDescription: String
  filterOptions: String
  productType: String
  prodId: BigInt!
  """Reads a single `Product` that is related to this `ProductType`."""
  productByProdId: Product
}

"""A `ProductType` edge in the connection."""
type ProductTypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `ProductType` at the end of the edge."""
  node: ProductType
}

"""Methods to use when ordering `ProductType`."""
enum ProductTypesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TYPE_NAME_ASC
  TYPE_NAME_DESC
  TAXES_ASC
  TAXES_DESC
  IS_SHIPPABLE_ASC
  IS_SHIPPABLE_DESC
  META_URL_ASC
  META_URL_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  FILTER_OPTIONS_ASC
  FILTER_OPTIONS_DESC
  PRODUCT_TYPE_ASC
  PRODUCT_TYPE_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ProductType` object types. All fields are tested
for equality and combined with a logical and.
"""
input ProductTypeCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `typeName` field."""
  typeName: String
  """Checks for equality with the objects `taxes` field."""
  taxes: String
  """Checks for equality with the objects `isShippable` field."""
  isShippable: String
  """Checks for equality with the objects `metaUrl` field."""
  metaUrl: String
  """Checks for equality with the objects `metaDescription` field."""
  metaDescription: String
  """Checks for equality with the objects `filterOptions` field."""
  filterOptions: String
  """Checks for equality with the objects `productType` field."""
  productType: String
  """Checks for equality with the objects `prodId` field."""
  prodId: BigInt
}

"""A connection to a list of `Brand` values."""
type BrandsConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand` and cursor to aid in pagination."""
  edges: [BrandsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection."""
type BrandsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
}

"""A connection to a list of `Occassion` values."""
type OccassionsConnection {
  """A list of `Occassion` objects."""
  nodes: [Occassion]!
  """A list of edges which contains the `Occassion` and cursor to aid in pagination."""
  edges: [OccassionsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Occassion` you could get from the connection."""
  totalCount: Int!
}

type Occassion implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  category: String
  tags: String
  description: String
  products: BigInt
  wishlists: BigInt
  """Reads a single `Product` that is related to this `Occassion`."""
  productByProducts: Product
  """Reads a single `Wishlist` that is related to this `Occassion`."""
  wishlistByWishlists: Wishlist
}

type Wishlist implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  customers: String
  visibility: String
  products: String
  quantity: String
  """Reads and enables pagination through a set of `Occassion`."""
  occassionsByWishlists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): OccassionsConnection!
  """Reads and enables pagination through a set of `Occassion`."""
  occassionsByWishlistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): [Occassion!]!
  """Reads and enables pagination through a set of `Product`."""
  productsByOccassionWishlistsAndProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): WishlistProductsByOccassionWishlistsAndProductsManyToManyConnection!
  """Reads and enables pagination through a set of `Product`."""
  productsByOccassionWishlistsAndProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]!
}

"""Methods to use when ordering `Occassion`."""
enum OccassionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  TAGS_ASC
  TAGS_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  WISHLISTS_ASC
  WISHLISTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Occassion` object types. All fields are tested
for equality and combined with a logical and.
"""
input OccassionCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `code` field."""
  code: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `category` field."""
  category: String
  """Checks for equality with the objects `tags` field."""
  tags: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `products` field."""
  products: BigInt
  """Checks for equality with the objects `wishlists` field."""
  wishlists: BigInt
}

"""A connection to a list of `Product` values, with data from `Occassion`."""
type WishlistProductsByOccassionWishlistsAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Occassion`, and the cursor to aid in pagination."""
  edges: [WishlistProductsByOccassionWishlistsAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Occassion`."""
type WishlistProductsByOccassionWishlistsAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Occassion`."""
  occassionsByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): OccassionsConnection!
  """Reads and enables pagination through a set of `Occassion`."""
  occassionsByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): [Occassion!]!
}

"""A `Occassion` edge in the connection."""
type OccassionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Occassion` at the end of the edge."""
  node: Occassion
}

"""A connection to a list of `Manufacturer` values."""
type ManufacturersConnection {
  """A list of `Manufacturer` objects."""
  nodes: [Manufacturer]!
  """A list of edges which contains the `Manufacturer` and cursor to aid in pagination."""
  edges: [ManufacturersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Manufacturer` you could get from the connection."""
  totalCount: Int!
}

type Manufacturer implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
  """Reads a single `Product` that is related to this `Manufacturer`."""
  productByProduct: Product
}

"""A `Manufacturer` edge in the connection."""
type ManufacturersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Manufacturer` at the end of the edge."""
  node: Manufacturer
}

"""Methods to use when ordering `Manufacturer`."""
enum ManufacturersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  STATE_ASC
  STATE_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  CITY_ASC
  CITY_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  MEDIA_ASC
  MEDIA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Manufacturer` object types. All fields are
tested for equality and combined with a logical and.
"""
input ManufacturerCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `code` field."""
  code: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `isPublic` field."""
  isPublic: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `product` field."""
  product: BigInt
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `media` field."""
  media: String
}

"""A connection to a list of `Customer` values, with data from `CreditMemo`."""
type ProductCustomersByCreditMemoProdIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `CreditMemo`, and the cursor to aid in pagination."""
  edges: [ProductCustomersByCreditMemoProdIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `CreditMemo`."""
type ProductCustomersByCreditMemoProdIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `CreditMemo`."""
  creditMemosByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): CreditMemosConnection!
  """Reads and enables pagination through a set of `CreditMemo`."""
  creditMemosByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): [CreditMemo!]!
}

"""A connection to a list of `Customer` values, with data from `Order`."""
type ProductCustomersByOrderProdIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Order`, and the cursor to aid in pagination."""
  edges: [ProductCustomersByOrderProdIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Order`."""
type ProductCustomersByOrderProdIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Order`."""
  ordersByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): OrdersConnection!
  """Reads and enables pagination through a set of `Order`."""
  ordersByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): [Order!]!
}

"""A connection to a list of `Customer` values, with data from `Quote`."""
type ProductCustomersByQuoteProdIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Quote`, and the cursor to aid in pagination."""
  edges: [ProductCustomersByQuoteProdIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Quote`."""
type ProductCustomersByQuoteProdIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Quote`."""
  quotesByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]!
}

"""A connection to a list of `Order` values, with data from `Quote`."""
type ProductOrdersByQuoteProdIdAndOrderIdManyToManyConnection {
  """A list of `Order` objects."""
  nodes: [Order]!
  """A list of edges which contains the `Order`, info from the `Quote`, and the cursor to aid in pagination."""
  edges: [ProductOrdersByQuoteProdIdAndOrderIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Order` you could get from the connection."""
  totalCount: Int!
}

"""A `Order` edge in the connection, with data from `Quote`."""
type ProductOrdersByQuoteProdIdAndOrderIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Order` at the end of the edge."""
  node: Order
  """Reads and enables pagination through a set of `Quote`."""
  quotesByOrderId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection!
  """Reads and enables pagination through a set of `Quote`."""
  quotesByOrderIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]!
}

"""A connection to a list of `Customer` values, with data from `Return`."""
type ProductCustomersByReturnProdIdAndCustIdManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Return`, and the cursor to aid in pagination."""
  edges: [ProductCustomersByReturnProdIdAndCustIdManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Return`."""
type ProductCustomersByReturnProdIdAndCustIdManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Return`."""
  returnsByCustId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): ReturnsConnection!
  """Reads and enables pagination through a set of `Return`."""
  returnsByCustIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): [Return!]!
}

"""A connection to a list of `Wishlist` values, with data from `Occassion`."""
type ProductWishlistsByOccassionProductsAndWishlistsManyToManyConnection {
  """A list of `Wishlist` objects."""
  nodes: [Wishlist]!
  """A list of edges which contains the `Wishlist`, info from the `Occassion`, and the cursor to aid in pagination."""
  edges: [ProductWishlistsByOccassionProductsAndWishlistsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Wishlist` you could get from the connection."""
  totalCount: Int!
}

"""A `Wishlist` edge in the connection, with data from `Occassion`."""
type ProductWishlistsByOccassionProductsAndWishlistsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Wishlist` at the end of the edge."""
  node: Wishlist
  """Reads and enables pagination through a set of `Occassion`."""
  occassionsByWishlists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): OccassionsConnection!
  """Reads and enables pagination through a set of `Occassion`."""
  occassionsByWishlistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): [Occassion!]!
}

"""Methods to use when ordering `Wishlist`."""
enum WishlistsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  VISIBILITY_ASC
  VISIBILITY_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  QUANTITY_ASC
  QUANTITY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Wishlist` object types. All fields are tested
for equality and combined with a logical and.
"""
input WishlistCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `visibility` field."""
  visibility: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `quantity` field."""
  quantity: String
}

"""A connection to a list of `Brand` values, with data from `Mediamanager`."""
type ProductBrandsByMediamanagerProductsAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [ProductBrandsByMediamanagerProductsAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Mediamanager`."""
type ProductBrandsByMediamanagerProductsAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Customer` values, with data from `Mediamanager`."""
type ProductCustomersByMediamanagerProductsAndAuthorManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [ProductCustomersByMediamanagerProductsAndAuthorManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Mediamanager`."""
type ProductCustomersByMediamanagerProductsAndAuthorManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Agreement` values, with data from `Mediamanager`."""
type ProductAgreementsByMediamanagerProductsAndAgreementsManyToManyConnection {
  """A list of `Agreement` objects."""
  nodes: [Agreement]!
  """A list of edges which contains the `Agreement`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [ProductAgreementsByMediamanagerProductsAndAgreementsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Agreement` you could get from the connection."""
  totalCount: Int!
}

"""A `Agreement` edge in the connection, with data from `Mediamanager`."""
type ProductAgreementsByMediamanagerProductsAndAgreementsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Agreement` at the end of the edge."""
  node: Agreement
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Comment` values, with data from `Mediamanager`."""
type ProductCommentsByMediamanagerProductsAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [ProductCommentsByMediamanagerProductsAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Mediamanager`."""
type ProductCommentsByMediamanagerProductsAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `TodoList` values, with data from `Mediamanager`."""
type ProductTodoListsByMediamanagerProductsAndTaskNameManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [ProductTodoListsByMediamanagerProductsAndTaskNameManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Mediamanager`."""
type ProductTodoListsByMediamanagerProductsAndTaskNameManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `User` values, with data from `Mediamanager`."""
type ProductUsersByMediamanagerProductsAndMembersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [ProductUsersByMediamanagerProductsAndMembersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Mediamanager`."""
type ProductUsersByMediamanagerProductsAndMembersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Customer` values, with data from `Workspace`."""
type ProductCustomersByWorkspaceProductsAndCustomersManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProductCustomersByWorkspaceProductsAndCustomersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Workspace`."""
type ProductCustomersByWorkspaceProductsAndCustomersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `User` values, with data from `Workspace`."""
type ProductUsersByWorkspaceProductsAndUsersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProductUsersByWorkspaceProductsAndUsersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Workspace`."""
type ProductUsersByWorkspaceProductsAndUsersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `TodoList` values, with data from `Workspace`."""
type ProductTodoListsByWorkspaceProductsAndTasksManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProductTodoListsByWorkspaceProductsAndTasksManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Workspace`."""
type ProductTodoListsByWorkspaceProductsAndTasksManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Brand` values, with data from `Workspace`."""
type ProductBrandsByWorkspaceProductsAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProductBrandsByWorkspaceProductsAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Workspace`."""
type ProductBrandsByWorkspaceProductsAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Shop` values, with data from `Workspace`."""
type ProductShopsByWorkspaceProductsAndShopsManyToManyConnection {
  """A list of `Shop` objects."""
  nodes: [Shop]!
  """A list of edges which contains the `Shop`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProductShopsByWorkspaceProductsAndShopsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Shop` you could get from the connection."""
  totalCount: Int!
}

"""A `Shop` edge in the connection, with data from `Workspace`."""
type ProductShopsByWorkspaceProductsAndShopsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Shop` at the end of the edge."""
  node: Shop
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Category` values, with data from `Workspace`."""
type ProductCategoriesByWorkspaceProductsAndCategoryManyToManyConnection {
  """A list of `Category` objects."""
  nodes: [Category]!
  """A list of edges which contains the `Category`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProductCategoriesByWorkspaceProductsAndCategoryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection, with data from `Workspace`."""
type ProductCategoriesByWorkspaceProductsAndCategoryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Category` at the end of the edge."""
  node: Category
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Project` values, with data from `Workspace`."""
type ProductProjectsByWorkspaceProductsAndProjectsManyToManyConnection {
  """A list of `Project` objects."""
  nodes: [Project]!
  """A list of edges which contains the `Project`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [ProductProjectsByWorkspaceProductsAndProjectsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

"""A `Project` edge in the connection, with data from `Workspace`."""
type ProductProjectsByWorkspaceProductsAndProjectsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Project` at the end of the edge."""
  node: Project
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Comment` values, with data from `Training`."""
type ProductCommentsByTrainingProductsAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [ProductCommentsByTrainingProductsAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Training`."""
type ProductCommentsByTrainingProductsAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Training`."""
  trainingsByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `Country` values, with data from `Training`."""
type ProductCountriesByTrainingProductsAndCountryManyToManyConnection {
  """A list of `Country` objects."""
  nodes: [Country]!
  """A list of edges which contains the `Country`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [ProductCountriesByTrainingProductsAndCountryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Country` you could get from the connection."""
  totalCount: Int!
}

"""A `Country` edge in the connection, with data from `Training`."""
type ProductCountriesByTrainingProductsAndCountryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Country` at the end of the edge."""
  node: Country
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountry(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByCountryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `State` values, with data from `Training`."""
type ProductStatesByTrainingProductsAndStateManyToManyConnection {
  """A list of `State` objects."""
  nodes: [State]!
  """A list of edges which contains the `State`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [ProductStatesByTrainingProductsAndStateManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `State` you could get from the connection."""
  totalCount: Int!
}

"""A `State` edge in the connection, with data from `Training`."""
type ProductStatesByTrainingProductsAndStateManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `State` at the end of the edge."""
  node: State
  """Reads and enables pagination through a set of `Training`."""
  trainingsByState(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByStateList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `Checklist` values, with data from `Training`."""
type ProductChecklistsByTrainingProductsAndChecklistsManyToManyConnection {
  """A list of `Checklist` objects."""
  nodes: [Checklist]!
  """A list of edges which contains the `Checklist`, info from the `Training`, and the cursor to aid in pagination."""
  edges: [ProductChecklistsByTrainingProductsAndChecklistsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Checklist` you could get from the connection."""
  totalCount: Int!
}

"""A `Checklist` edge in the connection, with data from `Training`."""
type ProductChecklistsByTrainingProductsAndChecklistsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Checklist` at the end of the edge."""
  node: Checklist
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection!
  """Reads and enables pagination through a set of `Training`."""
  trainingsByChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]!
}

"""A connection to a list of `Customer` values, with data from `Mediamanager`."""
type BrandCustomersByMediamanagerBrandsAndAuthorManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [BrandCustomersByMediamanagerBrandsAndAuthorManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Mediamanager`."""
type BrandCustomersByMediamanagerBrandsAndAuthorManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Agreement` values, with data from `Mediamanager`."""
type BrandAgreementsByMediamanagerBrandsAndAgreementsManyToManyConnection {
  """A list of `Agreement` objects."""
  nodes: [Agreement]!
  """A list of edges which contains the `Agreement`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [BrandAgreementsByMediamanagerBrandsAndAgreementsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Agreement` you could get from the connection."""
  totalCount: Int!
}

"""A `Agreement` edge in the connection, with data from `Mediamanager`."""
type BrandAgreementsByMediamanagerBrandsAndAgreementsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Agreement` at the end of the edge."""
  node: Agreement
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Comment` values, with data from `Mediamanager`."""
type BrandCommentsByMediamanagerBrandsAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [BrandCommentsByMediamanagerBrandsAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Mediamanager`."""
type BrandCommentsByMediamanagerBrandsAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `TodoList` values, with data from `Mediamanager`."""
type BrandTodoListsByMediamanagerBrandsAndTaskNameManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [BrandTodoListsByMediamanagerBrandsAndTaskNameManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Mediamanager`."""
type BrandTodoListsByMediamanagerBrandsAndTaskNameManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `User` values, with data from `Mediamanager`."""
type BrandUsersByMediamanagerBrandsAndMembersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [BrandUsersByMediamanagerBrandsAndMembersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Mediamanager`."""
type BrandUsersByMediamanagerBrandsAndMembersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Product` values, with data from `Mediamanager`."""
type BrandProductsByMediamanagerBrandsAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [BrandProductsByMediamanagerBrandsAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Mediamanager`."""
type BrandProductsByMediamanagerBrandsAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Customer` values, with data from `Workspace`."""
type BrandCustomersByWorkspaceBrandsAndCustomersManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [BrandCustomersByWorkspaceBrandsAndCustomersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Workspace`."""
type BrandCustomersByWorkspaceBrandsAndCustomersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `User` values, with data from `Workspace`."""
type BrandUsersByWorkspaceBrandsAndUsersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [BrandUsersByWorkspaceBrandsAndUsersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Workspace`."""
type BrandUsersByWorkspaceBrandsAndUsersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Product` values, with data from `Workspace`."""
type BrandProductsByWorkspaceBrandsAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [BrandProductsByWorkspaceBrandsAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Workspace`."""
type BrandProductsByWorkspaceBrandsAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `TodoList` values, with data from `Workspace`."""
type BrandTodoListsByWorkspaceBrandsAndTasksManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [BrandTodoListsByWorkspaceBrandsAndTasksManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Workspace`."""
type BrandTodoListsByWorkspaceBrandsAndTasksManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByTasksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Shop` values, with data from `Workspace`."""
type BrandShopsByWorkspaceBrandsAndShopsManyToManyConnection {
  """A list of `Shop` objects."""
  nodes: [Shop]!
  """A list of edges which contains the `Shop`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [BrandShopsByWorkspaceBrandsAndShopsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Shop` you could get from the connection."""
  totalCount: Int!
}

"""A `Shop` edge in the connection, with data from `Workspace`."""
type BrandShopsByWorkspaceBrandsAndShopsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Shop` at the end of the edge."""
  node: Shop
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Category` values, with data from `Workspace`."""
type BrandCategoriesByWorkspaceBrandsAndCategoryManyToManyConnection {
  """A list of `Category` objects."""
  nodes: [Category]!
  """A list of edges which contains the `Category`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [BrandCategoriesByWorkspaceBrandsAndCategoryManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection, with data from `Workspace`."""
type BrandCategoriesByWorkspaceBrandsAndCategoryManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Category` at the end of the edge."""
  node: Category
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategory(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByCategoryList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A connection to a list of `Project` values, with data from `Workspace`."""
type BrandProjectsByWorkspaceBrandsAndProjectsManyToManyConnection {
  """A list of `Project` objects."""
  nodes: [Project]!
  """A list of edges which contains the `Project`, info from the `Workspace`, and the cursor to aid in pagination."""
  edges: [BrandProjectsByWorkspaceBrandsAndProjectsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

"""A `Project` edge in the connection, with data from `Workspace`."""
type BrandProjectsByWorkspaceBrandsAndProjectsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Project` at the end of the edge."""
  node: Project
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection!
  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]!
}

"""A `Mediamanager` edge in the connection."""
type MediamanagersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Mediamanager` at the end of the edge."""
  node: Mediamanager
}

"""A connection to a list of `Brand` values, with data from `Mediamanager`."""
type AgreementBrandsByMediamanagerAgreementsAndBrandsManyToManyConnection {
  """A list of `Brand` objects."""
  nodes: [Brand]!
  """A list of edges which contains the `Brand`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [AgreementBrandsByMediamanagerAgreementsAndBrandsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

"""A `Brand` edge in the connection, with data from `Mediamanager`."""
type AgreementBrandsByMediamanagerAgreementsAndBrandsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Brand` at the end of the edge."""
  node: Brand
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Customer` values, with data from `Mediamanager`."""
type AgreementCustomersByMediamanagerAgreementsAndAuthorManyToManyConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [AgreementCustomersByMediamanagerAgreementsAndAuthorManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection, with data from `Mediamanager`."""
type AgreementCustomersByMediamanagerAgreementsAndAuthorManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthor(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByAuthorList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Comment` values, with data from `Mediamanager`."""
type AgreementCommentsByMediamanagerAgreementsAndCommentManyToManyConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!
  """A list of edges which contains the `Comment`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [AgreementCommentsByMediamanagerAgreementsAndCommentManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

"""A `Comment` edge in the connection, with data from `Mediamanager`."""
type AgreementCommentsByMediamanagerAgreementsAndCommentManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Comment` at the end of the edge."""
  node: Comment
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByComment(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByCommentList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `TodoList` values, with data from `Mediamanager`."""
type AgreementTodoListsByMediamanagerAgreementsAndTaskNameManyToManyConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [AgreementTodoListsByMediamanagerAgreementsAndTaskNameManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection, with data from `Mediamanager`."""
type AgreementTodoListsByMediamanagerAgreementsAndTaskNameManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskName(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByTaskNameList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `User` values, with data from `Mediamanager`."""
type AgreementUsersByMediamanagerAgreementsAndMembersManyToManyConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [AgreementUsersByMediamanagerAgreementsAndMembersManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection, with data from `Mediamanager`."""
type AgreementUsersByMediamanagerAgreementsAndMembersManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByMembersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A connection to a list of `Product` values, with data from `Mediamanager`."""
type AgreementProductsByMediamanagerAgreementsAndProductsManyToManyConnection {
  """A list of `Product` objects."""
  nodes: [Product]!
  """A list of edges which contains the `Product`, info from the `Mediamanager`, and the cursor to aid in pagination."""
  edges: [AgreementProductsByMediamanagerAgreementsAndProductsManyToManyEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

"""A `Product` edge in the connection, with data from `Mediamanager`."""
type AgreementProductsByMediamanagerAgreementsAndProductsManyToManyEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Product` at the end of the edge."""
  node: Product
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection!
  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagersByProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]!
}

"""A `Agreement` edge in the connection."""
type AgreementsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Agreement` at the end of the edge."""
  node: Agreement
}

"""A connection to a list of `Analytic` values."""
type AnalyticsConnection {
  """A list of `Analytic` objects."""
  nodes: [Analytic]!
  """A list of edges which contains the `Analytic` and cursor to aid in pagination."""
  edges: [AnalyticsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Analytic` you could get from the connection."""
  totalCount: Int!
}

type Analytic implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  country: String
  shareData: String
  websiteName: String
  clientId: String
  clientSecret: String
  trackingId: String
  propertyName: String
  url: String
  defaultView: String
  category: String
  propertyHit: String
  trackingCode: String
  dataCollection: Boolean
  dataRetention: Boolean
  searchAnalytics: String
}

"""A `Analytic` edge in the connection."""
type AnalyticsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Analytic` at the end of the edge."""
  node: Analytic
}

"""Methods to use when ordering `Analytic`."""
enum AnalyticsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  SHARE_DATA_ASC
  SHARE_DATA_DESC
  WEBSITE_NAME_ASC
  WEBSITE_NAME_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  TRACKING_ID_ASC
  TRACKING_ID_DESC
  PROPERTY_NAME_ASC
  PROPERTY_NAME_DESC
  URL_ASC
  URL_DESC
  DEFAULT_VIEW_ASC
  DEFAULT_VIEW_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  PROPERTY_HIT_ASC
  PROPERTY_HIT_DESC
  TRACKING_CODE_ASC
  TRACKING_CODE_DESC
  DATA_COLLECTION_ASC
  DATA_COLLECTION_DESC
  DATA_RETENTION_ASC
  DATA_RETENTION_DESC
  SEARCH_ANALYTICS_ASC
  SEARCH_ANALYTICS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Analytic` object types. All fields are tested
for equality and combined with a logical and.
"""
input AnalyticCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `shareData` field."""
  shareData: String
  """Checks for equality with the objects `websiteName` field."""
  websiteName: String
  """Checks for equality with the objects `clientId` field."""
  clientId: String
  """Checks for equality with the objects `clientSecret` field."""
  clientSecret: String
  """Checks for equality with the objects `trackingId` field."""
  trackingId: String
  """Checks for equality with the objects `propertyName` field."""
  propertyName: String
  """Checks for equality with the objects `url` field."""
  url: String
  """Checks for equality with the objects `defaultView` field."""
  defaultView: String
  """Checks for equality with the objects `category` field."""
  category: String
  """Checks for equality with the objects `propertyHit` field."""
  propertyHit: String
  """Checks for equality with the objects `trackingCode` field."""
  trackingCode: String
  """Checks for equality with the objects `dataCollection` field."""
  dataCollection: Boolean
  """Checks for equality with the objects `dataRetention` field."""
  dataRetention: Boolean
  """Checks for equality with the objects `searchAnalytics` field."""
  searchAnalytics: String
}

"""A connection to a list of `Apitoken` values."""
type ApitokensConnection {
  """A list of `Apitoken` objects."""
  nodes: [Apitoken]!
  """A list of edges which contains the `Apitoken` and cursor to aid in pagination."""
  edges: [ApitokensEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Apitoken` you could get from the connection."""
  totalCount: Int!
}

type Apitoken implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String!
  tokenType: String
  description: String
  token: BigInt!
}

"""A `Apitoken` edge in the connection."""
type ApitokensEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Apitoken` at the end of the edge."""
  node: Apitoken
}

"""Methods to use when ordering `Apitoken`."""
enum ApitokensOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  TOKEN_TYPE_ASC
  TOKEN_TYPE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  TOKEN_ASC
  TOKEN_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Apitoken` object types. All fields are tested
for equality and combined with a logical and.
"""
input ApitokenCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `tokenType` field."""
  tokenType: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `token` field."""
  token: BigInt
}

"""A connection to a list of `Article` values."""
type ArticlesConnection {
  """A list of `Article` objects."""
  nodes: [Article]!
  """A list of edges which contains the `Article` and cursor to aid in pagination."""
  edges: [ArticlesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Article` you could get from the connection."""
  totalCount: Int!
}

type Article implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  name: String!
  excerpt: String!
  content: String
  image: String
  categories: String
  customers: String
  users: String
  published: String
  custId: Int!
  isPublic: String
  metaDescription: String
  metaName: String
  metaUrl: String
  tags: String
}

"""A `Article` edge in the connection."""
type ArticlesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Article` at the end of the edge."""
  node: Article
}

"""Methods to use when ordering `Article`."""
enum ArticlesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  CONTENT_ASC
  CONTENT_DESC
  IMAGE_ASC
  IMAGE_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  META_NAME_ASC
  META_NAME_DESC
  META_URL_ASC
  META_URL_DESC
  TAGS_ASC
  TAGS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Article` object types. All fields are tested for equality and combined with a logical and."""
input ArticleCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `excerpt` field."""
  excerpt: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `users` field."""
  users: String
  """Checks for equality with the objects `published` field."""
  published: String
  """Checks for equality with the objects `custId` field."""
  custId: Int
  """Checks for equality with the objects `isPublic` field."""
  isPublic: String
  """Checks for equality with the objects `metaDescription` field."""
  metaDescription: String
  """Checks for equality with the objects `metaName` field."""
  metaName: String
  """Checks for equality with the objects `metaUrl` field."""
  metaUrl: String
  """Checks for equality with the objects `tags` field."""
  tags: String
}

"""A connection to a list of `CartPriceRule` values."""
type CartPriceRulesConnection {
  """A list of `CartPriceRule` objects."""
  nodes: [CartPriceRule]!
  """A list of edges which contains the `CartPriceRule` and cursor to aid in pagination."""
  edges: [CartPriceRulesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `CartPriceRule` you could get from the connection."""
  totalCount: Int!
}

type CartPriceRule implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  rule: String
  description: String
  active: Boolean
  coupon: String
  usesPerCustomer: String
  priority: String
  startDate: Date
  endDate: Date
  status: String
  website: String
  actionsApply: String
  actionsDiscountAmount: BigFloat
  actionsDiscardSubsequentRules: Boolean
  actionsMaxQtyDiscountIsAppliedTo: BigFloat
  actionsDiscountQtyStep: BigFloat
  actionsApplyShippingAmount: Boolean
}

"""The day, does not include a time."""
scalar Date

"""A `CartPriceRule` edge in the connection."""
type CartPriceRulesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `CartPriceRule` at the end of the edge."""
  node: CartPriceRule
}

"""Methods to use when ordering `CartPriceRule`."""
enum CartPriceRulesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  RULE_ASC
  RULE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  COUPON_ASC
  COUPON_DESC
  USES_PER_CUSTOMER_ASC
  USES_PER_CUSTOMER_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  STATUS_ASC
  STATUS_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  ACTIONS_APPLY_ASC
  ACTIONS_APPLY_DESC
  ACTIONS_DISCOUNT_AMOUNT_ASC
  ACTIONS_DISCOUNT_AMOUNT_DESC
  ACTIONS_DISCARD_SUBSEQUENT_RULES_ASC
  ACTIONS_DISCARD_SUBSEQUENT_RULES_DESC
  ACTIONS_MAX_QTY_DISCOUNT_IS_APPLIED_TO_ASC
  ACTIONS_MAX_QTY_DISCOUNT_IS_APPLIED_TO_DESC
  ACTIONS_DISCOUNT_QTY_STEP_ASC
  ACTIONS_DISCOUNT_QTY_STEP_DESC
  ACTIONS_APPLY_SHIPPING_AMOUNT_ASC
  ACTIONS_APPLY_SHIPPING_AMOUNT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CartPriceRule` object types. All fields are
tested for equality and combined with a logical and.
"""
input CartPriceRuleCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `rule` field."""
  rule: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `active` field."""
  active: Boolean
  """Checks for equality with the objects `coupon` field."""
  coupon: String
  """Checks for equality with the objects `usesPerCustomer` field."""
  usesPerCustomer: String
  """Checks for equality with the objects `priority` field."""
  priority: String
  """Checks for equality with the objects `startDate` field."""
  startDate: Date
  """Checks for equality with the objects `endDate` field."""
  endDate: Date
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `website` field."""
  website: String
  """Checks for equality with the objects `actionsApply` field."""
  actionsApply: String
  """Checks for equality with the objects `actionsDiscountAmount` field."""
  actionsDiscountAmount: BigFloat
  """Checks for equality with the objects `actionsDiscardSubsequentRules` field."""
  actionsDiscardSubsequentRules: Boolean
  """Checks for equality with the objects `actionsMaxQtyDiscountIsAppliedTo` field."""
  actionsMaxQtyDiscountIsAppliedTo: BigFloat
  """Checks for equality with the objects `actionsDiscountQtyStep` field."""
  actionsDiscountQtyStep: BigFloat
  """Checks for equality with the objects `actionsApplyShippingAmount` field."""
  actionsApplyShippingAmount: Boolean
}

"""A connection to a list of `Case` values."""
type CasesConnection {
  """A list of `Case` objects."""
  nodes: [Case]!
  """A list of edges which contains the `Case` and cursor to aid in pagination."""
  edges: [CasesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Case` you could get from the connection."""
  totalCount: Int!
}

type Case implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  caseNumber: Int
  state: String
  type: String
  subject: String
  description: String
  resolution: String
  priority: String
  status: String
  accountName: String
  assignedTo: String
  dateModified: Datetime
}

"""A `Case` edge in the connection."""
type CasesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Case` at the end of the edge."""
  node: Case
}

"""Methods to use when ordering `Case`."""
enum CasesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CASE_NUMBER_ASC
  CASE_NUMBER_DESC
  STATE_ASC
  STATE_DESC
  TYPE_ASC
  TYPE_DESC
  SUBJECT_ASC
  SUBJECT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  RESOLUTION_ASC
  RESOLUTION_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  STATUS_ASC
  STATUS_DESC
  ACCOUNT_NAME_ASC
  ACCOUNT_NAME_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  DATE_MODIFIED_ASC
  DATE_MODIFIED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Case` object types. All fields are tested for equality and combined with a logical and."""
input CaseCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `caseNumber` field."""
  caseNumber: Int
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `type` field."""
  type: String
  """Checks for equality with the objects `subject` field."""
  subject: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `resolution` field."""
  resolution: String
  """Checks for equality with the objects `priority` field."""
  priority: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `accountName` field."""
  accountName: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `dateModified` field."""
  dateModified: Datetime
}

"""A connection to a list of `CatalogPriceRule` values."""
type CatalogPriceRulesConnection {
  """A list of `CatalogPriceRule` objects."""
  nodes: [CatalogPriceRule]!
  """A list of edges which contains the `CatalogPriceRule` and cursor to aid in pagination."""
  edges: [CatalogPriceRulesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `CatalogPriceRule` you could get from the connection."""
  totalCount: Int!
}

type CatalogPriceRule implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  rule: String
  description: String
  active: Boolean
  customerGroups: String
  priority: String
  startDate: Date
  endDate: Date
  status: String
  website: String
  actionsApply: String
  actionsDiscountAmount: BigFloat
  actionsDiscardSubsequentRules: Boolean
}

"""A `CatalogPriceRule` edge in the connection."""
type CatalogPriceRulesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `CatalogPriceRule` at the end of the edge."""
  node: CatalogPriceRule
}

"""Methods to use when ordering `CatalogPriceRule`."""
enum CatalogPriceRulesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  RULE_ASC
  RULE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  CUSTOMER_GROUPS_ASC
  CUSTOMER_GROUPS_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  STATUS_ASC
  STATUS_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  ACTIONS_APPLY_ASC
  ACTIONS_APPLY_DESC
  ACTIONS_DISCOUNT_AMOUNT_ASC
  ACTIONS_DISCOUNT_AMOUNT_DESC
  ACTIONS_DISCARD_SUBSEQUENT_RULES_ASC
  ACTIONS_DISCARD_SUBSEQUENT_RULES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CatalogPriceRule` object types. All fields are
tested for equality and combined with a logical and.
"""
input CatalogPriceRuleCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `rule` field."""
  rule: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `active` field."""
  active: Boolean
  """Checks for equality with the objects `customerGroups` field."""
  customerGroups: String
  """Checks for equality with the objects `priority` field."""
  priority: String
  """Checks for equality with the objects `startDate` field."""
  startDate: Date
  """Checks for equality with the objects `endDate` field."""
  endDate: Date
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `website` field."""
  website: String
  """Checks for equality with the objects `actionsApply` field."""
  actionsApply: String
  """Checks for equality with the objects `actionsDiscountAmount` field."""
  actionsDiscountAmount: BigFloat
  """Checks for equality with the objects `actionsDiscardSubsequentRules` field."""
  actionsDiscardSubsequentRules: Boolean
}

"""A connection to a list of `Category` values."""
type CategoriesConnection {
  """A list of `Category` objects."""
  nodes: [Category]!
  """A list of edges which contains the `Category` and cursor to aid in pagination."""
  edges: [CategoriesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

"""A `Category` edge in the connection."""
type CategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Category` at the end of the edge."""
  node: Category
}

"""A connection to a list of `Channel` values."""
type ChannelsConnection {
  """A list of `Channel` objects."""
  nodes: [Channel]!
  """A list of edges which contains the `Channel` and cursor to aid in pagination."""
  edges: [ChannelsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Channel` you could get from the connection."""
  totalCount: Int!
}

type Channel implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  currency: String
  defaultLang: String
  includeTax: String
  defaultZone: String
  defaultShipping: String
  clientId: String
  clientSecret: String
}

"""A `Channel` edge in the connection."""
type ChannelsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Channel` at the end of the edge."""
  node: Channel
}

"""Methods to use when ordering `Channel`."""
enum ChannelsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  CURRENCY_ASC
  CURRENCY_DESC
  DEFAULT_LANG_ASC
  DEFAULT_LANG_DESC
  INCLUDE_TAX_ASC
  INCLUDE_TAX_DESC
  DEFAULT_ZONE_ASC
  DEFAULT_ZONE_DESC
  DEFAULT_SHIPPING_ASC
  DEFAULT_SHIPPING_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Channel` object types. All fields are tested for equality and combined with a logical and."""
input ChannelCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `code` field."""
  code: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `currency` field."""
  currency: String
  """Checks for equality with the objects `defaultLang` field."""
  defaultLang: String
  """Checks for equality with the objects `includeTax` field."""
  includeTax: String
  """Checks for equality with the objects `defaultZone` field."""
  defaultZone: String
  """Checks for equality with the objects `defaultShipping` field."""
  defaultShipping: String
  """Checks for equality with the objects `clientId` field."""
  clientId: String
  """Checks for equality with the objects `clientSecret` field."""
  clientSecret: String
}

"""A connection to a list of `Checklist` values."""
type ChecklistsConnection {
  """A list of `Checklist` objects."""
  nodes: [Checklist]!
  """A list of edges which contains the `Checklist` and cursor to aid in pagination."""
  edges: [ChecklistsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Checklist` you could get from the connection."""
  totalCount: Int!
}

"""A `Checklist` edge in the connection."""
type ChecklistsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Checklist` at the end of the edge."""
  node: Checklist
}

"""A connection to a list of `City` values."""
type CitiesConnection {
  """A list of `City` objects."""
  nodes: [City]!
  """A list of edges which contains the `City` and cursor to aid in pagination."""
  edges: [CitiesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `City` you could get from the connection."""
  totalCount: Int!
}

type City implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  name: String!
  description: String
  state: String
  country: String
  postalCode: String
  image: String
}

"""A `City` edge in the connection."""
type CitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `City` at the end of the edge."""
  node: City
}

"""Methods to use when ordering `City`."""
enum CitiesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  POSTAL_CODE_ASC
  POSTAL_CODE_DESC
  IMAGE_ASC
  IMAGE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `City` object types. All fields are tested for equality and combined with a logical and."""
input CityCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `postalCode` field."""
  postalCode: String
  """Checks for equality with the objects `image` field."""
  image: String
}

"""A connection to a list of `Collection` values."""
type CollectionsConnection {
  """A list of `Collection` objects."""
  nodes: [Collection]!
  """A list of edges which contains the `Collection` and cursor to aid in pagination."""
  edges: [CollectionsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Collection` you could get from the connection."""
  totalCount: Int!
}

type Collection implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  description: String
  image: String
  product: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
}

"""A `Collection` edge in the connection."""
type CollectionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Collection` at the end of the edge."""
  node: Collection
}

"""Methods to use when ordering `Collection`."""
enum CollectionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  META_TITLE_ASC
  META_TITLE_DESC
  META_KEYWORDS_ASC
  META_KEYWORDS_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Collection` object types. All fields are tested
for equality and combined with a logical and.
"""
input CollectionCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `product` field."""
  product: String
  """Checks for equality with the objects `metaTitle` field."""
  metaTitle: String
  """Checks for equality with the objects `metaKeywords` field."""
  metaKeywords: String
  """Checks for equality with the objects `metaDescription` field."""
  metaDescription: String
}

"""A connection to a list of `ContentType` values."""
type ContentTypesConnection {
  """A list of `ContentType` objects."""
  nodes: [ContentType]!
  """A list of edges which contains the `ContentType` and cursor to aid in pagination."""
  edges: [ContentTypesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `ContentType` you could get from the connection."""
  totalCount: Int!
}

type ContentType implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  text: String
  number: BigFloat
  json: JSON
  link: String
  email: String
  uid: UUID
  date: Date
  time: Time
  timestamp: Datetime
  boolean: Boolean
  richText: String
  password: String
  media: String
  databaseName: String
}

"""A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122)."""
scalar UUID

"""The exact time of day, does not include the date. May or may not have a timezone offset."""
scalar Time

"""A `ContentType` edge in the connection."""
type ContentTypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `ContentType` at the end of the edge."""
  node: ContentType
}

"""Methods to use when ordering `ContentType`."""
enum ContentTypesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  TEXT_ASC
  TEXT_DESC
  NUMBER_ASC
  NUMBER_DESC
  JSON_ASC
  JSON_DESC
  LINK_ASC
  LINK_DESC
  EMAIL_ASC
  EMAIL_DESC
  UID_ASC
  UID_DESC
  DATE_ASC
  DATE_DESC
  TIME_ASC
  TIME_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  BOOLEAN_ASC
  BOOLEAN_DESC
  RICH_TEXT_ASC
  RICH_TEXT_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  MEDIA_ASC
  MEDIA_DESC
  DATABASE_NAME_ASC
  DATABASE_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ContentType` object types. All fields are tested
for equality and combined with a logical and.
"""
input ContentTypeCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `text` field."""
  text: String
  """Checks for equality with the objects `number` field."""
  number: BigFloat
  """Checks for equality with the objects `json` field."""
  json: JSON
  """Checks for equality with the objects `link` field."""
  link: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `uid` field."""
  uid: UUID
  """Checks for equality with the objects `date` field."""
  date: Date
  """Checks for equality with the objects `time` field."""
  time: Time
  """Checks for equality with the objects `timestamp` field."""
  timestamp: Datetime
  """Checks for equality with the objects `boolean` field."""
  boolean: Boolean
  """Checks for equality with the objects `richText` field."""
  richText: String
  """Checks for equality with the objects `password` field."""
  password: String
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `databaseName` field."""
  databaseName: String
}

"""A connection to a list of `Contract` values."""
type ContractsConnection {
  """A list of `Contract` objects."""
  nodes: [Contract]!
  """A list of edges which contains the `Contract` and cursor to aid in pagination."""
  edges: [ContractsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Contract` you could get from the connection."""
  totalCount: Int!
}

type Contract implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  contractTitle: String
  contractValue: String
  startDate: String
  endDate: String
  renewalReminder: String
  customerSignedDate: String
  companySignedDate: String
  status: String
  contractManager: String
  account: String
  contact: String
  description: String
  opportunity: String
  contractType: String
  currency: String
  lineItems: String
  total: String
  discount: String
  subtotal: String
  shipping: String
  shippingTax: String
  tax: String
  grandTotal: String
  createdAt: Datetime
}

"""A `Contract` edge in the connection."""
type ContractsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Contract` at the end of the edge."""
  node: Contract
}

"""Methods to use when ordering `Contract`."""
enum ContractsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CONTRACT_TITLE_ASC
  CONTRACT_TITLE_DESC
  CONTRACT_VALUE_ASC
  CONTRACT_VALUE_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  RENEWAL_REMINDER_ASC
  RENEWAL_REMINDER_DESC
  CUSTOMER_SIGNED_DATE_ASC
  CUSTOMER_SIGNED_DATE_DESC
  COMPANY_SIGNED_DATE_ASC
  COMPANY_SIGNED_DATE_DESC
  STATUS_ASC
  STATUS_DESC
  CONTRACT_MANAGER_ASC
  CONTRACT_MANAGER_DESC
  ACCOUNT_ASC
  ACCOUNT_DESC
  CONTACT_ASC
  CONTACT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  OPPORTUNITY_ASC
  OPPORTUNITY_DESC
  CONTRACT_TYPE_ASC
  CONTRACT_TYPE_DESC
  CURRENCY_ASC
  CURRENCY_DESC
  LINE_ITEMS_ASC
  LINE_ITEMS_DESC
  TOTAL_ASC
  TOTAL_DESC
  DISCOUNT_ASC
  DISCOUNT_DESC
  SUBTOTAL_ASC
  SUBTOTAL_DESC
  SHIPPING_ASC
  SHIPPING_DESC
  SHIPPING_TAX_ASC
  SHIPPING_TAX_DESC
  TAX_ASC
  TAX_DESC
  GRAND_TOTAL_ASC
  GRAND_TOTAL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Contract` object types. All fields are tested
for equality and combined with a logical and.
"""
input ContractCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `contractTitle` field."""
  contractTitle: String
  """Checks for equality with the objects `contractValue` field."""
  contractValue: String
  """Checks for equality with the objects `startDate` field."""
  startDate: String
  """Checks for equality with the objects `endDate` field."""
  endDate: String
  """Checks for equality with the objects `renewalReminder` field."""
  renewalReminder: String
  """Checks for equality with the objects `customerSignedDate` field."""
  customerSignedDate: String
  """Checks for equality with the objects `companySignedDate` field."""
  companySignedDate: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `contractManager` field."""
  contractManager: String
  """Checks for equality with the objects `account` field."""
  account: String
  """Checks for equality with the objects `contact` field."""
  contact: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `opportunity` field."""
  opportunity: String
  """Checks for equality with the objects `contractType` field."""
  contractType: String
  """Checks for equality with the objects `currency` field."""
  currency: String
  """Checks for equality with the objects `lineItems` field."""
  lineItems: String
  """Checks for equality with the objects `total` field."""
  total: String
  """Checks for equality with the objects `discount` field."""
  discount: String
  """Checks for equality with the objects `subtotal` field."""
  subtotal: String
  """Checks for equality with the objects `shipping` field."""
  shipping: String
  """Checks for equality with the objects `shippingTax` field."""
  shippingTax: String
  """Checks for equality with the objects `tax` field."""
  tax: String
  """Checks for equality with the objects `grandTotal` field."""
  grandTotal: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
}

"""A connection to a list of `Country` values."""
type CountriesConnection {
  """A list of `Country` objects."""
  nodes: [Country]!
  """A list of edges which contains the `Country` and cursor to aid in pagination."""
  edges: [CountriesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Country` you could get from the connection."""
  totalCount: Int!
}

"""A `Country` edge in the connection."""
type CountriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Country` at the end of the edge."""
  node: Country
}

"""A connection to a list of `Currency` values."""
type CurrenciesConnection {
  """A list of `Currency` objects."""
  nodes: [Currency]!
  """A list of edges which contains the `Currency` and cursor to aid in pagination."""
  edges: [CurrenciesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Currency` you could get from the connection."""
  totalCount: Int!
}

type Currency implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  region: String
}

"""A `Currency` edge in the connection."""
type CurrenciesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Currency` at the end of the edge."""
  node: Currency
}

"""Methods to use when ordering `Currency`."""
enum CurrenciesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  REGION_ASC
  REGION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Currency` object types. All fields are tested
for equality and combined with a logical and.
"""
input CurrencyCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `code` field."""
  code: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `region` field."""
  region: String
}

"""A connection to a list of `CurrencyRate` values."""
type CurrencyRatesConnection {
  """A list of `CurrencyRate` objects."""
  nodes: [CurrencyRate]!
  """A list of edges which contains the `CurrencyRate` and cursor to aid in pagination."""
  edges: [CurrencyRatesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `CurrencyRate` you could get from the connection."""
  totalCount: Int!
}

type CurrencyRate implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  importService: String!
  usd: Float
  id: BigInt!
}

"""A `CurrencyRate` edge in the connection."""
type CurrencyRatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `CurrencyRate` at the end of the edge."""
  node: CurrencyRate
}

"""Methods to use when ordering `CurrencyRate`."""
enum CurrencyRatesOrderBy {
  NATURAL
  IMPORT_SERVICE_ASC
  IMPORT_SERVICE_DESC
  USD_ASC
  USD_DESC
  ID_ASC
  ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CurrencyRate` object types. All fields are
tested for equality and combined with a logical and.
"""
input CurrencyRateCondition {
  """Checks for equality with the objects `importService` field."""
  importService: String
  """Checks for equality with the objects `usd` field."""
  usd: Float
  """Checks for equality with the objects `id` field."""
  id: BigInt
}

"""A connection to a list of `CurrencySymbol` values."""
type CurrencySymbolsConnection {
  """A list of `CurrencySymbol` objects."""
  nodes: [CurrencySymbol]!
  """A list of edges which contains the `CurrencySymbol` and cursor to aid in pagination."""
  edges: [CurrencySymbolsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `CurrencySymbol` you could get from the connection."""
  totalCount: Int!
}

type CurrencySymbol implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  symbol: String!
  useStandard: Boolean
  id: BigInt!
}

"""A `CurrencySymbol` edge in the connection."""
type CurrencySymbolsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `CurrencySymbol` at the end of the edge."""
  node: CurrencySymbol
}

"""Methods to use when ordering `CurrencySymbol`."""
enum CurrencySymbolsOrderBy {
  NATURAL
  SYMBOL_ASC
  SYMBOL_DESC
  USE_STANDARD_ASC
  USE_STANDARD_DESC
  ID_ASC
  ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CurrencySymbol` object types. All fields are
tested for equality and combined with a logical and.
"""
input CurrencySymbolCondition {
  """Checks for equality with the objects `symbol` field."""
  symbol: String
  """Checks for equality with the objects `useStandard` field."""
  useStandard: Boolean
  """Checks for equality with the objects `id` field."""
  id: BigInt
}

"""A connection to a list of `Customer` values."""
type CustomersConnection {
  """A list of `Customer` objects."""
  nodes: [Customer]!
  """A list of edges which contains the `Customer` and cursor to aid in pagination."""
  edges: [CustomersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

"""A `Customer` edge in the connection."""
type CustomersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customer` at the end of the edge."""
  node: Customer
}

"""A connection to a list of `Customization` values."""
type CustomizationsConnection {
  """A list of `Customization` objects."""
  nodes: [Customization]!
  """A list of edges which contains the `Customization` and cursor to aid in pagination."""
  edges: [CustomizationsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Customization` you could get from the connection."""
  totalCount: Int!
}

type Customization implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  createdAt: Datetime
  siteName: String
  navLink: String
  notification: String
  banner: String
  footerLink: String
  announcement: String
  email: String
  siteUrl: String
  allowSignup: String
}

"""A `Customization` edge in the connection."""
type CustomizationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Customization` at the end of the edge."""
  node: Customization
}

"""Methods to use when ordering `Customization`."""
enum CustomizationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  SITE_NAME_ASC
  SITE_NAME_DESC
  NAV_LINK_ASC
  NAV_LINK_DESC
  NOTIFICATION_ASC
  NOTIFICATION_DESC
  BANNER_ASC
  BANNER_DESC
  FOOTER_LINK_ASC
  FOOTER_LINK_DESC
  ANNOUNCEMENT_ASC
  ANNOUNCEMENT_DESC
  EMAIL_ASC
  EMAIL_DESC
  SITE_URL_ASC
  SITE_URL_DESC
  ALLOW_SIGNUP_ASC
  ALLOW_SIGNUP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Customization` object types. All fields are
tested for equality and combined with a logical and.
"""
input CustomizationCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `siteName` field."""
  siteName: String
  """Checks for equality with the objects `navLink` field."""
  navLink: String
  """Checks for equality with the objects `notification` field."""
  notification: String
  """Checks for equality with the objects `banner` field."""
  banner: String
  """Checks for equality with the objects `footerLink` field."""
  footerLink: String
  """Checks for equality with the objects `announcement` field."""
  announcement: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `siteUrl` field."""
  siteUrl: String
  """Checks for equality with the objects `allowSignup` field."""
  allowSignup: String
}

"""A connection to a list of `Dashboard` values."""
type DashboardsConnection {
  """A list of `Dashboard` objects."""
  nodes: [Dashboard]!
  """A list of edges which contains the `Dashboard` and cursor to aid in pagination."""
  edges: [DashboardsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Dashboard` you could get from the connection."""
  totalCount: Int!
}

type Dashboard implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  clientId: String
  clientSecret: String
  privacy: String
  category: String
  url: String
  media: String
  task: String
  reports: String
  tasks: String
  projects: String
  tickets: String
  customers: String
  checklists: String
  visits: String
  users: String
  products: String
  articles: String
  sales: String
}

"""A `Dashboard` edge in the connection."""
type DashboardsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Dashboard` at the end of the edge."""
  node: Dashboard
}

"""Methods to use when ordering `Dashboard`."""
enum DashboardsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  PRIVACY_ASC
  PRIVACY_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  URL_ASC
  URL_DESC
  MEDIA_ASC
  MEDIA_DESC
  TASK_ASC
  TASK_DESC
  REPORTS_ASC
  REPORTS_DESC
  TASKS_ASC
  TASKS_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  TICKETS_ASC
  TICKETS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  CHECKLISTS_ASC
  CHECKLISTS_DESC
  VISITS_ASC
  VISITS_DESC
  USERS_ASC
  USERS_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  SALES_ASC
  SALES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Dashboard` object types. All fields are tested
for equality and combined with a logical and.
"""
input DashboardCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `clientId` field."""
  clientId: String
  """Checks for equality with the objects `clientSecret` field."""
  clientSecret: String
  """Checks for equality with the objects `privacy` field."""
  privacy: String
  """Checks for equality with the objects `category` field."""
  category: String
  """Checks for equality with the objects `url` field."""
  url: String
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `task` field."""
  task: String
  """Checks for equality with the objects `reports` field."""
  reports: String
  """Checks for equality with the objects `tasks` field."""
  tasks: String
  """Checks for equality with the objects `projects` field."""
  projects: String
  """Checks for equality with the objects `tickets` field."""
  tickets: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `checklists` field."""
  checklists: String
  """Checks for equality with the objects `visits` field."""
  visits: String
  """Checks for equality with the objects `users` field."""
  users: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `articles` field."""
  articles: String
  """Checks for equality with the objects `sales` field."""
  sales: String
}

"""A connection to a list of `Deepdive` values."""
type DeepdivesConnection {
  """A list of `Deepdive` objects."""
  nodes: [Deepdive]!
  """A list of edges which contains the `Deepdive` and cursor to aid in pagination."""
  edges: [DeepdivesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Deepdive` you could get from the connection."""
  totalCount: Int!
}

type Deepdive implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  endDate: String
  content: String
  attendees: String
  login: String
  startDate: String
  whid: String
}

"""A `Deepdive` edge in the connection."""
type DeepdivesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Deepdive` at the end of the edge."""
  node: Deepdive
}

"""Methods to use when ordering `Deepdive`."""
enum DeepdivesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  END_DATE_ASC
  END_DATE_DESC
  CONTENT_ASC
  CONTENT_DESC
  ATTENDEES_ASC
  ATTENDEES_DESC
  LOGIN_ASC
  LOGIN_DESC
  START_DATE_ASC
  START_DATE_DESC
  WHID_ASC
  WHID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Deepdive` object types. All fields are tested
for equality and combined with a logical and.
"""
input DeepdiveCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `endDate` field."""
  endDate: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `attendees` field."""
  attendees: String
  """Checks for equality with the objects `login` field."""
  login: String
  """Checks for equality with the objects `startDate` field."""
  startDate: String
  """Checks for equality with the objects `whid` field."""
  whid: String
}

"""A connection to a list of `EmailTemplate` values."""
type EmailTemplatesConnection {
  """A list of `EmailTemplate` objects."""
  nodes: [EmailTemplate]!
  """A list of edges which contains the `EmailTemplate` and cursor to aid in pagination."""
  edges: [EmailTemplatesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `EmailTemplate` you could get from the connection."""
  totalCount: Int!
}

type EmailTemplate implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  assignedTo: String
  type: String
  active: String
  insertVariable: String
  subject: String
  content: String
  header: String
  footer: String
  width: String
  height: String
  media: String
}

"""A `EmailTemplate` edge in the connection."""
type EmailTemplatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `EmailTemplate` at the end of the edge."""
  node: EmailTemplate
}

"""Methods to use when ordering `EmailTemplate`."""
enum EmailTemplatesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  TYPE_ASC
  TYPE_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  INSERT_VARIABLE_ASC
  INSERT_VARIABLE_DESC
  SUBJECT_ASC
  SUBJECT_DESC
  CONTENT_ASC
  CONTENT_DESC
  HEADER_ASC
  HEADER_DESC
  FOOTER_ASC
  FOOTER_DESC
  WIDTH_ASC
  WIDTH_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  MEDIA_ASC
  MEDIA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `EmailTemplate` object types. All fields are
tested for equality and combined with a logical and.
"""
input EmailTemplateCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `type` field."""
  type: String
  """Checks for equality with the objects `active` field."""
  active: String
  """Checks for equality with the objects `insertVariable` field."""
  insertVariable: String
  """Checks for equality with the objects `subject` field."""
  subject: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `header` field."""
  header: String
  """Checks for equality with the objects `footer` field."""
  footer: String
  """Checks for equality with the objects `width` field."""
  width: String
  """Checks for equality with the objects `height` field."""
  height: String
  """Checks for equality with the objects `media` field."""
  media: String
}

"""A connection to a list of `Event` values."""
type EventsConnection {
  """A list of `Event` objects."""
  nodes: [Event]!
  """A list of edges which contains the `Event` and cursor to aid in pagination."""
  edges: [EventsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Event` you could get from the connection."""
  totalCount: Int!
}

type Event implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  content: String
  tickets: String
  image: String
  start: String
  end: String
  category: String
  city: String
  state: String
  country: String
  postalcode: String
}

"""A `Event` edge in the connection."""
type EventsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Event` at the end of the edge."""
  node: Event
}

"""Methods to use when ordering `Event`."""
enum EventsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  TICKETS_ASC
  TICKETS_DESC
  IMAGE_ASC
  IMAGE_DESC
  START_ASC
  START_DESC
  END_ASC
  END_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  POSTALCODE_ASC
  POSTALCODE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical and."""
input EventCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `tickets` field."""
  tickets: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `start` field."""
  start: String
  """Checks for equality with the objects `end` field."""
  end: String
  """Checks for equality with the objects `category` field."""
  category: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `postalcode` field."""
  postalcode: String
}

"""A connection to a list of `Fullfillment` values."""
type FullfillmentsConnection {
  """A list of `Fullfillment` objects."""
  nodes: [Fullfillment]!
  """A list of edges which contains the `Fullfillment` and cursor to aid in pagination."""
  edges: [FullfillmentsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Fullfillment` you could get from the connection."""
  totalCount: Int!
}

type Fullfillment implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  shippingZones: String
  company: String
  address: String
  addressTwo: String
  city: String
  state: String
  zipcode: String
  country: String
  countryArea: String
  phone: String
  pickup: String
  stock: String
}

"""A `Fullfillment` edge in the connection."""
type FullfillmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Fullfillment` at the end of the edge."""
  node: Fullfillment
}

"""Methods to use when ordering `Fullfillment`."""
enum FullfillmentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  SHIPPING_ZONES_ASC
  SHIPPING_ZONES_DESC
  COMPANY_ASC
  COMPANY_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ADDRESS_TWO_ASC
  ADDRESS_TWO_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  ZIPCODE_ASC
  ZIPCODE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  COUNTRY_AREA_ASC
  COUNTRY_AREA_DESC
  PHONE_ASC
  PHONE_DESC
  PICKUP_ASC
  PICKUP_DESC
  STOCK_ASC
  STOCK_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Fullfillment` object types. All fields are
tested for equality and combined with a logical and.
"""
input FullfillmentCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `shippingZones` field."""
  shippingZones: String
  """Checks for equality with the objects `company` field."""
  company: String
  """Checks for equality with the objects `address` field."""
  address: String
  """Checks for equality with the objects `addressTwo` field."""
  addressTwo: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `zipcode` field."""
  zipcode: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `countryArea` field."""
  countryArea: String
  """Checks for equality with the objects `phone` field."""
  phone: String
  """Checks for equality with the objects `pickup` field."""
  pickup: String
  """Checks for equality with the objects `stock` field."""
  stock: String
}

"""A connection to a list of `GeneralSetting` values."""
type GeneralSettingsConnection {
  """A list of `GeneralSetting` objects."""
  nodes: [GeneralSetting]!
  """A list of edges which contains the `GeneralSetting` and cursor to aid in pagination."""
  edges: [GeneralSettingsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `GeneralSetting` you could get from the connection."""
  totalCount: Int!
}

type GeneralSetting implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  title: String
  tagline: String
  url: String
  email: String
  accessRestrictions: String
  restrictionMode: String
  startupPage: String
  landingPage: String
  httpResponse: String
  storeEmail: String
  storeContact: String
  storeContactTwo: String
  customerSupport: String
}

"""A `GeneralSetting` edge in the connection."""
type GeneralSettingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `GeneralSetting` at the end of the edge."""
  node: GeneralSetting
}

"""Methods to use when ordering `GeneralSetting`."""
enum GeneralSettingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  TITLE_ASC
  TITLE_DESC
  TAGLINE_ASC
  TAGLINE_DESC
  URL_ASC
  URL_DESC
  EMAIL_ASC
  EMAIL_DESC
  ACCESS_RESTRICTIONS_ASC
  ACCESS_RESTRICTIONS_DESC
  RESTRICTION_MODE_ASC
  RESTRICTION_MODE_DESC
  STARTUP_PAGE_ASC
  STARTUP_PAGE_DESC
  LANDING_PAGE_ASC
  LANDING_PAGE_DESC
  HTTP_RESPONSE_ASC
  HTTP_RESPONSE_DESC
  STORE_EMAIL_ASC
  STORE_EMAIL_DESC
  STORE_CONTACT_ASC
  STORE_CONTACT_DESC
  STORE_CONTACT_TWO_ASC
  STORE_CONTACT_TWO_DESC
  CUSTOMER_SUPPORT_ASC
  CUSTOMER_SUPPORT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `GeneralSetting` object types. All fields are
tested for equality and combined with a logical and.
"""
input GeneralSettingCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `title` field."""
  title: String
  """Checks for equality with the objects `tagline` field."""
  tagline: String
  """Checks for equality with the objects `url` field."""
  url: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `accessRestrictions` field."""
  accessRestrictions: String
  """Checks for equality with the objects `restrictionMode` field."""
  restrictionMode: String
  """Checks for equality with the objects `startupPage` field."""
  startupPage: String
  """Checks for equality with the objects `landingPage` field."""
  landingPage: String
  """Checks for equality with the objects `httpResponse` field."""
  httpResponse: String
  """Checks for equality with the objects `storeEmail` field."""
  storeEmail: String
  """Checks for equality with the objects `storeContact` field."""
  storeContact: String
  """Checks for equality with the objects `storeContactTwo` field."""
  storeContactTwo: String
  """Checks for equality with the objects `customerSupport` field."""
  customerSupport: String
}

"""A connection to a list of `GiftCertificate` values."""
type GiftCertificatesConnection {
  """A list of `GiftCertificate` objects."""
  nodes: [GiftCertificate]!
  """A list of edges which contains the `GiftCertificate` and cursor to aid in pagination."""
  edges: [GiftCertificatesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `GiftCertificate` you could get from the connection."""
  totalCount: Int!
}

type GiftCertificate implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  excerpt: String
  discount: String
  image: String
  published: Datetime
  specialOffers: String
  rewards: String
  coupons: String
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  type: String
}

"""A `GiftCertificate` edge in the connection."""
type GiftCertificatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `GiftCertificate` at the end of the edge."""
  node: GiftCertificate
}

"""Methods to use when ordering `GiftCertificate`."""
enum GiftCertificatesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  DISCOUNT_ASC
  DISCOUNT_DESC
  IMAGE_ASC
  IMAGE_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  SPECIAL_OFFERS_ASC
  SPECIAL_OFFERS_DESC
  REWARDS_ASC
  REWARDS_DESC
  COUPONS_ASC
  COUPONS_DESC
  EXPIRATION_ASC
  EXPIRATION_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  TYPE_ASC
  TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `GiftCertificate` object types. All fields are
tested for equality and combined with a logical and.
"""
input GiftCertificateCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `excerpt` field."""
  excerpt: String
  """Checks for equality with the objects `discount` field."""
  discount: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `published` field."""
  published: Datetime
  """Checks for equality with the objects `specialOffers` field."""
  specialOffers: String
  """Checks for equality with the objects `rewards` field."""
  rewards: String
  """Checks for equality with the objects `coupons` field."""
  coupons: String
  """Checks for equality with the objects `expiration` field."""
  expiration: String
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `articles` field."""
  articles: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `users` field."""
  users: String
  """Checks for equality with the objects `type` field."""
  type: String
}

"""A connection to a list of `Glossary` values."""
type GlossariesConnection {
  """A list of `Glossary` objects."""
  nodes: [Glossary]!
  """A list of edges which contains the `Glossary` and cursor to aid in pagination."""
  edges: [GlossariesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Glossary` you could get from the connection."""
  totalCount: Int!
}

type Glossary implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: Int!
  name: String!
  content: String
  image: String
  published: Datetime
}

"""A `Glossary` edge in the connection."""
type GlossariesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Glossary` at the end of the edge."""
  node: Glossary
}

"""Methods to use when ordering `Glossary`."""
enum GlossariesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  IMAGE_ASC
  IMAGE_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Glossary` object types. All fields are tested
for equality and combined with a logical and.
"""
input GlossaryCondition {
  """Checks for equality with the objects `id` field."""
  id: Int
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `published` field."""
  published: Datetime
}

"""A connection to a list of `Importm` values."""
type ImportmsConnection {
  """A list of `Importm` objects."""
  nodes: [Importm]!
  """A list of edges which contains the `Importm` and cursor to aid in pagination."""
  edges: [ImportmsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Importm` you could get from the connection."""
  totalCount: Int!
}

type Importm implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  description: String
  file: String
  url: String
  image: String
}

"""A `Importm` edge in the connection."""
type ImportmsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Importm` at the end of the edge."""
  node: Importm
}

"""Methods to use when ordering `Importm`."""
enum ImportmsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  FILE_ASC
  FILE_DESC
  URL_ASC
  URL_DESC
  IMAGE_ASC
  IMAGE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Importm` object types. All fields are tested for equality and combined with a logical and."""
input ImportmCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `file` field."""
  file: String
  """Checks for equality with the objects `url` field."""
  url: String
  """Checks for equality with the objects `image` field."""
  image: String
}

"""A connection to a list of `Integration` values."""
type IntegrationsConnection {
  """A list of `Integration` objects."""
  nodes: [Integration]!
  """A list of edges which contains the `Integration` and cursor to aid in pagination."""
  edges: [IntegrationsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Integration` you could get from the connection."""
  totalCount: Int!
}

type Integration implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  content: String
  media: String
  location: String
  category: String
}

"""A `Integration` edge in the connection."""
type IntegrationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Integration` at the end of the edge."""
  node: Integration
}

"""Methods to use when ordering `Integration`."""
enum IntegrationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  MEDIA_ASC
  MEDIA_DESC
  LOCATION_ASC
  LOCATION_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Integration` object types. All fields are tested
for equality and combined with a logical and.
"""
input IntegrationCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `location` field."""
  location: String
  """Checks for equality with the objects `category` field."""
  category: String
}

"""A connection to a list of `Internalization` values."""
type InternalizationsConnection {
  """A list of `Internalization` objects."""
  nodes: [Internalization]!
  """A list of edges which contains the `Internalization` and cursor to aid in pagination."""
  edges: [InternalizationsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Internalization` you could get from the connection."""
  totalCount: Int!
}

type Internalization implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  region: String
  description: String
  default: String
  website: String
}

"""A `Internalization` edge in the connection."""
type InternalizationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Internalization` at the end of the edge."""
  node: Internalization
}

"""Methods to use when ordering `Internalization`."""
enum InternalizationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  REGION_ASC
  REGION_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  DEFAULT_ASC
  DEFAULT_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Internalization` object types. All fields are
tested for equality and combined with a logical and.
"""
input InternalizationCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `region` field."""
  region: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `default` field."""
  default: String
  """Checks for equality with the objects `website` field."""
  website: String
}

"""A connection to a list of `Invitation` values."""
type InvitationsConnection {
  """A list of `Invitation` objects."""
  nodes: [Invitation]!
  """A list of edges which contains the `Invitation` and cursor to aid in pagination."""
  edges: [InvitationsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Invitation` you could get from the connection."""
  totalCount: Int!
}

type Invitation implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  invoiceDate: Datetime
  email: String
  billingAddress: String
  shippingAddress: String
  orderNumber: String
  grandTotalPurchased: String
  paymentMethod: String
  status: String
  media: String
  content: String
}

"""A `Invitation` edge in the connection."""
type InvitationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Invitation` at the end of the edge."""
  node: Invitation
}

"""Methods to use when ordering `Invitation`."""
enum InvitationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  INVOICE_DATE_ASC
  INVOICE_DATE_DESC
  EMAIL_ASC
  EMAIL_DESC
  BILLING_ADDRESS_ASC
  BILLING_ADDRESS_DESC
  SHIPPING_ADDRESS_ASC
  SHIPPING_ADDRESS_DESC
  ORDER_NUMBER_ASC
  ORDER_NUMBER_DESC
  GRAND_TOTAL_PURCHASED_ASC
  GRAND_TOTAL_PURCHASED_DESC
  PAYMENT_METHOD_ASC
  PAYMENT_METHOD_DESC
  STATUS_ASC
  STATUS_DESC
  MEDIA_ASC
  MEDIA_DESC
  CONTENT_ASC
  CONTENT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Invitation` object types. All fields are tested
for equality and combined with a logical and.
"""
input InvitationCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `invoiceDate` field."""
  invoiceDate: Datetime
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `billingAddress` field."""
  billingAddress: String
  """Checks for equality with the objects `shippingAddress` field."""
  shippingAddress: String
  """Checks for equality with the objects `orderNumber` field."""
  orderNumber: String
  """Checks for equality with the objects `grandTotalPurchased` field."""
  grandTotalPurchased: String
  """Checks for equality with the objects `paymentMethod` field."""
  paymentMethod: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `media` field."""
  media: String
  """Checks for equality with the objects `content` field."""
  content: String
}

"""A connection to a list of `Invoice` values."""
type InvoicesConnection {
  """A list of `Invoice` objects."""
  nodes: [Invoice]!
  """A list of edges which contains the `Invoice` and cursor to aid in pagination."""
  edges: [InvoicesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Invoice` you could get from the connection."""
  totalCount: Int!
}

type Invoice implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  invoice: Int!
  orderNumber: BigInt!
  invoiceDate: Datetime
  billToName: String!
  billingAddress: String
  grandTotalBase: String
  grandTotalPurchased: String
  status: String
  shippingAddress: String
  customerName: String
  email: String
  customerGroup: String
  paymentMethod: String
  shippingInformation: String
  subtotal: String
  shippingAndHandling: String
  id: BigInt!
}

"""A `Invoice` edge in the connection."""
type InvoicesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Invoice` at the end of the edge."""
  node: Invoice
}

"""Methods to use when ordering `Invoice`."""
enum InvoicesOrderBy {
  NATURAL
  INVOICE_ASC
  INVOICE_DESC
  ORDER_NUMBER_ASC
  ORDER_NUMBER_DESC
  INVOICE_DATE_ASC
  INVOICE_DATE_DESC
  BILL_TO_NAME_ASC
  BILL_TO_NAME_DESC
  BILLING_ADDRESS_ASC
  BILLING_ADDRESS_DESC
  GRAND_TOTAL_BASE_ASC
  GRAND_TOTAL_BASE_DESC
  GRAND_TOTAL_PURCHASED_ASC
  GRAND_TOTAL_PURCHASED_DESC
  STATUS_ASC
  STATUS_DESC
  SHIPPING_ADDRESS_ASC
  SHIPPING_ADDRESS_DESC
  CUSTOMER_NAME_ASC
  CUSTOMER_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  CUSTOMER_GROUP_ASC
  CUSTOMER_GROUP_DESC
  PAYMENT_METHOD_ASC
  PAYMENT_METHOD_DESC
  SHIPPING_INFORMATION_ASC
  SHIPPING_INFORMATION_DESC
  SUBTOTAL_ASC
  SUBTOTAL_DESC
  SHIPPING_AND_HANDLING_ASC
  SHIPPING_AND_HANDLING_DESC
  ID_ASC
  ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Invoice` object types. All fields are tested for equality and combined with a logical and."""
input InvoiceCondition {
  """Checks for equality with the objects `invoice` field."""
  invoice: Int
  """Checks for equality with the objects `orderNumber` field."""
  orderNumber: BigInt
  """Checks for equality with the objects `invoiceDate` field."""
  invoiceDate: Datetime
  """Checks for equality with the objects `billToName` field."""
  billToName: String
  """Checks for equality with the objects `billingAddress` field."""
  billingAddress: String
  """Checks for equality with the objects `grandTotalBase` field."""
  grandTotalBase: String
  """Checks for equality with the objects `grandTotalPurchased` field."""
  grandTotalPurchased: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `shippingAddress` field."""
  shippingAddress: String
  """Checks for equality with the objects `customerName` field."""
  customerName: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `customerGroup` field."""
  customerGroup: String
  """Checks for equality with the objects `paymentMethod` field."""
  paymentMethod: String
  """Checks for equality with the objects `shippingInformation` field."""
  shippingInformation: String
  """Checks for equality with the objects `subtotal` field."""
  subtotal: String
  """Checks for equality with the objects `shippingAndHandling` field."""
  shippingAndHandling: String
  """Checks for equality with the objects `id` field."""
  id: BigInt
}

"""A connection to a list of `Knowledgebase` values."""
type KnowledgebasesConnection {
  """A list of `Knowledgebase` objects."""
  nodes: [Knowledgebase]!
  """A list of edges which contains the `Knowledgebase` and cursor to aid in pagination."""
  edges: [KnowledgebasesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Knowledgebase` you could get from the connection."""
  totalCount: Int!
}

type Knowledgebase implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  status: String
  revision: String
  content: String
  resolution: String
  author: String
  approver: String
  dateModified: Datetime
}

"""A `Knowledgebase` edge in the connection."""
type KnowledgebasesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Knowledgebase` at the end of the edge."""
  node: Knowledgebase
}

"""Methods to use when ordering `Knowledgebase`."""
enum KnowledgebasesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  STATUS_ASC
  STATUS_DESC
  REVISION_ASC
  REVISION_DESC
  CONTENT_ASC
  CONTENT_DESC
  RESOLUTION_ASC
  RESOLUTION_DESC
  AUTHOR_ASC
  AUTHOR_DESC
  APPROVER_ASC
  APPROVER_DESC
  DATE_MODIFIED_ASC
  DATE_MODIFIED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Knowledgebase` object types. All fields are
tested for equality and combined with a logical and.
"""
input KnowledgebaseCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `revision` field."""
  revision: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `resolution` field."""
  resolution: String
  """Checks for equality with the objects `author` field."""
  author: String
  """Checks for equality with the objects `approver` field."""
  approver: String
  """Checks for equality with the objects `dateModified` field."""
  dateModified: Datetime
}

"""A connection to a list of `Lead` values."""
type LeadsConnection {
  """A list of `Lead` objects."""
  nodes: [Lead]!
  """A list of edges which contains the `Lead` and cursor to aid in pagination."""
  edges: [LeadsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Lead` you could get from the connection."""
  totalCount: Int!
}

type Lead implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  prefix: String
  firstName: String
  lastName: String
  department: String
  accountName: String
  address: String
  postalcode: String
  city: String
  state: String
  country: String
  email: String
  description: String
  fax: String
  website: String
  mobile: String
  jobTitle: String
  altAddress: String
  altPostalcode: String
  altCity: String
  altState: String
  altCountry: String
  officePhone: String
  status: String
  statusDescription: String
  opportunityAmount: String
  campaign: String
  leadSource: String
  leadSourceDescription: String
  referredBy: String
  customerName: String
}

"""A `Lead` edge in the connection."""
type LeadsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Lead` at the end of the edge."""
  node: Lead
}

"""Methods to use when ordering `Lead`."""
enum LeadsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PREFIX_ASC
  PREFIX_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  DEPARTMENT_ASC
  DEPARTMENT_DESC
  ACCOUNT_NAME_ASC
  ACCOUNT_NAME_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  POSTALCODE_ASC
  POSTALCODE_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  EMAIL_ASC
  EMAIL_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  FAX_ASC
  FAX_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  MOBILE_ASC
  MOBILE_DESC
  JOB_TITLE_ASC
  JOB_TITLE_DESC
  ALT_ADDRESS_ASC
  ALT_ADDRESS_DESC
  ALT_POSTALCODE_ASC
  ALT_POSTALCODE_DESC
  ALT_CITY_ASC
  ALT_CITY_DESC
  ALT_STATE_ASC
  ALT_STATE_DESC
  ALT_COUNTRY_ASC
  ALT_COUNTRY_DESC
  OFFICE_PHONE_ASC
  OFFICE_PHONE_DESC
  STATUS_ASC
  STATUS_DESC
  STATUS_DESCRIPTION_ASC
  STATUS_DESCRIPTION_DESC
  OPPORTUNITY_AMOUNT_ASC
  OPPORTUNITY_AMOUNT_DESC
  CAMPAIGN_ASC
  CAMPAIGN_DESC
  LEAD_SOURCE_ASC
  LEAD_SOURCE_DESC
  LEAD_SOURCE_DESCRIPTION_ASC
  LEAD_SOURCE_DESCRIPTION_DESC
  REFERRED_BY_ASC
  REFERRED_BY_DESC
  CUSTOMER_NAME_ASC
  CUSTOMER_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Lead` object types. All fields are tested for equality and combined with a logical and."""
input LeadCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `prefix` field."""
  prefix: String
  """Checks for equality with the objects `firstName` field."""
  firstName: String
  """Checks for equality with the objects `lastName` field."""
  lastName: String
  """Checks for equality with the objects `department` field."""
  department: String
  """Checks for equality with the objects `accountName` field."""
  accountName: String
  """Checks for equality with the objects `address` field."""
  address: String
  """Checks for equality with the objects `postalcode` field."""
  postalcode: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `fax` field."""
  fax: String
  """Checks for equality with the objects `website` field."""
  website: String
  """Checks for equality with the objects `mobile` field."""
  mobile: String
  """Checks for equality with the objects `jobTitle` field."""
  jobTitle: String
  """Checks for equality with the objects `altAddress` field."""
  altAddress: String
  """Checks for equality with the objects `altPostalcode` field."""
  altPostalcode: String
  """Checks for equality with the objects `altCity` field."""
  altCity: String
  """Checks for equality with the objects `altState` field."""
  altState: String
  """Checks for equality with the objects `altCountry` field."""
  altCountry: String
  """Checks for equality with the objects `officePhone` field."""
  officePhone: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `statusDescription` field."""
  statusDescription: String
  """Checks for equality with the objects `opportunityAmount` field."""
  opportunityAmount: String
  """Checks for equality with the objects `campaign` field."""
  campaign: String
  """Checks for equality with the objects `leadSource` field."""
  leadSource: String
  """Checks for equality with the objects `leadSourceDescription` field."""
  leadSourceDescription: String
  """Checks for equality with the objects `referredBy` field."""
  referredBy: String
  """Checks for equality with the objects `customerName` field."""
  customerName: String
}

"""A connection to a list of `Meeting` values."""
type MeetingsConnection {
  """A list of `Meeting` objects."""
  nodes: [Meeting]!
  """A list of edges which contains the `Meeting` and cursor to aid in pagination."""
  edges: [MeetingsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Meeting` you could get from the connection."""
  totalCount: Int!
}

type Meeting implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  subject: String
  startDate: String
  endDate: String
  duration: String
  status: String
  relatedTo: String
  reminders: String
  content: String
  assignedTo: String
  invitees: String
  scheduling: String
}

"""A `Meeting` edge in the connection."""
type MeetingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Meeting` at the end of the edge."""
  node: Meeting
}

"""Methods to use when ordering `Meeting`."""
enum MeetingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  SUBJECT_ASC
  SUBJECT_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  DURATION_ASC
  DURATION_DESC
  STATUS_ASC
  STATUS_DESC
  RELATED_TO_ASC
  RELATED_TO_DESC
  REMINDERS_ASC
  REMINDERS_DESC
  CONTENT_ASC
  CONTENT_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  INVITEES_ASC
  INVITEES_DESC
  SCHEDULING_ASC
  SCHEDULING_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Meeting` object types. All fields are tested for equality and combined with a logical and."""
input MeetingCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `subject` field."""
  subject: String
  """Checks for equality with the objects `startDate` field."""
  startDate: String
  """Checks for equality with the objects `endDate` field."""
  endDate: String
  """Checks for equality with the objects `duration` field."""
  duration: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `relatedTo` field."""
  relatedTo: String
  """Checks for equality with the objects `reminders` field."""
  reminders: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `invitees` field."""
  invitees: String
  """Checks for equality with the objects `scheduling` field."""
  scheduling: String
}

"""A connection to a list of `Ooto` values."""
type OotosConnection {
  """A list of `Ooto` objects."""
  nodes: [Ooto]!
  """A list of edges which contains the `Ooto` and cursor to aid in pagination."""
  edges: [OotosEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Ooto` you could get from the connection."""
  totalCount: Int!
}

type Ooto implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  login: String
  startDate: String
  endDate: String
  note: String
  usingTime: String
  location: String
}

"""A `Ooto` edge in the connection."""
type OotosEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Ooto` at the end of the edge."""
  node: Ooto
}

"""Methods to use when ordering `Ooto`."""
enum OotosOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  LOGIN_ASC
  LOGIN_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  NOTE_ASC
  NOTE_DESC
  USING_TIME_ASC
  USING_TIME_DESC
  LOCATION_ASC
  LOCATION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Ooto` object types. All fields are tested for equality and combined with a logical and."""
input OotoCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `login` field."""
  login: String
  """Checks for equality with the objects `startDate` field."""
  startDate: String
  """Checks for equality with the objects `endDate` field."""
  endDate: String
  """Checks for equality with the objects `note` field."""
  note: String
  """Checks for equality with the objects `usingTime` field."""
  usingTime: String
  """Checks for equality with the objects `location` field."""
  location: String
}

"""A connection to a list of `Opportunity` values."""
type OpportunitiesConnection {
  """A list of `Opportunity` objects."""
  nodes: [Opportunity]!
  """A list of edges which contains the `Opportunity` and cursor to aid in pagination."""
  edges: [OpportunitiesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Opportunity` you could get from the connection."""
  totalCount: Int!
}

type Opportunity implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  amount: String
  salesStage: String
  currency: String
  probability: String
  nextStep: String
  description: String
  assignedTo: String
  leadSource: String
  campaign: String
  type: String
  accountName: String
  expectedCloseDate: String
}

"""A `Opportunity` edge in the connection."""
type OpportunitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Opportunity` at the end of the edge."""
  node: Opportunity
}

"""Methods to use when ordering `Opportunity`."""
enum OpportunitiesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  AMOUNT_ASC
  AMOUNT_DESC
  SALES_STAGE_ASC
  SALES_STAGE_DESC
  CURRENCY_ASC
  CURRENCY_DESC
  PROBABILITY_ASC
  PROBABILITY_DESC
  NEXT_STEP_ASC
  NEXT_STEP_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  LEAD_SOURCE_ASC
  LEAD_SOURCE_DESC
  CAMPAIGN_ASC
  CAMPAIGN_DESC
  TYPE_ASC
  TYPE_DESC
  ACCOUNT_NAME_ASC
  ACCOUNT_NAME_DESC
  EXPECTED_CLOSE_DATE_ASC
  EXPECTED_CLOSE_DATE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Opportunity` object types. All fields are tested
for equality and combined with a logical and.
"""
input OpportunityCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `amount` field."""
  amount: String
  """Checks for equality with the objects `salesStage` field."""
  salesStage: String
  """Checks for equality with the objects `currency` field."""
  currency: String
  """Checks for equality with the objects `probability` field."""
  probability: String
  """Checks for equality with the objects `nextStep` field."""
  nextStep: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `leadSource` field."""
  leadSource: String
  """Checks for equality with the objects `campaign` field."""
  campaign: String
  """Checks for equality with the objects `type` field."""
  type: String
  """Checks for equality with the objects `accountName` field."""
  accountName: String
  """Checks for equality with the objects `expectedCloseDate` field."""
  expectedCloseDate: String
}

"""A connection to a list of `Page` values."""
type PagesConnection {
  """A list of `Page` objects."""
  nodes: [Page]!
  """A list of edges which contains the `Page` and cursor to aid in pagination."""
  edges: [PagesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Page` you could get from the connection."""
  totalCount: Int!
}

type Page implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  enablePage: Boolean
  title: String!
  contentTitle: String
  content: String
  urlKey: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  createdAt: Datetime
}

"""A `Page` edge in the connection."""
type PagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Page` at the end of the edge."""
  node: Page
}

"""Methods to use when ordering `Page`."""
enum PagesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ENABLE_PAGE_ASC
  ENABLE_PAGE_DESC
  TITLE_ASC
  TITLE_DESC
  CONTENT_TITLE_ASC
  CONTENT_TITLE_DESC
  CONTENT_ASC
  CONTENT_DESC
  URL_KEY_ASC
  URL_KEY_DESC
  META_TITLE_ASC
  META_TITLE_DESC
  META_KEYWORDS_ASC
  META_KEYWORDS_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical and."""
input PageCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `enablePage` field."""
  enablePage: Boolean
  """Checks for equality with the objects `title` field."""
  title: String
  """Checks for equality with the objects `contentTitle` field."""
  contentTitle: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `urlKey` field."""
  urlKey: String
  """Checks for equality with the objects `metaTitle` field."""
  metaTitle: String
  """Checks for equality with the objects `metaKeywords` field."""
  metaKeywords: String
  """Checks for equality with the objects `metaDescription` field."""
  metaDescription: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
}

"""A connection to a list of `Partner` values."""
type PartnersConnection {
  """A list of `Partner` objects."""
  nodes: [Partner]!
  """A list of edges which contains the `Partner` and cursor to aid in pagination."""
  edges: [PartnersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Partner` you could get from the connection."""
  totalCount: Int!
}

type Partner implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  address: String
  city: String
  state: String
  country: String
  isPublic: String
  businessType: String
}

"""A `Partner` edge in the connection."""
type PartnersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Partner` at the end of the edge."""
  node: Partner
}

"""Methods to use when ordering `Partner`."""
enum PartnersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  BUSINESS_TYPE_ASC
  BUSINESS_TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Partner` object types. All fields are tested for equality and combined with a logical and."""
input PartnerCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `address` field."""
  address: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `isPublic` field."""
  isPublic: String
  """Checks for equality with the objects `businessType` field."""
  businessType: String
}

"""A connection to a list of `Payment` values."""
type PaymentsConnection {
  """A list of `Payment` objects."""
  nodes: [Payment]!
  """A list of edges which contains the `Payment` and cursor to aid in pagination."""
  edges: [PaymentsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Payment` you could get from the connection."""
  totalCount: Int!
}

type Payment implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String!
  active: String
  country: String
}

"""A `Payment` edge in the connection."""
type PaymentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Payment` at the end of the edge."""
  node: Payment
}

"""Methods to use when ordering `Payment`."""
enum PaymentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  HOST_URI_ASC
  HOST_URI_DESC
  REDIRECT_URL_ASC
  REDIRECT_URL_DESC
  REDIRECT_URL_APP_ASC
  REDIRECT_URL_APP_DESC
  ICON_ASC
  ICON_DESC
  NAME_ASC
  NAME_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Payment` object types. All fields are tested for equality and combined with a logical and."""
input PaymentCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `clientId` field."""
  clientId: String
  """Checks for equality with the objects `clientSecret` field."""
  clientSecret: String
  """Checks for equality with the objects `hostUri` field."""
  hostUri: String
  """Checks for equality with the objects `redirectUrl` field."""
  redirectUrl: String
  """Checks for equality with the objects `redirectUrlApp` field."""
  redirectUrlApp: String
  """Checks for equality with the objects `icon` field."""
  icon: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `active` field."""
  active: String
  """Checks for equality with the objects `country` field."""
  country: String
}

"""A connection to a list of `PdfTemplate` values."""
type PdfTemplatesConnection {
  """A list of `PdfTemplate` objects."""
  nodes: [PdfTemplate]!
  """A list of edges which contains the `PdfTemplate` and cursor to aid in pagination."""
  edges: [PdfTemplatesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `PdfTemplate` you could get from the connection."""
  totalCount: Int!
}

type PdfTemplate implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  assignedTo: String
  type: String
  active: String
  pageSize: String
  orientation: String
  content: String
  header: String
  footer: String
  marginLeft: String
  marginRight: String
  marginTop: String
  marginBottom: String
  marginHeader: String
  marginFooter: String
}

"""A `PdfTemplate` edge in the connection."""
type PdfTemplatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `PdfTemplate` at the end of the edge."""
  node: PdfTemplate
}

"""Methods to use when ordering `PdfTemplate`."""
enum PdfTemplatesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  TYPE_ASC
  TYPE_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  PAGE_SIZE_ASC
  PAGE_SIZE_DESC
  ORIENTATION_ASC
  ORIENTATION_DESC
  CONTENT_ASC
  CONTENT_DESC
  HEADER_ASC
  HEADER_DESC
  FOOTER_ASC
  FOOTER_DESC
  MARGIN_LEFT_ASC
  MARGIN_LEFT_DESC
  MARGIN_RIGHT_ASC
  MARGIN_RIGHT_DESC
  MARGIN_TOP_ASC
  MARGIN_TOP_DESC
  MARGIN_BOTTOM_ASC
  MARGIN_BOTTOM_DESC
  MARGIN_HEADER_ASC
  MARGIN_HEADER_DESC
  MARGIN_FOOTER_ASC
  MARGIN_FOOTER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `PdfTemplate` object types. All fields are tested
for equality and combined with a logical and.
"""
input PdfTemplateCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `type` field."""
  type: String
  """Checks for equality with the objects `active` field."""
  active: String
  """Checks for equality with the objects `pageSize` field."""
  pageSize: String
  """Checks for equality with the objects `orientation` field."""
  orientation: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `header` field."""
  header: String
  """Checks for equality with the objects `footer` field."""
  footer: String
  """Checks for equality with the objects `marginLeft` field."""
  marginLeft: String
  """Checks for equality with the objects `marginRight` field."""
  marginRight: String
  """Checks for equality with the objects `marginTop` field."""
  marginTop: String
  """Checks for equality with the objects `marginBottom` field."""
  marginBottom: String
  """Checks for equality with the objects `marginHeader` field."""
  marginHeader: String
  """Checks for equality with the objects `marginFooter` field."""
  marginFooter: String
}

"""A connection to a list of `Permission` values."""
type PermissionsConnection {
  """A list of `Permission` objects."""
  nodes: [Permission]!
  """A list of edges which contains the `Permission` and cursor to aid in pagination."""
  edges: [PermissionsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Permission` you could get from the connection."""
  totalCount: Int!
}

type Permission implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  content: String
  role: String
  create: String
  read: String
  update: String
  delete: String
  users: String
}

"""A `Permission` edge in the connection."""
type PermissionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Permission` at the end of the edge."""
  node: Permission
}

"""Methods to use when ordering `Permission`."""
enum PermissionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  ROLE_ASC
  ROLE_DESC
  CREATE_ASC
  CREATE_DESC
  READ_ASC
  READ_DESC
  UPDATE_ASC
  UPDATE_DESC
  DELETE_ASC
  DELETE_DESC
  USERS_ASC
  USERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Permission` object types. All fields are tested
for equality and combined with a logical and.
"""
input PermissionCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `role` field."""
  role: String
  """Checks for equality with the objects `create` field."""
  create: String
  """Checks for equality with the objects `read` field."""
  read: String
  """Checks for equality with the objects `update` field."""
  update: String
  """Checks for equality with the objects `delete` field."""
  delete: String
  """Checks for equality with the objects `users` field."""
  users: String
}

"""A connection to a list of `Plugin` values."""
type PluginsConnection {
  """A list of `Plugin` objects."""
  nodes: [Plugin]!
  """A list of edges which contains the `Plugin` and cursor to aid in pagination."""
  edges: [PluginsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Plugin` you could get from the connection."""
  totalCount: Int!
}

type Plugin implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  url: String
  githubLink: String
  description: String
  logo: String
  screenshots: String
  lastUpdated: Datetime
  publisherName: String
  agreeTerms: Boolean
  publisherEmail: String
}

"""A `Plugin` edge in the connection."""
type PluginsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Plugin` at the end of the edge."""
  node: Plugin
}

"""Methods to use when ordering `Plugin`."""
enum PluginsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  URL_ASC
  URL_DESC
  GITHUB_LINK_ASC
  GITHUB_LINK_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  LOGO_ASC
  LOGO_DESC
  SCREENSHOTS_ASC
  SCREENSHOTS_DESC
  LAST_UPDATED_ASC
  LAST_UPDATED_DESC
  PUBLISHER_NAME_ASC
  PUBLISHER_NAME_DESC
  AGREE_TERMS_ASC
  AGREE_TERMS_DESC
  PUBLISHER_EMAIL_ASC
  PUBLISHER_EMAIL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Plugin` object types. All fields are tested for equality and combined with a logical and."""
input PluginCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `url` field."""
  url: String
  """Checks for equality with the objects `githubLink` field."""
  githubLink: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `logo` field."""
  logo: String
  """Checks for equality with the objects `screenshots` field."""
  screenshots: String
  """Checks for equality with the objects `lastUpdated` field."""
  lastUpdated: Datetime
  """Checks for equality with the objects `publisherName` field."""
  publisherName: String
  """Checks for equality with the objects `agreeTerms` field."""
  agreeTerms: Boolean
  """Checks for equality with the objects `publisherEmail` field."""
  publisherEmail: String
}

"""A connection to a list of `ProjectTemplate` values."""
type ProjectTemplatesConnection {
  """A list of `ProjectTemplate` objects."""
  nodes: [ProjectTemplate]!
  """A list of edges which contains the `ProjectTemplate` and cursor to aid in pagination."""
  edges: [ProjectTemplatesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `ProjectTemplate` you could get from the connection."""
  totalCount: Int!
}

type ProjectTemplate implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String
  status: String
  considerWorkingDays: String
  priority: String
  projectManager: String
  resource: String
  content: String
}

"""A `ProjectTemplate` edge in the connection."""
type ProjectTemplatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `ProjectTemplate` at the end of the edge."""
  node: ProjectTemplate
}

"""Methods to use when ordering `ProjectTemplate`."""
enum ProjectTemplatesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  STATUS_ASC
  STATUS_DESC
  CONSIDER_WORKING_DAYS_ASC
  CONSIDER_WORKING_DAYS_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  PROJECT_MANAGER_ASC
  PROJECT_MANAGER_DESC
  RESOURCE_ASC
  RESOURCE_DESC
  CONTENT_ASC
  CONTENT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ProjectTemplate` object types. All fields are
tested for equality and combined with a logical and.
"""
input ProjectTemplateCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `considerWorkingDays` field."""
  considerWorkingDays: String
  """Checks for equality with the objects `priority` field."""
  priority: String
  """Checks for equality with the objects `projectManager` field."""
  projectManager: String
  """Checks for equality with the objects `resource` field."""
  resource: String
  """Checks for equality with the objects `content` field."""
  content: String
}

"""A connection to a list of `Provider` values."""
type ProvidersConnection {
  """A list of `Provider` objects."""
  nodes: [Provider]!
  """A list of edges which contains the `Provider` and cursor to aid in pagination."""
  edges: [ProvidersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Provider` you could get from the connection."""
  totalCount: Int!
}

type Provider implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String!
  active: String
}

"""A `Provider` edge in the connection."""
type ProvidersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Provider` at the end of the edge."""
  node: Provider
}

"""Methods to use when ordering `Provider`."""
enum ProvidersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  HOST_URI_ASC
  HOST_URI_DESC
  REDIRECT_URL_ASC
  REDIRECT_URL_DESC
  REDIRECT_URL_APP_ASC
  REDIRECT_URL_APP_DESC
  ICON_ASC
  ICON_DESC
  NAME_ASC
  NAME_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Provider` object types. All fields are tested
for equality and combined with a logical and.
"""
input ProviderCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `clientId` field."""
  clientId: String
  """Checks for equality with the objects `clientSecret` field."""
  clientSecret: String
  """Checks for equality with the objects `hostUri` field."""
  hostUri: String
  """Checks for equality with the objects `redirectUrl` field."""
  redirectUrl: String
  """Checks for equality with the objects `redirectUrlApp` field."""
  redirectUrlApp: String
  """Checks for equality with the objects `icon` field."""
  icon: String
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `active` field."""
  active: String
}

"""A connection to a list of `Report` values."""
type ReportsConnection {
  """A list of `Report` objects."""
  nodes: [Report]!
  """A list of edges which contains the `Report` and cursor to aid in pagination."""
  edges: [ReportsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Report` you could get from the connection."""
  totalCount: Int!
}

type Report implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  customer: String
  email: String
  products: String
  quantity: BigFloat
  subtotal: String
  appliedCoupon: String
  created: Datetime
  updated: Datetime
  ipAddress: String
}

"""A `Report` edge in the connection."""
type ReportsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Report` at the end of the edge."""
  node: Report
}

"""Methods to use when ordering `Report`."""
enum ReportsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CUSTOMER_ASC
  CUSTOMER_DESC
  EMAIL_ASC
  EMAIL_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  QUANTITY_ASC
  QUANTITY_DESC
  SUBTOTAL_ASC
  SUBTOTAL_DESC
  APPLIED_COUPON_ASC
  APPLIED_COUPON_DESC
  CREATED_ASC
  CREATED_DESC
  UPDATED_ASC
  UPDATED_DESC
  IP_ADDRESS_ASC
  IP_ADDRESS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Report` object types. All fields are tested for equality and combined with a logical and."""
input ReportCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `customer` field."""
  customer: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `quantity` field."""
  quantity: BigFloat
  """Checks for equality with the objects `subtotal` field."""
  subtotal: String
  """Checks for equality with the objects `appliedCoupon` field."""
  appliedCoupon: String
  """Checks for equality with the objects `created` field."""
  created: Datetime
  """Checks for equality with the objects `updated` field."""
  updated: Datetime
  """Checks for equality with the objects `ipAddress` field."""
  ipAddress: String
}

"""A connection to a list of `Review` values."""
type ReviewsConnection {
  """A list of `Review` objects."""
  nodes: [Review]!
  """A list of edges which contains the `Review` and cursor to aid in pagination."""
  edges: [ReviewsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Review` you could get from the connection."""
  totalCount: Int!
}

type Review implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  firstName: String
  lastName: String
  content: String
  websites: String
  createdAt: Datetime
  shopId: Int!
  commentId: Int!
}

"""A `Review` edge in the connection."""
type ReviewsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Review` at the end of the edge."""
  node: Review
}

"""Methods to use when ordering `Review`."""
enum ReviewsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  SHOP_ID_ASC
  SHOP_ID_DESC
  COMMENT_ID_ASC
  COMMENT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Review` object types. All fields are tested for equality and combined with a logical and."""
input ReviewCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `firstName` field."""
  firstName: String
  """Checks for equality with the objects `lastName` field."""
  lastName: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `websites` field."""
  websites: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `shopId` field."""
  shopId: Int
  """Checks for equality with the objects `commentId` field."""
  commentId: Int
}

"""A connection to a list of `Reward` values."""
type RewardsConnection {
  """A list of `Reward` objects."""
  nodes: [Reward]!
  """A list of edges which contains the `Reward` and cursor to aid in pagination."""
  edges: [RewardsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Reward` you could get from the connection."""
  totalCount: Int!
}

type Reward implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  slug: String
  level: String
  createdAt: Datetime
  coupons: String
  expiration: Date
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""A `Reward` edge in the connection."""
type RewardsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Reward` at the end of the edge."""
  node: Reward
}

"""Methods to use when ordering `Reward`."""
enum RewardsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  SLUG_ASC
  SLUG_DESC
  LEVEL_ASC
  LEVEL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  COUPONS_ASC
  COUPONS_DESC
  EXPIRATION_ASC
  EXPIRATION_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Reward` object types. All fields are tested for equality and combined with a logical and."""
input RewardCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `slug` field."""
  slug: String
  """Checks for equality with the objects `level` field."""
  level: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `coupons` field."""
  coupons: String
  """Checks for equality with the objects `expiration` field."""
  expiration: Date
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `articles` field."""
  articles: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `users` field."""
  users: String
}

"""A connection to a list of `Scheduler` values."""
type SchedulersConnection {
  """A list of `Scheduler` objects."""
  nodes: [Scheduler]!
  """A list of edges which contains the `Scheduler` and cursor to aid in pagination."""
  edges: [SchedulersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Scheduler` you could get from the connection."""
  totalCount: Int!
}

type Scheduler implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  endDate: String
  level: String
  login: String
  notes: String
  startDate: String
  whid: String
}

"""A `Scheduler` edge in the connection."""
type SchedulersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Scheduler` at the end of the edge."""
  node: Scheduler
}

"""Methods to use when ordering `Scheduler`."""
enum SchedulersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  END_DATE_ASC
  END_DATE_DESC
  LEVEL_ASC
  LEVEL_DESC
  LOGIN_ASC
  LOGIN_DESC
  NOTES_ASC
  NOTES_DESC
  START_DATE_ASC
  START_DATE_DESC
  WHID_ASC
  WHID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Scheduler` object types. All fields are tested
for equality and combined with a logical and.
"""
input SchedulerCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `endDate` field."""
  endDate: String
  """Checks for equality with the objects `level` field."""
  level: String
  """Checks for equality with the objects `login` field."""
  login: String
  """Checks for equality with the objects `notes` field."""
  notes: String
  """Checks for equality with the objects `startDate` field."""
  startDate: String
  """Checks for equality with the objects `whid` field."""
  whid: String
}

"""A connection to a list of `Segment` values."""
type SegmentsConnection {
  """A list of `Segment` objects."""
  nodes: [Segment]!
  """A list of edges which contains the `Segment` and cursor to aid in pagination."""
  edges: [SegmentsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Segment` you could get from the connection."""
  totalCount: Int!
}

type Segment implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  description: String
  website: String
  status: String
  applyTo: String
  customers: String
}

"""A `Segment` edge in the connection."""
type SegmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Segment` at the end of the edge."""
  node: Segment
}

"""Methods to use when ordering `Segment`."""
enum SegmentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  STATUS_ASC
  STATUS_DESC
  APPLY_TO_ASC
  APPLY_TO_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Segment` object types. All fields are tested for equality and combined with a logical and."""
input SegmentCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `website` field."""
  website: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `applyTo` field."""
  applyTo: String
  """Checks for equality with the objects `customers` field."""
  customers: String
}

"""A connection to a list of `Settingscustomer` values."""
type SettingscustomersConnection {
  """A list of `Settingscustomer` objects."""
  nodes: [Settingscustomer]!
  """A list of edges which contains the `Settingscustomer` and cursor to aid in pagination."""
  edges: [SettingscustomersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Settingscustomer` you could get from the connection."""
  totalCount: Int!
}

type Settingscustomer implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  loginAsCustomer: String
  shareCustomerAccounts: String
  onlineMinutesInterval: String
  customerDataLifetime: String
  emailAfterRegistration: String
}

"""A `Settingscustomer` edge in the connection."""
type SettingscustomersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Settingscustomer` at the end of the edge."""
  node: Settingscustomer
}

"""Methods to use when ordering `Settingscustomer`."""
enum SettingscustomersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  LOGIN_AS_CUSTOMER_ASC
  LOGIN_AS_CUSTOMER_DESC
  SHARE_CUSTOMER_ACCOUNTS_ASC
  SHARE_CUSTOMER_ACCOUNTS_DESC
  ONLINE_MINUTES_INTERVAL_ASC
  ONLINE_MINUTES_INTERVAL_DESC
  CUSTOMER_DATA_LIFETIME_ASC
  CUSTOMER_DATA_LIFETIME_DESC
  EMAIL_AFTER_REGISTRATION_ASC
  EMAIL_AFTER_REGISTRATION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Settingscustomer` object types. All fields are
tested for equality and combined with a logical and.
"""
input SettingscustomerCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `loginAsCustomer` field."""
  loginAsCustomer: String
  """Checks for equality with the objects `shareCustomerAccounts` field."""
  shareCustomerAccounts: String
  """Checks for equality with the objects `onlineMinutesInterval` field."""
  onlineMinutesInterval: String
  """Checks for equality with the objects `customerDataLifetime` field."""
  customerDataLifetime: String
  """Checks for equality with the objects `emailAfterRegistration` field."""
  emailAfterRegistration: String
}

"""A connection to a list of `Settingsgeneral` values."""
type SettingsgeneralsConnection {
  """A list of `Settingsgeneral` objects."""
  nodes: [Settingsgeneral]!
  """A list of edges which contains the `Settingsgeneral` and cursor to aid in pagination."""
  edges: [SettingsgeneralsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Settingsgeneral` you could get from the connection."""
  totalCount: Int!
}

type Settingsgeneral implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  siteTitle: String
  siteTagline: String
  siteWebsite: String
  email: String
  awsS3: String
  googleDrive: String
}

"""A `Settingsgeneral` edge in the connection."""
type SettingsgeneralsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Settingsgeneral` at the end of the edge."""
  node: Settingsgeneral
}

"""Methods to use when ordering `Settingsgeneral`."""
enum SettingsgeneralsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  SITE_TITLE_ASC
  SITE_TITLE_DESC
  SITE_TAGLINE_ASC
  SITE_TAGLINE_DESC
  SITE_WEBSITE_ASC
  SITE_WEBSITE_DESC
  EMAIL_ASC
  EMAIL_DESC
  AWS_S3_ASC
  AWS_S3_DESC
  GOOGLE_DRIVE_ASC
  GOOGLE_DRIVE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Settingsgeneral` object types. All fields are
tested for equality and combined with a logical and.
"""
input SettingsgeneralCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `siteTitle` field."""
  siteTitle: String
  """Checks for equality with the objects `siteTagline` field."""
  siteTagline: String
  """Checks for equality with the objects `siteWebsite` field."""
  siteWebsite: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `awsS3` field."""
  awsS3: String
  """Checks for equality with the objects `googleDrive` field."""
  googleDrive: String
}

"""A connection to a list of `Settingshop` values."""
type SettingshopsConnection {
  """A list of `Settingshop` objects."""
  nodes: [Settingshop]!
  """A list of edges which contains the `Settingshop` and cursor to aid in pagination."""
  edges: [SettingshopsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Settingshop` you could get from the connection."""
  totalCount: Int!
}

type Settingshop implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  enableProductAssignment: String
  productVideos: String
  sellerPayouts: String
  adminApproval: String
  enableReviewSystem: String
  customerRateVendor: String
  multishipping: String
  vendorTransactionId: String
  enableVendorProductAttribute: String
}

"""A `Settingshop` edge in the connection."""
type SettingshopsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Settingshop` at the end of the edge."""
  node: Settingshop
}

"""Methods to use when ordering `Settingshop`."""
enum SettingshopsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ENABLE_PRODUCT_ASSIGNMENT_ASC
  ENABLE_PRODUCT_ASSIGNMENT_DESC
  PRODUCT_VIDEOS_ASC
  PRODUCT_VIDEOS_DESC
  SELLER_PAYOUTS_ASC
  SELLER_PAYOUTS_DESC
  ADMIN_APPROVAL_ASC
  ADMIN_APPROVAL_DESC
  ENABLE_REVIEW_SYSTEM_ASC
  ENABLE_REVIEW_SYSTEM_DESC
  CUSTOMER_RATE_VENDOR_ASC
  CUSTOMER_RATE_VENDOR_DESC
  MULTISHIPPING_ASC
  MULTISHIPPING_DESC
  VENDOR_TRANSACTION_ID_ASC
  VENDOR_TRANSACTION_ID_DESC
  ENABLE_VENDOR_PRODUCT_ATTRIBUTE_ASC
  ENABLE_VENDOR_PRODUCT_ATTRIBUTE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Settingshop` object types. All fields are tested
for equality and combined with a logical and.
"""
input SettingshopCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `enableProductAssignment` field."""
  enableProductAssignment: String
  """Checks for equality with the objects `productVideos` field."""
  productVideos: String
  """Checks for equality with the objects `sellerPayouts` field."""
  sellerPayouts: String
  """Checks for equality with the objects `adminApproval` field."""
  adminApproval: String
  """Checks for equality with the objects `enableReviewSystem` field."""
  enableReviewSystem: String
  """Checks for equality with the objects `customerRateVendor` field."""
  customerRateVendor: String
  """Checks for equality with the objects `multishipping` field."""
  multishipping: String
  """Checks for equality with the objects `vendorTransactionId` field."""
  vendorTransactionId: String
  """Checks for equality with the objects `enableVendorProductAttribute` field."""
  enableVendorProductAttribute: String
}

"""A connection to a list of `Settingsmarketing` values."""
type SettingsmarketingsConnection {
  """A list of `Settingsmarketing` objects."""
  nodes: [Settingsmarketing]!
  """A list of edges which contains the `Settingsmarketing` and cursor to aid in pagination."""
  edges: [SettingsmarketingsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Settingsmarketing` you could get from the connection."""
  totalCount: Int!
}

type Settingsmarketing implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  mailPort: String
  recaptchaApi: String
  adsenseApi: String
  sitemapUrl: String
  customerDataLifetime: String
  mailServer: String
}

"""A `Settingsmarketing` edge in the connection."""
type SettingsmarketingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Settingsmarketing` at the end of the edge."""
  node: Settingsmarketing
}

"""Methods to use when ordering `Settingsmarketing`."""
enum SettingsmarketingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MAIL_PORT_ASC
  MAIL_PORT_DESC
  RECAPTCHA_API_ASC
  RECAPTCHA_API_DESC
  ADSENSE_API_ASC
  ADSENSE_API_DESC
  SITEMAP_URL_ASC
  SITEMAP_URL_DESC
  CUSTOMER_DATA_LIFETIME_ASC
  CUSTOMER_DATA_LIFETIME_DESC
  MAIL_SERVER_ASC
  MAIL_SERVER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Settingsmarketing` object types. All fields are
tested for equality and combined with a logical and.
"""
input SettingsmarketingCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `mailPort` field."""
  mailPort: String
  """Checks for equality with the objects `recaptchaApi` field."""
  recaptchaApi: String
  """Checks for equality with the objects `adsenseApi` field."""
  adsenseApi: String
  """Checks for equality with the objects `sitemapUrl` field."""
  sitemapUrl: String
  """Checks for equality with the objects `customerDataLifetime` field."""
  customerDataLifetime: String
  """Checks for equality with the objects `mailServer` field."""
  mailServer: String
}

"""A connection to a list of `Settingssale` values."""
type SettingssalesConnection {
  """A list of `Settingssale` objects."""
  nodes: [Settingssale]!
  """A list of edges which contains the `Settingssale` and cursor to aid in pagination."""
  edges: [SettingssalesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Settingssale` you could get from the connection."""
  totalCount: Int!
}

type Settingssale implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  analyticsAccountType: String
  analyticsAccountNumber: String
  analyticsAnonymizeip: String
  analyticsContentExperiments: String
  adwordsConversionid: String
  adwordsConversionlanguage: String
  adwordsConversionformat: String
  adwordsConversioncolor: String
  adwordsConversionlabel: String
  adwordsConversionvalueType: String
  adwordsSendorder: String
  tagManagerAnonymizeip: String
  tagManagerContentexperiments: String
  tagManagerContainerid: String
}

"""A `Settingssale` edge in the connection."""
type SettingssalesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Settingssale` at the end of the edge."""
  node: Settingssale
}

"""Methods to use when ordering `Settingssale`."""
enum SettingssalesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ANALYTICS_ACCOUNT_TYPE_ASC
  ANALYTICS_ACCOUNT_TYPE_DESC
  ANALYTICS_ACCOUNT_NUMBER_ASC
  ANALYTICS_ACCOUNT_NUMBER_DESC
  ANALYTICS_ANONYMIZEIP_ASC
  ANALYTICS_ANONYMIZEIP_DESC
  ANALYTICS_CONTENT_EXPERIMENTS_ASC
  ANALYTICS_CONTENT_EXPERIMENTS_DESC
  ADWORDS_CONVERSIONID_ASC
  ADWORDS_CONVERSIONID_DESC
  ADWORDS_CONVERSIONLANGUAGE_ASC
  ADWORDS_CONVERSIONLANGUAGE_DESC
  ADWORDS_CONVERSIONFORMAT_ASC
  ADWORDS_CONVERSIONFORMAT_DESC
  ADWORDS_CONVERSIONCOLOR_ASC
  ADWORDS_CONVERSIONCOLOR_DESC
  ADWORDS_CONVERSIONLABEL_ASC
  ADWORDS_CONVERSIONLABEL_DESC
  ADWORDS_CONVERSIONVALUE_TYPE_ASC
  ADWORDS_CONVERSIONVALUE_TYPE_DESC
  ADWORDS_SENDORDER_ASC
  ADWORDS_SENDORDER_DESC
  TAG_MANAGER_ANONYMIZEIP_ASC
  TAG_MANAGER_ANONYMIZEIP_DESC
  TAG_MANAGER_CONTENTEXPERIMENTS_ASC
  TAG_MANAGER_CONTENTEXPERIMENTS_DESC
  TAG_MANAGER_CONTAINERID_ASC
  TAG_MANAGER_CONTAINERID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Settingssale` object types. All fields are
tested for equality and combined with a logical and.
"""
input SettingssaleCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `analyticsAccountType` field."""
  analyticsAccountType: String
  """Checks for equality with the objects `analyticsAccountNumber` field."""
  analyticsAccountNumber: String
  """Checks for equality with the objects `analyticsAnonymizeip` field."""
  analyticsAnonymizeip: String
  """Checks for equality with the objects `analyticsContentExperiments` field."""
  analyticsContentExperiments: String
  """Checks for equality with the objects `adwordsConversionid` field."""
  adwordsConversionid: String
  """Checks for equality with the objects `adwordsConversionlanguage` field."""
  adwordsConversionlanguage: String
  """Checks for equality with the objects `adwordsConversionformat` field."""
  adwordsConversionformat: String
  """Checks for equality with the objects `adwordsConversioncolor` field."""
  adwordsConversioncolor: String
  """Checks for equality with the objects `adwordsConversionlabel` field."""
  adwordsConversionlabel: String
  """Checks for equality with the objects `adwordsConversionvalueType` field."""
  adwordsConversionvalueType: String
  """Checks for equality with the objects `adwordsSendorder` field."""
  adwordsSendorder: String
  """Checks for equality with the objects `tagManagerAnonymizeip` field."""
  tagManagerAnonymizeip: String
  """Checks for equality with the objects `tagManagerContentexperiments` field."""
  tagManagerContentexperiments: String
  """Checks for equality with the objects `tagManagerContainerid` field."""
  tagManagerContainerid: String
}

"""A connection to a list of `Shipment` values."""
type ShipmentsConnection {
  """A list of `Shipment` objects."""
  nodes: [Shipment]!
  """A list of edges which contains the `Shipment` and cursor to aid in pagination."""
  edges: [ShipmentsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Shipment` you could get from the connection."""
  totalCount: Int!
}

type Shipment implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  product: String
  speedGrade: String
  shipDate: Datetime
  carrierName: String!
  transitTime: String
  trackingUrl: String
  image: String
  id: BigInt!
  clientId: String
  clientSecret: String
  country: String
  website: String
}

"""A `Shipment` edge in the connection."""
type ShipmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Shipment` at the end of the edge."""
  node: Shipment
}

"""Methods to use when ordering `Shipment`."""
enum ShipmentsOrderBy {
  NATURAL
  PRODUCT_ASC
  PRODUCT_DESC
  SPEED_GRADE_ASC
  SPEED_GRADE_DESC
  SHIP_DATE_ASC
  SHIP_DATE_DESC
  CARRIER_NAME_ASC
  CARRIER_NAME_DESC
  TRANSIT_TIME_ASC
  TRANSIT_TIME_DESC
  TRACKING_URL_ASC
  TRACKING_URL_DESC
  IMAGE_ASC
  IMAGE_DESC
  ID_ASC
  ID_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Shipment` object types. All fields are tested
for equality and combined with a logical and.
"""
input ShipmentCondition {
  """Checks for equality with the objects `product` field."""
  product: String
  """Checks for equality with the objects `speedGrade` field."""
  speedGrade: String
  """Checks for equality with the objects `shipDate` field."""
  shipDate: Datetime
  """Checks for equality with the objects `carrierName` field."""
  carrierName: String
  """Checks for equality with the objects `transitTime` field."""
  transitTime: String
  """Checks for equality with the objects `trackingUrl` field."""
  trackingUrl: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `clientId` field."""
  clientId: String
  """Checks for equality with the objects `clientSecret` field."""
  clientSecret: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `website` field."""
  website: String
}

"""A connection to a list of `ShopSetting` values."""
type ShopSettingsConnection {
  """A list of `ShopSetting` objects."""
  nodes: [ShopSetting]!
  """A list of edges which contains the `ShopSetting` and cursor to aid in pagination."""
  edges: [ShopSettingsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `ShopSetting` you could get from the connection."""
  totalCount: Int!
}

type ShopSetting implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  storeName: String
  storePhone: String
  storeHours: String
  country: String
  region: String
  zipcode: String
  city: String
  address: String
  addressTwo: String
  vatNumber: String
  allowState: String
  stateRequiredFor: String
  allowCountries: String
  defaultCountry: String
  optionalZip: String
  europeanUnionCountries: String
  topDestinations: String
  baseCurrency: String
  defaultCurrency: String
  allowedCurrency: String
}

"""A `ShopSetting` edge in the connection."""
type ShopSettingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `ShopSetting` at the end of the edge."""
  node: ShopSetting
}

"""Methods to use when ordering `ShopSetting`."""
enum ShopSettingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  STORE_NAME_ASC
  STORE_NAME_DESC
  STORE_PHONE_ASC
  STORE_PHONE_DESC
  STORE_HOURS_ASC
  STORE_HOURS_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  REGION_ASC
  REGION_DESC
  ZIPCODE_ASC
  ZIPCODE_DESC
  CITY_ASC
  CITY_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ADDRESS_TWO_ASC
  ADDRESS_TWO_DESC
  VAT_NUMBER_ASC
  VAT_NUMBER_DESC
  ALLOW_STATE_ASC
  ALLOW_STATE_DESC
  STATE_REQUIRED_FOR_ASC
  STATE_REQUIRED_FOR_DESC
  ALLOW_COUNTRIES_ASC
  ALLOW_COUNTRIES_DESC
  DEFAULT_COUNTRY_ASC
  DEFAULT_COUNTRY_DESC
  OPTIONAL_ZIP_ASC
  OPTIONAL_ZIP_DESC
  EUROPEAN_UNION_COUNTRIES_ASC
  EUROPEAN_UNION_COUNTRIES_DESC
  TOP_DESTINATIONS_ASC
  TOP_DESTINATIONS_DESC
  BASE_CURRENCY_ASC
  BASE_CURRENCY_DESC
  DEFAULT_CURRENCY_ASC
  DEFAULT_CURRENCY_DESC
  ALLOWED_CURRENCY_ASC
  ALLOWED_CURRENCY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ShopSetting` object types. All fields are tested
for equality and combined with a logical and.
"""
input ShopSettingCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `storeName` field."""
  storeName: String
  """Checks for equality with the objects `storePhone` field."""
  storePhone: String
  """Checks for equality with the objects `storeHours` field."""
  storeHours: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `region` field."""
  region: String
  """Checks for equality with the objects `zipcode` field."""
  zipcode: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `address` field."""
  address: String
  """Checks for equality with the objects `addressTwo` field."""
  addressTwo: String
  """Checks for equality with the objects `vatNumber` field."""
  vatNumber: String
  """Checks for equality with the objects `allowState` field."""
  allowState: String
  """Checks for equality with the objects `stateRequiredFor` field."""
  stateRequiredFor: String
  """Checks for equality with the objects `allowCountries` field."""
  allowCountries: String
  """Checks for equality with the objects `defaultCountry` field."""
  defaultCountry: String
  """Checks for equality with the objects `optionalZip` field."""
  optionalZip: String
  """Checks for equality with the objects `europeanUnionCountries` field."""
  europeanUnionCountries: String
  """Checks for equality with the objects `topDestinations` field."""
  topDestinations: String
  """Checks for equality with the objects `baseCurrency` field."""
  baseCurrency: String
  """Checks for equality with the objects `defaultCurrency` field."""
  defaultCurrency: String
  """Checks for equality with the objects `allowedCurrency` field."""
  allowedCurrency: String
}

"""A connection to a list of `Shop` values."""
type ShopsConnection {
  """A list of `Shop` objects."""
  nodes: [Shop]!
  """A list of edges which contains the `Shop` and cursor to aid in pagination."""
  edges: [ShopsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Shop` you could get from the connection."""
  totalCount: Int!
}

"""A `Shop` edge in the connection."""
type ShopsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Shop` at the end of the edge."""
  node: Shop
}

"""A connection to a list of `SpecialDiscount` values."""
type SpecialDiscountsConnection {
  """A list of `SpecialDiscount` objects."""
  nodes: [SpecialDiscount]!
  """A list of edges which contains the `SpecialDiscount` and cursor to aid in pagination."""
  edges: [SpecialDiscountsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `SpecialDiscount` you could get from the connection."""
  totalCount: Int!
}

type SpecialDiscount implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  excerpt: String
  image: String
  published: Datetime
  rewards: String
  coupons: String
  expiration: Date
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  discount: String
}

"""A `SpecialDiscount` edge in the connection."""
type SpecialDiscountsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `SpecialDiscount` at the end of the edge."""
  node: SpecialDiscount
}

"""Methods to use when ordering `SpecialDiscount`."""
enum SpecialDiscountsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  IMAGE_ASC
  IMAGE_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  REWARDS_ASC
  REWARDS_DESC
  COUPONS_ASC
  COUPONS_DESC
  EXPIRATION_ASC
  EXPIRATION_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  DISCOUNT_ASC
  DISCOUNT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `SpecialDiscount` object types. All fields are
tested for equality and combined with a logical and.
"""
input SpecialDiscountCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `excerpt` field."""
  excerpt: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `published` field."""
  published: Datetime
  """Checks for equality with the objects `rewards` field."""
  rewards: String
  """Checks for equality with the objects `coupons` field."""
  coupons: String
  """Checks for equality with the objects `expiration` field."""
  expiration: Date
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `articles` field."""
  articles: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `users` field."""
  users: String
  """Checks for equality with the objects `discount` field."""
  discount: String
}

"""A connection to a list of `State` values."""
type StatesConnection {
  """A list of `State` objects."""
  nodes: [State]!
  """A list of edges which contains the `State` and cursor to aid in pagination."""
  edges: [StatesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `State` you could get from the connection."""
  totalCount: Int!
}

"""A `State` edge in the connection."""
type StatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `State` at the end of the edge."""
  node: State
}

"""A connection to a list of `Statistic` values."""
type StatisticsConnection {
  """A list of `Statistic` objects."""
  nodes: [Statistic]!
  """A list of edges which contains the `Statistic` and cursor to aid in pagination."""
  edges: [StatisticsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Statistic` you could get from the connection."""
  totalCount: Int!
}

type Statistic implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  excerpt: String
  description: String
  image: String
  published: Datetime
  specialOffers: String
  reports: String
  rewards: String
  coupons: String
  expiration: Date
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""A `Statistic` edge in the connection."""
type StatisticsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Statistic` at the end of the edge."""
  node: Statistic
}

"""Methods to use when ordering `Statistic`."""
enum StatisticsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  SPECIAL_OFFERS_ASC
  SPECIAL_OFFERS_DESC
  REPORTS_ASC
  REPORTS_DESC
  REWARDS_ASC
  REWARDS_DESC
  COUPONS_ASC
  COUPONS_DESC
  EXPIRATION_ASC
  EXPIRATION_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Statistic` object types. All fields are tested
for equality and combined with a logical and.
"""
input StatisticCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `excerpt` field."""
  excerpt: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `published` field."""
  published: Datetime
  """Checks for equality with the objects `specialOffers` field."""
  specialOffers: String
  """Checks for equality with the objects `reports` field."""
  reports: String
  """Checks for equality with the objects `rewards` field."""
  rewards: String
  """Checks for equality with the objects `coupons` field."""
  coupons: String
  """Checks for equality with the objects `expiration` field."""
  expiration: Date
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `articles` field."""
  articles: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `users` field."""
  users: String
}

"""A connection to a list of `Stock` values."""
type StocksConnection {
  """A list of `Stock` objects."""
  nodes: [Stock]!
  """A list of edges which contains the `Stock` and cursor to aid in pagination."""
  edges: [StocksEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Stock` you could get from the connection."""
  totalCount: Int!
}

type Stock implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  enabled: Boolean
  description: String
  website: String
  sources: String
}

"""A `Stock` edge in the connection."""
type StocksEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Stock` at the end of the edge."""
  node: Stock
}

"""Methods to use when ordering `Stock`."""
enum StocksOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ENABLED_ASC
  ENABLED_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  SOURCES_ASC
  SOURCES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Stock` object types. All fields are tested for equality and combined with a logical and."""
input StockCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `enabled` field."""
  enabled: Boolean
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `website` field."""
  website: String
  """Checks for equality with the objects `sources` field."""
  sources: String
}

"""A connection to a list of `Survey` values."""
type SurveysConnection {
  """A list of `Survey` objects."""
  nodes: [Survey]!
  """A list of edges which contains the `Survey` and cursor to aid in pagination."""
  edges: [SurveysEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Survey` you could get from the connection."""
  totalCount: Int!
}

type Survey implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  assignedTo: String
  status: String
  description: String
  question: String
  answer: String
  submitText: String
  satisfiedText: String
  neitherText: String
  dissatisfiedText: String
}

"""A `Survey` edge in the connection."""
type SurveysEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Survey` at the end of the edge."""
  node: Survey
}

"""Methods to use when ordering `Survey`."""
enum SurveysOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  STATUS_ASC
  STATUS_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  QUESTION_ASC
  QUESTION_DESC
  ANSWER_ASC
  ANSWER_DESC
  SUBMIT_TEXT_ASC
  SUBMIT_TEXT_DESC
  SATISFIED_TEXT_ASC
  SATISFIED_TEXT_DESC
  NEITHER_TEXT_ASC
  NEITHER_TEXT_DESC
  DISSATISFIED_TEXT_ASC
  DISSATISFIED_TEXT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Survey` object types. All fields are tested for equality and combined with a logical and."""
input SurveyCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `assignedTo` field."""
  assignedTo: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `question` field."""
  question: String
  """Checks for equality with the objects `answer` field."""
  answer: String
  """Checks for equality with the objects `submitText` field."""
  submitText: String
  """Checks for equality with the objects `satisfiedText` field."""
  satisfiedText: String
  """Checks for equality with the objects `neitherText` field."""
  neitherText: String
  """Checks for equality with the objects `dissatisfiedText` field."""
  dissatisfiedText: String
}

"""A connection to a list of `Tag` values."""
type TagsConnection {
  """A list of `Tag` objects."""
  nodes: [Tag]!
  """A list of edges which contains the `Tag` and cursor to aid in pagination."""
  edges: [TagsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Tag` you could get from the connection."""
  totalCount: Int!
}

type Tag implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  name: String!
  excerpt: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""A `Tag` edge in the connection."""
type TagsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Tag` at the end of the edge."""
  node: Tag
}

"""Methods to use when ordering `Tag`."""
enum TagsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical and."""
input TagCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `excerpt` field."""
  excerpt: String
  """Checks for equality with the objects `categories` field."""
  categories: String
  """Checks for equality with the objects `articles` field."""
  articles: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `customers` field."""
  customers: String
  """Checks for equality with the objects `users` field."""
  users: String
}

"""A connection to a list of `Target` values."""
type TargetsConnection {
  """A list of `Target` objects."""
  nodes: [Target]!
  """A list of edges which contains the `Target` and cursor to aid in pagination."""
  edges: [TargetsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Target` you could get from the connection."""
  totalCount: Int!
}

type Target implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  prefix: String
  firstName: String
  lastName: String
  department: String
  accountName: String
  address: String
  postalcode: String
  city: String
  state: String
  country: String
  email: String
  description: String
  fax: String
  website: String
  mobile: String
  jobTitle: String
  altAddress: String
  altPostalcode: String
  altCity: String
  altState: String
  altCountry: String
  officePhone: String
  customerName: String
  emailOptOut: String
  donotcall: String
}

"""A `Target` edge in the connection."""
type TargetsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Target` at the end of the edge."""
  node: Target
}

"""Methods to use when ordering `Target`."""
enum TargetsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PREFIX_ASC
  PREFIX_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  DEPARTMENT_ASC
  DEPARTMENT_DESC
  ACCOUNT_NAME_ASC
  ACCOUNT_NAME_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  POSTALCODE_ASC
  POSTALCODE_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  EMAIL_ASC
  EMAIL_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  FAX_ASC
  FAX_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  MOBILE_ASC
  MOBILE_DESC
  JOB_TITLE_ASC
  JOB_TITLE_DESC
  ALT_ADDRESS_ASC
  ALT_ADDRESS_DESC
  ALT_POSTALCODE_ASC
  ALT_POSTALCODE_DESC
  ALT_CITY_ASC
  ALT_CITY_DESC
  ALT_STATE_ASC
  ALT_STATE_DESC
  ALT_COUNTRY_ASC
  ALT_COUNTRY_DESC
  OFFICE_PHONE_ASC
  OFFICE_PHONE_DESC
  CUSTOMER_NAME_ASC
  CUSTOMER_NAME_DESC
  EMAIL_OPT_OUT_ASC
  EMAIL_OPT_OUT_DESC
  DONOTCALL_ASC
  DONOTCALL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Target` object types. All fields are tested for equality and combined with a logical and."""
input TargetCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `prefix` field."""
  prefix: String
  """Checks for equality with the objects `firstName` field."""
  firstName: String
  """Checks for equality with the objects `lastName` field."""
  lastName: String
  """Checks for equality with the objects `department` field."""
  department: String
  """Checks for equality with the objects `accountName` field."""
  accountName: String
  """Checks for equality with the objects `address` field."""
  address: String
  """Checks for equality with the objects `postalcode` field."""
  postalcode: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `email` field."""
  email: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `fax` field."""
  fax: String
  """Checks for equality with the objects `website` field."""
  website: String
  """Checks for equality with the objects `mobile` field."""
  mobile: String
  """Checks for equality with the objects `jobTitle` field."""
  jobTitle: String
  """Checks for equality with the objects `altAddress` field."""
  altAddress: String
  """Checks for equality with the objects `altPostalcode` field."""
  altPostalcode: String
  """Checks for equality with the objects `altCity` field."""
  altCity: String
  """Checks for equality with the objects `altState` field."""
  altState: String
  """Checks for equality with the objects `altCountry` field."""
  altCountry: String
  """Checks for equality with the objects `officePhone` field."""
  officePhone: String
  """Checks for equality with the objects `customerName` field."""
  customerName: String
  """Checks for equality with the objects `emailOptOut` field."""
  emailOptOut: String
  """Checks for equality with the objects `donotcall` field."""
  donotcall: String
}

"""A connection to a list of `TaxCategory` values."""
type TaxCategoriesConnection {
  """A list of `TaxCategory` objects."""
  nodes: [TaxCategory]!
  """A list of edges which contains the `TaxCategory` and cursor to aid in pagination."""
  edges: [TaxCategoriesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TaxCategory` you could get from the connection."""
  totalCount: Int!
}

type TaxCategory implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  default: String
}

"""A `TaxCategory` edge in the connection."""
type TaxCategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TaxCategory` at the end of the edge."""
  node: TaxCategory
}

"""Methods to use when ordering `TaxCategory`."""
enum TaxCategoriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DEFAULT_ASC
  DEFAULT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `TaxCategory` object types. All fields are tested
for equality and combined with a logical and.
"""
input TaxCategoryCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `default` field."""
  default: String
}

"""A connection to a list of `Theme` values."""
type ThemesConnection {
  """A list of `Theme` objects."""
  nodes: [Theme]!
  """A list of edges which contains the `Theme` and cursor to aid in pagination."""
  edges: [ThemesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Theme` you could get from the connection."""
  totalCount: Int!
}

type Theme implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  title: String
  parentTheme: String
  themePath: String
  action: String
  websiteId: BigInt!
  """Reads a single `Website` that is related to this `Theme`."""
  websiteByWebsiteId: Website
}

type Website implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  url: String
  shop: String
  store: String
  image: String
  category: String
  """Reads and enables pagination through a set of `Theme`."""
  themesByWebsiteId(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ThemeCondition
  ): ThemesConnection!
  """Reads and enables pagination through a set of `Theme`."""
  themesByWebsiteIdList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ThemeCondition
  ): [Theme!]!
}

"""Methods to use when ordering `Theme`."""
enum ThemesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TITLE_ASC
  TITLE_DESC
  PARENT_THEME_ASC
  PARENT_THEME_DESC
  THEME_PATH_ASC
  THEME_PATH_DESC
  ACTION_ASC
  ACTION_DESC
  WEBSITE_ID_ASC
  WEBSITE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Theme` object types. All fields are tested for equality and combined with a logical and."""
input ThemeCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `title` field."""
  title: String
  """Checks for equality with the objects `parentTheme` field."""
  parentTheme: String
  """Checks for equality with the objects `themePath` field."""
  themePath: String
  """Checks for equality with the objects `action` field."""
  action: String
  """Checks for equality with the objects `websiteId` field."""
  websiteId: BigInt
}

"""A `Theme` edge in the connection."""
type ThemesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Theme` at the end of the edge."""
  node: Theme
}

"""A connection to a list of `Ticketing` values."""
type TicketingsConnection {
  """A list of `Ticketing` objects."""
  nodes: [Ticketing]!
  """A list of edges which contains the `Ticketing` and cursor to aid in pagination."""
  edges: [TicketingsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Ticketing` you could get from the connection."""
  totalCount: Int!
}

"""A `Ticketing` edge in the connection."""
type TicketingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Ticketing` at the end of the edge."""
  node: Ticketing
}

"""A connection to a list of `TodoList` values."""
type TodoListsConnection {
  """A list of `TodoList` objects."""
  nodes: [TodoList]!
  """A list of edges which contains the `TodoList` and cursor to aid in pagination."""
  edges: [TodoListsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `TodoList` you could get from the connection."""
  totalCount: Int!
}

"""A `TodoList` edge in the connection."""
type TodoListsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `TodoList` at the end of the edge."""
  node: TodoList
}

"""A connection to a list of `UrlRewrite` values."""
type UrlRewritesConnection {
  """A list of `UrlRewrite` objects."""
  nodes: [UrlRewrite]!
  """A list of edges which contains the `UrlRewrite` and cursor to aid in pagination."""
  edges: [UrlRewritesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `UrlRewrite` you could get from the connection."""
  totalCount: Int!
}

type UrlRewrite implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  requestPath: String
  description: String
  redirectType: Boolean
  targetPath: String
  store: String
}

"""A `UrlRewrite` edge in the connection."""
type UrlRewritesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `UrlRewrite` at the end of the edge."""
  node: UrlRewrite
}

"""Methods to use when ordering `UrlRewrite`."""
enum UrlRewritesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  REQUEST_PATH_ASC
  REQUEST_PATH_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  REDIRECT_TYPE_ASC
  REDIRECT_TYPE_DESC
  TARGET_PATH_ASC
  TARGET_PATH_DESC
  STORE_ASC
  STORE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `UrlRewrite` object types. All fields are tested
for equality and combined with a logical and.
"""
input UrlRewriteCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `requestPath` field."""
  requestPath: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `redirectType` field."""
  redirectType: Boolean
  """Checks for equality with the objects `targetPath` field."""
  targetPath: String
  """Checks for equality with the objects `store` field."""
  store: String
}

"""A connection to a list of `UserRole` values."""
type UserRolesConnection {
  """A list of `UserRole` objects."""
  nodes: [UserRole]!
  """A list of edges which contains the `UserRole` and cursor to aid in pagination."""
  edges: [UserRolesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `UserRole` you could get from the connection."""
  totalCount: Int!
}

type UserRole implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  roleName: String!
  content: String
  createdAt: Datetime
}

"""A `UserRole` edge in the connection."""
type UserRolesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `UserRole` at the end of the edge."""
  node: UserRole
}

"""Methods to use when ordering `UserRole`."""
enum UserRolesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ROLE_NAME_ASC
  ROLE_NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `UserRole` object types. All fields are tested
for equality and combined with a logical and.
"""
input UserRoleCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `roleName` field."""
  roleName: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User]!
  """A list of edges which contains the `User` and cursor to aid in pagination."""
  edges: [UsersEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `User` at the end of the edge."""
  node: User
}

"""A connection to a list of `Visit` values."""
type VisitsConnection {
  """A list of `Visit` objects."""
  nodes: [Visit]!
  """A list of edges which contains the `Visit` and cursor to aid in pagination."""
  edges: [VisitsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Visit` you could get from the connection."""
  totalCount: Int!
}

type Visit implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  location: String
  username: String
  reason: String
  content: String
  emergency: String
  startDate: String
  endDate: String
  task: String
  meeting: String
}

"""A `Visit` edge in the connection."""
type VisitsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Visit` at the end of the edge."""
  node: Visit
}

"""Methods to use when ordering `Visit`."""
enum VisitsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  LOCATION_ASC
  LOCATION_DESC
  USERNAME_ASC
  USERNAME_DESC
  REASON_ASC
  REASON_DESC
  CONTENT_ASC
  CONTENT_DESC
  EMERGENCY_ASC
  EMERGENCY_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  TASK_ASC
  TASK_DESC
  MEETING_ASC
  MEETING_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Visit` object types. All fields are tested for equality and combined with a logical and."""
input VisitCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `location` field."""
  location: String
  """Checks for equality with the objects `username` field."""
  username: String
  """Checks for equality with the objects `reason` field."""
  reason: String
  """Checks for equality with the objects `content` field."""
  content: String
  """Checks for equality with the objects `emergency` field."""
  emergency: String
  """Checks for equality with the objects `startDate` field."""
  startDate: String
  """Checks for equality with the objects `endDate` field."""
  endDate: String
  """Checks for equality with the objects `task` field."""
  task: String
  """Checks for equality with the objects `meeting` field."""
  meeting: String
}

"""A connection to a list of `Warehouse` values."""
type WarehousesConnection {
  """A list of `Warehouse` objects."""
  nodes: [Warehouse]!
  """A list of edges which contains the `Warehouse` and cursor to aid in pagination."""
  edges: [WarehousesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Warehouse` you could get from the connection."""
  totalCount: Int!
}

type Warehouse implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  description: String
  city: String
  state: String
  country: String
  postal: String
  status: String
  image: String
  products: String
  category: String
  isPublic: String
}

"""A `Warehouse` edge in the connection."""
type WarehousesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Warehouse` at the end of the edge."""
  node: Warehouse
}

"""Methods to use when ordering `Warehouse`."""
enum WarehousesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  POSTAL_ASC
  POSTAL_DESC
  STATUS_ASC
  STATUS_DESC
  IMAGE_ASC
  IMAGE_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Warehouse` object types. All fields are tested
for equality and combined with a logical and.
"""
input WarehouseCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `description` field."""
  description: String
  """Checks for equality with the objects `city` field."""
  city: String
  """Checks for equality with the objects `state` field."""
  state: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `postal` field."""
  postal: String
  """Checks for equality with the objects `status` field."""
  status: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `products` field."""
  products: String
  """Checks for equality with the objects `category` field."""
  category: String
  """Checks for equality with the objects `isPublic` field."""
  isPublic: String
}

"""A connection to a list of `Webhook` values."""
type WebhooksConnection {
  """A list of `Webhook` objects."""
  nodes: [Webhook]!
  """A list of edges which contains the `Webhook` and cursor to aid in pagination."""
  edges: [WebhooksEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Webhook` you could get from the connection."""
  totalCount: Int!
}

type Webhook implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String!
  url: String!
  headers: String
  create: String
  retrieve: String
  update: String
  delete: String
  publish: String
  unpublish: String
}

"""A `Webhook` edge in the connection."""
type WebhooksEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Webhook` at the end of the edge."""
  node: Webhook
}

"""Methods to use when ordering `Webhook`."""
enum WebhooksOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  URL_ASC
  URL_DESC
  HEADERS_ASC
  HEADERS_DESC
  CREATE_ASC
  CREATE_DESC
  RETRIEVE_ASC
  RETRIEVE_DESC
  UPDATE_ASC
  UPDATE_DESC
  DELETE_ASC
  DELETE_DESC
  PUBLISH_ASC
  PUBLISH_DESC
  UNPUBLISH_ASC
  UNPUBLISH_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Webhook` object types. All fields are tested for equality and combined with a logical and."""
input WebhookCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `url` field."""
  url: String
  """Checks for equality with the objects `headers` field."""
  headers: String
  """Checks for equality with the objects `create` field."""
  create: String
  """Checks for equality with the objects `retrieve` field."""
  retrieve: String
  """Checks for equality with the objects `update` field."""
  update: String
  """Checks for equality with the objects `delete` field."""
  delete: String
  """Checks for equality with the objects `publish` field."""
  publish: String
  """Checks for equality with the objects `unpublish` field."""
  unpublish: String
}

"""A connection to a list of `Website` values."""
type WebsitesConnection {
  """A list of `Website` objects."""
  nodes: [Website]!
  """A list of edges which contains the `Website` and cursor to aid in pagination."""
  edges: [WebsitesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Website` you could get from the connection."""
  totalCount: Int!
}

"""A `Website` edge in the connection."""
type WebsitesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Website` at the end of the edge."""
  node: Website
}

"""Methods to use when ordering `Website`."""
enum WebsitesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  URL_ASC
  URL_DESC
  SHOP_ASC
  SHOP_DESC
  STORE_ASC
  STORE_DESC
  IMAGE_ASC
  IMAGE_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Website` object types. All fields are tested for equality and combined with a logical and."""
input WebsiteCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `url` field."""
  url: String
  """Checks for equality with the objects `shop` field."""
  shop: String
  """Checks for equality with the objects `store` field."""
  store: String
  """Checks for equality with the objects `image` field."""
  image: String
  """Checks for equality with the objects `category` field."""
  category: String
}

"""A connection to a list of `Wishlist` values."""
type WishlistsConnection {
  """A list of `Wishlist` objects."""
  nodes: [Wishlist]!
  """A list of edges which contains the `Wishlist` and cursor to aid in pagination."""
  edges: [WishlistsEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Wishlist` you could get from the connection."""
  totalCount: Int!
}

"""A `Wishlist` edge in the connection."""
type WishlistsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Wishlist` at the end of the edge."""
  node: Wishlist
}

"""A connection to a list of `Zone` values."""
type ZonesConnection {
  """A list of `Zone` objects."""
  nodes: [Zone]!
  """A list of edges which contains the `Zone` and cursor to aid in pagination."""
  edges: [ZonesEdge!]!
  """Information to aid in pagination."""
  pageInfo: PageInfo!
  """The count of *all* `Zone` you could get from the connection."""
  totalCount: Int!
}

type Zone implements Node @key(fields: "nodeId") {
  """A globally unique identifier. Can be used in various places throughout the system to identify this single value."""
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  updatedAt: Datetime
  scope: String
  type: String
  country: String
  code: String
}

"""A `Zone` edge in the connection."""
type ZonesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor
  """The `Zone` at the end of the edge."""
  node: Zone
}

"""Methods to use when ordering `Zone`."""
enum ZonesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  SCOPE_ASC
  SCOPE_DESC
  TYPE_ASC
  TYPE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  CODE_ASC
  CODE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""A condition to be used against `Zone` object types. All fields are tested for equality and combined with a logical and."""
input ZoneCondition {
  """Checks for equality with the objects `id` field."""
  id: BigInt
  """Checks for equality with the objects `createdAt` field."""
  createdAt: Datetime
  """Checks for equality with the objects `name` field."""
  name: String
  """Checks for equality with the objects `updatedAt` field."""
  updatedAt: Datetime
  """Checks for equality with the objects `scope` field."""
  scope: String
  """Checks for equality with the objects `type` field."""
  type: String
  """Checks for equality with the objects `country` field."""
  country: String
  """Checks for equality with the objects `code` field."""
  code: String
}

"""A union of all federated types (those that use the @key directive)."""
union _Entity = Endofshift | _Schema | _PrismaMigration | Account | Agreement | Mediamanager | Brand | Product | Coupon | CreditMemo | Customer | Comment | Training | Country | State | Checklist | TodoList | Project | User | Email | Message | Workspace | Shop | Category | Ticketing | NewsletterSubscriber | Order | Quote | Transaction | CustomerPayment | CustomerGroup | Return | ProductAttribute | Rating | TaxRate | TaxRule | ProductType | Occassion | Wishlist | Manufacturer | Analytic | Apitoken | Article | CartPriceRule | Case | CatalogPriceRule | Channel | City | Collection | ContentType | Contract | Currency | CurrencyRate | CurrencySymbol | Customization | Dashboard | Deepdive | EmailTemplate | Event | Fullfillment | GeneralSetting | GiftCertificate | Glossary | Importm | Integration | Internalization | Invitation | Invoice | Knowledgebase | Lead | Meeting | Ooto | Opportunity | Page | Partner | Payment | PdfTemplate | Permission | Plugin | ProjectTemplate | Provider | Report | Review | Reward | Scheduler | Segment | Settingscustomer | Settingsgeneral | Settingshop | Settingsmarketing | Settingssale | Shipment | ShopSetting | SpecialDiscount | Statistic | Stock | Survey | Tag | Target | TaxCategory | Theme | Website | UrlRewrite | UserRole | Visit | Warehouse | Webhook | Zone

scalar _Any

"""Describes our federated service."""
type _Service {
  """
  The GraphQL Schema Language definiton of our endpoint including the
  Apollo Federation directives (but not their definitions or the special
  Apollo Federation fields).
  """
  sdl: String @deprecated(reason: "Only Apollo Federation should use this")
}

"""The root mutation type which contains root level fields which mutate data."""
type Mutation {
  """Creates a single `Endofshift`."""
  createEndofshift(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateEndofshiftInput!
  ): CreateEndofshiftPayload
  """Creates a single `_Schema`."""
  createSchema(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSchemaInput!
  ): CreateSchemaPayload
  """Creates a single `_PrismaMigration`."""
  createPrismaMigration(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreatePrismaMigrationInput!
  ): CreatePrismaMigrationPayload
  """Creates a single `Account`."""
  createAccount(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateAccountInput!
  ): CreateAccountPayload
  """Creates a single `Agreement`."""
  createAgreement(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateAgreementInput!
  ): CreateAgreementPayload
  """Creates a single `Analytic`."""
  createAnalytic(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateAnalyticInput!
  ): CreateAnalyticPayload
  """Creates a single `Apitoken`."""
  createApitoken(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateApitokenInput!
  ): CreateApitokenPayload
  """Creates a single `Article`."""
  createArticle(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateArticleInput!
  ): CreateArticlePayload
  """Creates a single `Brand`."""
  createBrand(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateBrandInput!
  ): CreateBrandPayload
  """Creates a single `CartPriceRule`."""
  createCartPriceRule(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCartPriceRuleInput!
  ): CreateCartPriceRulePayload
  """Creates a single `Case`."""
  createCase(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCaseInput!
  ): CreateCasePayload
  """Creates a single `CatalogPriceRule`."""
  createCatalogPriceRule(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCatalogPriceRuleInput!
  ): CreateCatalogPriceRulePayload
  """Creates a single `Category`."""
  createCategory(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCategoryInput!
  ): CreateCategoryPayload
  """Creates a single `Channel`."""
  createChannel(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateChannelInput!
  ): CreateChannelPayload
  """Creates a single `Checklist`."""
  createChecklist(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateChecklistInput!
  ): CreateChecklistPayload
  """Creates a single `City`."""
  createCity(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCityInput!
  ): CreateCityPayload
  """Creates a single `Collection`."""
  createCollection(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCollectionInput!
  ): CreateCollectionPayload
  """Creates a single `Comment`."""
  createComment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCommentInput!
  ): CreateCommentPayload
  """Creates a single `ContentType`."""
  createContentType(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateContentTypeInput!
  ): CreateContentTypePayload
  """Creates a single `Contract`."""
  createContract(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateContractInput!
  ): CreateContractPayload
  """Creates a single `Country`."""
  createCountry(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCountryInput!
  ): CreateCountryPayload
  """Creates a single `Coupon`."""
  createCoupon(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCouponInput!
  ): CreateCouponPayload
  """Creates a single `CreditMemo`."""
  createCreditMemo(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCreditMemoInput!
  ): CreateCreditMemoPayload
  """Creates a single `Currency`."""
  createCurrency(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCurrencyInput!
  ): CreateCurrencyPayload
  """Creates a single `CurrencyRate`."""
  createCurrencyRate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCurrencyRateInput!
  ): CreateCurrencyRatePayload
  """Creates a single `CurrencySymbol`."""
  createCurrencySymbol(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCurrencySymbolInput!
  ): CreateCurrencySymbolPayload
  """Creates a single `CustomerGroup`."""
  createCustomerGroup(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCustomerGroupInput!
  ): CreateCustomerGroupPayload
  """Creates a single `CustomerPayment`."""
  createCustomerPayment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCustomerPaymentInput!
  ): CreateCustomerPaymentPayload
  """Creates a single `Customer`."""
  createCustomer(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCustomerInput!
  ): CreateCustomerPayload
  """Creates a single `Customization`."""
  createCustomization(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateCustomizationInput!
  ): CreateCustomizationPayload
  """Creates a single `Dashboard`."""
  createDashboard(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateDashboardInput!
  ): CreateDashboardPayload
  """Creates a single `Deepdive`."""
  createDeepdive(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateDeepdiveInput!
  ): CreateDeepdivePayload
  """Creates a single `EmailTemplate`."""
  createEmailTemplate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateEmailTemplateInput!
  ): CreateEmailTemplatePayload
  """Creates a single `Email`."""
  createEmail(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateEmailInput!
  ): CreateEmailPayload
  """Creates a single `Event`."""
  createEvent(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateEventInput!
  ): CreateEventPayload
  """Creates a single `Fullfillment`."""
  createFullfillment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateFullfillmentInput!
  ): CreateFullfillmentPayload
  """Creates a single `GeneralSetting`."""
  createGeneralSetting(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateGeneralSettingInput!
  ): CreateGeneralSettingPayload
  """Creates a single `GiftCertificate`."""
  createGiftCertificate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateGiftCertificateInput!
  ): CreateGiftCertificatePayload
  """Creates a single `Glossary`."""
  createGlossary(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateGlossaryInput!
  ): CreateGlossaryPayload
  """Creates a single `Importm`."""
  createImportm(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateImportmInput!
  ): CreateImportmPayload
  """Creates a single `Integration`."""
  createIntegration(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateIntegrationInput!
  ): CreateIntegrationPayload
  """Creates a single `Internalization`."""
  createInternalization(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateInternalizationInput!
  ): CreateInternalizationPayload
  """Creates a single `Invitation`."""
  createInvitation(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateInvitationInput!
  ): CreateInvitationPayload
  """Creates a single `Invoice`."""
  createInvoice(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateInvoiceInput!
  ): CreateInvoicePayload
  """Creates a single `Knowledgebase`."""
  createKnowledgebase(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateKnowledgebaseInput!
  ): CreateKnowledgebasePayload
  """Creates a single `Lead`."""
  createLead(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateLeadInput!
  ): CreateLeadPayload
  """Creates a single `Manufacturer`."""
  createManufacturer(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateManufacturerInput!
  ): CreateManufacturerPayload
  """Creates a single `Mediamanager`."""
  createMediamanager(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateMediamanagerInput!
  ): CreateMediamanagerPayload
  """Creates a single `Meeting`."""
  createMeeting(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateMeetingInput!
  ): CreateMeetingPayload
  """Creates a single `Message`."""
  createMessage(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateMessageInput!
  ): CreateMessagePayload
  """Creates a single `NewsletterSubscriber`."""
  createNewsletterSubscriber(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateNewsletterSubscriberInput!
  ): CreateNewsletterSubscriberPayload
  """Creates a single `Occassion`."""
  createOccassion(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateOccassionInput!
  ): CreateOccassionPayload
  """Creates a single `Ooto`."""
  createOoto(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateOotoInput!
  ): CreateOotoPayload
  """Creates a single `Opportunity`."""
  createOpportunity(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateOpportunityInput!
  ): CreateOpportunityPayload
  """Creates a single `Order`."""
  createOrder(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateOrderInput!
  ): CreateOrderPayload
  """Creates a single `Page`."""
  createPage(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreatePageInput!
  ): CreatePagePayload
  """Creates a single `Partner`."""
  createPartner(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreatePartnerInput!
  ): CreatePartnerPayload
  """Creates a single `Payment`."""
  createPayment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreatePaymentInput!
  ): CreatePaymentPayload
  """Creates a single `PdfTemplate`."""
  createPdfTemplate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreatePdfTemplateInput!
  ): CreatePdfTemplatePayload
  """Creates a single `Permission`."""
  createPermission(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreatePermissionInput!
  ): CreatePermissionPayload
  """Creates a single `Plugin`."""
  createPlugin(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreatePluginInput!
  ): CreatePluginPayload
  """Creates a single `ProductAttribute`."""
  createProductAttribute(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateProductAttributeInput!
  ): CreateProductAttributePayload
  """Creates a single `ProductType`."""
  createProductType(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateProductTypeInput!
  ): CreateProductTypePayload
  """Creates a single `Product`."""
  createProduct(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateProductInput!
  ): CreateProductPayload
  """Creates a single `ProjectTemplate`."""
  createProjectTemplate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateProjectTemplateInput!
  ): CreateProjectTemplatePayload
  """Creates a single `Project`."""
  createProject(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateProjectInput!
  ): CreateProjectPayload
  """Creates a single `Provider`."""
  createProvider(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateProviderInput!
  ): CreateProviderPayload
  """Creates a single `Quote`."""
  createQuote(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateQuoteInput!
  ): CreateQuotePayload
  """Creates a single `Rating`."""
  createRating(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateRatingInput!
  ): CreateRatingPayload
  """Creates a single `Report`."""
  createReport(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateReportInput!
  ): CreateReportPayload
  """Creates a single `Return`."""
  createReturn(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateReturnInput!
  ): CreateReturnPayload
  """Creates a single `Review`."""
  createReview(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateReviewInput!
  ): CreateReviewPayload
  """Creates a single `Reward`."""
  createReward(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateRewardInput!
  ): CreateRewardPayload
  """Creates a single `Scheduler`."""
  createScheduler(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSchedulerInput!
  ): CreateSchedulerPayload
  """Creates a single `Segment`."""
  createSegment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSegmentInput!
  ): CreateSegmentPayload
  """Creates a single `Settingscustomer`."""
  createSettingscustomer(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSettingscustomerInput!
  ): CreateSettingscustomerPayload
  """Creates a single `Settingsgeneral`."""
  createSettingsgeneral(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSettingsgeneralInput!
  ): CreateSettingsgeneralPayload
  """Creates a single `Settingshop`."""
  createSettingshop(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSettingshopInput!
  ): CreateSettingshopPayload
  """Creates a single `Settingsmarketing`."""
  createSettingsmarketing(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSettingsmarketingInput!
  ): CreateSettingsmarketingPayload
  """Creates a single `Settingssale`."""
  createSettingssale(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSettingssaleInput!
  ): CreateSettingssalePayload
  """Creates a single `Shipment`."""
  createShipment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateShipmentInput!
  ): CreateShipmentPayload
  """Creates a single `ShopSetting`."""
  createShopSetting(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateShopSettingInput!
  ): CreateShopSettingPayload
  """Creates a single `Shop`."""
  createShop(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateShopInput!
  ): CreateShopPayload
  """Creates a single `SpecialDiscount`."""
  createSpecialDiscount(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSpecialDiscountInput!
  ): CreateSpecialDiscountPayload
  """Creates a single `State`."""
  createState(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateStateInput!
  ): CreateStatePayload
  """Creates a single `Statistic`."""
  createStatistic(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateStatisticInput!
  ): CreateStatisticPayload
  """Creates a single `Stock`."""
  createStock(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateStockInput!
  ): CreateStockPayload
  """Creates a single `Survey`."""
  createSurvey(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateSurveyInput!
  ): CreateSurveyPayload
  """Creates a single `Tag`."""
  createTag(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateTagInput!
  ): CreateTagPayload
  """Creates a single `Target`."""
  createTarget(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateTargetInput!
  ): CreateTargetPayload
  """Creates a single `TaxCategory`."""
  createTaxCategory(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateTaxCategoryInput!
  ): CreateTaxCategoryPayload
  """Creates a single `TaxRate`."""
  createTaxRate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateTaxRateInput!
  ): CreateTaxRatePayload
  """Creates a single `TaxRule`."""
  createTaxRule(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateTaxRuleInput!
  ): CreateTaxRulePayload
  """Creates a single `Theme`."""
  createTheme(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateThemeInput!
  ): CreateThemePayload
  """Creates a single `Ticketing`."""
  createTicketing(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateTicketingInput!
  ): CreateTicketingPayload
  """Creates a single `TodoList`."""
  createTodoList(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateTodoListInput!
  ): CreateTodoListPayload
  """Creates a single `Training`."""
  createTraining(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateTrainingInput!
  ): CreateTrainingPayload
  """Creates a single `Transaction`."""
  createTransaction(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateTransactionInput!
  ): CreateTransactionPayload
  """Creates a single `UrlRewrite`."""
  createUrlRewrite(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateUrlRewriteInput!
  ): CreateUrlRewritePayload
  """Creates a single `UserRole`."""
  createUserRole(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateUserRoleInput!
  ): CreateUserRolePayload
  """Creates a single `User`."""
  createUser(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateUserInput!
  ): CreateUserPayload
  """Creates a single `Visit`."""
  createVisit(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateVisitInput!
  ): CreateVisitPayload
  """Creates a single `Warehouse`."""
  createWarehouse(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateWarehouseInput!
  ): CreateWarehousePayload
  """Creates a single `Webhook`."""
  createWebhook(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateWebhookInput!
  ): CreateWebhookPayload
  """Creates a single `Website`."""
  createWebsite(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateWebsiteInput!
  ): CreateWebsitePayload
  """Creates a single `Wishlist`."""
  createWishlist(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateWishlistInput!
  ): CreateWishlistPayload
  """Creates a single `Workspace`."""
  createWorkspace(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateWorkspaceInput!
  ): CreateWorkspacePayload
  """Creates a single `Zone`."""
  createZone(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: CreateZoneInput!
  ): CreateZonePayload
  """Updates a single `Endofshift` using its globally unique id and a patch."""
  updateEndofshift(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateEndofshiftInput!
  ): UpdateEndofshiftPayload
  """Updates a single `Endofshift` using a unique key and a patch."""
  updateEndofshiftById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateEndofshiftByIdInput!
  ): UpdateEndofshiftPayload
  """Updates a single `_Schema` using its globally unique id and a patch."""
  updateSchema(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSchemaInput!
  ): UpdateSchemaPayload
  """Updates a single `_Schema` using a unique key and a patch."""
  updateSchemaByClassName(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSchemaByClassNameInput!
  ): UpdateSchemaPayload
  """Updates a single `_PrismaMigration` using its globally unique id and a patch."""
  updatePrismaMigration(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePrismaMigrationInput!
  ): UpdatePrismaMigrationPayload
  """Updates a single `_PrismaMigration` using a unique key and a patch."""
  updatePrismaMigrationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePrismaMigrationByIdInput!
  ): UpdatePrismaMigrationPayload
  """Updates a single `Account` using its globally unique id and a patch."""
  updateAccount(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateAccountInput!
  ): UpdateAccountPayload
  """Updates a single `Account` using a unique key and a patch."""
  updateAccountById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateAccountByIdInput!
  ): UpdateAccountPayload
  """Updates a single `Agreement` using its globally unique id and a patch."""
  updateAgreement(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateAgreementInput!
  ): UpdateAgreementPayload
  """Updates a single `Agreement` using a unique key and a patch."""
  updateAgreementById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateAgreementByIdInput!
  ): UpdateAgreementPayload
  """Updates a single `Analytic` using its globally unique id and a patch."""
  updateAnalytic(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateAnalyticInput!
  ): UpdateAnalyticPayload
  """Updates a single `Analytic` using a unique key and a patch."""
  updateAnalyticById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateAnalyticByIdInput!
  ): UpdateAnalyticPayload
  """Updates a single `Apitoken` using its globally unique id and a patch."""
  updateApitoken(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateApitokenInput!
  ): UpdateApitokenPayload
  """Updates a single `Apitoken` using a unique key and a patch."""
  updateApitokenById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateApitokenByIdInput!
  ): UpdateApitokenPayload
  """Updates a single `Article` using its globally unique id and a patch."""
  updateArticle(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateArticleInput!
  ): UpdateArticlePayload
  """Updates a single `Article` using a unique key and a patch."""
  updateArticleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateArticleByIdInput!
  ): UpdateArticlePayload
  """Updates a single `Brand` using its globally unique id and a patch."""
  updateBrand(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateBrandInput!
  ): UpdateBrandPayload
  """Updates a single `Brand` using a unique key and a patch."""
  updateBrandById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateBrandByIdInput!
  ): UpdateBrandPayload
  """Updates a single `CartPriceRule` using its globally unique id and a patch."""
  updateCartPriceRule(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCartPriceRuleInput!
  ): UpdateCartPriceRulePayload
  """Updates a single `CartPriceRule` using a unique key and a patch."""
  updateCartPriceRuleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCartPriceRuleByIdInput!
  ): UpdateCartPriceRulePayload
  """Updates a single `Case` using its globally unique id and a patch."""
  updateCase(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCaseInput!
  ): UpdateCasePayload
  """Updates a single `Case` using a unique key and a patch."""
  updateCaseById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCaseByIdInput!
  ): UpdateCasePayload
  """Updates a single `CatalogPriceRule` using its globally unique id and a patch."""
  updateCatalogPriceRule(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCatalogPriceRuleInput!
  ): UpdateCatalogPriceRulePayload
  """Updates a single `CatalogPriceRule` using a unique key and a patch."""
  updateCatalogPriceRuleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCatalogPriceRuleByIdInput!
  ): UpdateCatalogPriceRulePayload
  """Updates a single `Category` using its globally unique id and a patch."""
  updateCategory(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCategoryInput!
  ): UpdateCategoryPayload
  """Updates a single `Category` using a unique key and a patch."""
  updateCategoryById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCategoryByIdInput!
  ): UpdateCategoryPayload
  """Updates a single `Channel` using its globally unique id and a patch."""
  updateChannel(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateChannelInput!
  ): UpdateChannelPayload
  """Updates a single `Channel` using a unique key and a patch."""
  updateChannelById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateChannelByIdInput!
  ): UpdateChannelPayload
  """Updates a single `Checklist` using its globally unique id and a patch."""
  updateChecklist(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateChecklistInput!
  ): UpdateChecklistPayload
  """Updates a single `Checklist` using a unique key and a patch."""
  updateChecklistById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateChecklistByIdInput!
  ): UpdateChecklistPayload
  """Updates a single `City` using its globally unique id and a patch."""
  updateCity(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCityInput!
  ): UpdateCityPayload
  """Updates a single `City` using a unique key and a patch."""
  updateCityById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCityByIdInput!
  ): UpdateCityPayload
  """Updates a single `Collection` using its globally unique id and a patch."""
  updateCollection(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCollectionInput!
  ): UpdateCollectionPayload
  """Updates a single `Collection` using a unique key and a patch."""
  updateCollectionById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCollectionByIdInput!
  ): UpdateCollectionPayload
  """Updates a single `Comment` using its globally unique id and a patch."""
  updateComment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCommentInput!
  ): UpdateCommentPayload
  """Updates a single `Comment` using a unique key and a patch."""
  updateCommentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCommentByIdInput!
  ): UpdateCommentPayload
  """Updates a single `ContentType` using its globally unique id and a patch."""
  updateContentType(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateContentTypeInput!
  ): UpdateContentTypePayload
  """Updates a single `ContentType` using a unique key and a patch."""
  updateContentTypeById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateContentTypeByIdInput!
  ): UpdateContentTypePayload
  """Updates a single `Contract` using its globally unique id and a patch."""
  updateContract(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateContractInput!
  ): UpdateContractPayload
  """Updates a single `Contract` using a unique key and a patch."""
  updateContractById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateContractByIdInput!
  ): UpdateContractPayload
  """Updates a single `Country` using its globally unique id and a patch."""
  updateCountry(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCountryInput!
  ): UpdateCountryPayload
  """Updates a single `Country` using a unique key and a patch."""
  updateCountryById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCountryByIdInput!
  ): UpdateCountryPayload
  """Updates a single `Coupon` using its globally unique id and a patch."""
  updateCoupon(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCouponInput!
  ): UpdateCouponPayload
  """Updates a single `Coupon` using a unique key and a patch."""
  updateCouponById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCouponByIdInput!
  ): UpdateCouponPayload
  """Updates a single `CreditMemo` using its globally unique id and a patch."""
  updateCreditMemo(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCreditMemoInput!
  ): UpdateCreditMemoPayload
  """Updates a single `CreditMemo` using a unique key and a patch."""
  updateCreditMemoByCreditMemoAndId(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCreditMemoByCreditMemoAndIdInput!
  ): UpdateCreditMemoPayload
  """Updates a single `Currency` using its globally unique id and a patch."""
  updateCurrency(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCurrencyInput!
  ): UpdateCurrencyPayload
  """Updates a single `Currency` using a unique key and a patch."""
  updateCurrencyById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCurrencyByIdInput!
  ): UpdateCurrencyPayload
  """Updates a single `CurrencyRate` using its globally unique id and a patch."""
  updateCurrencyRate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCurrencyRateInput!
  ): UpdateCurrencyRatePayload
  """Updates a single `CurrencyRate` using a unique key and a patch."""
  updateCurrencyRateByImportService(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCurrencyRateByImportServiceInput!
  ): UpdateCurrencyRatePayload
  """Updates a single `CurrencyRate` using a unique key and a patch."""
  updateCurrencyRateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCurrencyRateByIdInput!
  ): UpdateCurrencyRatePayload
  """Updates a single `CurrencySymbol` using its globally unique id and a patch."""
  updateCurrencySymbol(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCurrencySymbolInput!
  ): UpdateCurrencySymbolPayload
  """Updates a single `CurrencySymbol` using a unique key and a patch."""
  updateCurrencySymbolBySymbol(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCurrencySymbolBySymbolInput!
  ): UpdateCurrencySymbolPayload
  """Updates a single `CurrencySymbol` using a unique key and a patch."""
  updateCurrencySymbolById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCurrencySymbolByIdInput!
  ): UpdateCurrencySymbolPayload
  """Updates a single `CustomerGroup` using its globally unique id and a patch."""
  updateCustomerGroup(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCustomerGroupInput!
  ): UpdateCustomerGroupPayload
  """Updates a single `CustomerGroup` using a unique key and a patch."""
  updateCustomerGroupById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCustomerGroupByIdInput!
  ): UpdateCustomerGroupPayload
  """Updates a single `CustomerPayment` using its globally unique id and a patch."""
  updateCustomerPayment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCustomerPaymentInput!
  ): UpdateCustomerPaymentPayload
  """Updates a single `CustomerPayment` using a unique key and a patch."""
  updateCustomerPaymentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCustomerPaymentByIdInput!
  ): UpdateCustomerPaymentPayload
  """Updates a single `Customer` using its globally unique id and a patch."""
  updateCustomer(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCustomerInput!
  ): UpdateCustomerPayload
  """Updates a single `Customer` using a unique key and a patch."""
  updateCustomerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCustomerByIdInput!
  ): UpdateCustomerPayload
  """Updates a single `Customization` using its globally unique id and a patch."""
  updateCustomization(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCustomizationInput!
  ): UpdateCustomizationPayload
  """Updates a single `Customization` using a unique key and a patch."""
  updateCustomizationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateCustomizationByIdInput!
  ): UpdateCustomizationPayload
  """Updates a single `Dashboard` using its globally unique id and a patch."""
  updateDashboard(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateDashboardInput!
  ): UpdateDashboardPayload
  """Updates a single `Dashboard` using a unique key and a patch."""
  updateDashboardById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateDashboardByIdInput!
  ): UpdateDashboardPayload
  """Updates a single `Deepdive` using its globally unique id and a patch."""
  updateDeepdive(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateDeepdiveInput!
  ): UpdateDeepdivePayload
  """Updates a single `Deepdive` using a unique key and a patch."""
  updateDeepdiveById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateDeepdiveByIdInput!
  ): UpdateDeepdivePayload
  """Updates a single `EmailTemplate` using its globally unique id and a patch."""
  updateEmailTemplate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateEmailTemplateInput!
  ): UpdateEmailTemplatePayload
  """Updates a single `EmailTemplate` using a unique key and a patch."""
  updateEmailTemplateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateEmailTemplateByIdInput!
  ): UpdateEmailTemplatePayload
  """Updates a single `Email` using its globally unique id and a patch."""
  updateEmail(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateEmailInput!
  ): UpdateEmailPayload
  """Updates a single `Email` using a unique key and a patch."""
  updateEmailById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateEmailByIdInput!
  ): UpdateEmailPayload
  """Updates a single `Event` using its globally unique id and a patch."""
  updateEvent(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateEventInput!
  ): UpdateEventPayload
  """Updates a single `Event` using a unique key and a patch."""
  updateEventById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateEventByIdInput!
  ): UpdateEventPayload
  """Updates a single `Fullfillment` using its globally unique id and a patch."""
  updateFullfillment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateFullfillmentInput!
  ): UpdateFullfillmentPayload
  """Updates a single `Fullfillment` using a unique key and a patch."""
  updateFullfillmentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateFullfillmentByIdInput!
  ): UpdateFullfillmentPayload
  """Updates a single `GeneralSetting` using its globally unique id and a patch."""
  updateGeneralSetting(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateGeneralSettingInput!
  ): UpdateGeneralSettingPayload
  """Updates a single `GeneralSetting` using a unique key and a patch."""
  updateGeneralSettingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateGeneralSettingByIdInput!
  ): UpdateGeneralSettingPayload
  """Updates a single `GiftCertificate` using its globally unique id and a patch."""
  updateGiftCertificate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateGiftCertificateInput!
  ): UpdateGiftCertificatePayload
  """Updates a single `GiftCertificate` using a unique key and a patch."""
  updateGiftCertificateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateGiftCertificateByIdInput!
  ): UpdateGiftCertificatePayload
  """Updates a single `Glossary` using its globally unique id and a patch."""
  updateGlossary(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateGlossaryInput!
  ): UpdateGlossaryPayload
  """Updates a single `Glossary` using a unique key and a patch."""
  updateGlossaryById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateGlossaryByIdInput!
  ): UpdateGlossaryPayload
  """Updates a single `Importm` using its globally unique id and a patch."""
  updateImportm(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateImportmInput!
  ): UpdateImportmPayload
  """Updates a single `Importm` using a unique key and a patch."""
  updateImportmById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateImportmByIdInput!
  ): UpdateImportmPayload
  """Updates a single `Integration` using its globally unique id and a patch."""
  updateIntegration(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateIntegrationInput!
  ): UpdateIntegrationPayload
  """Updates a single `Integration` using a unique key and a patch."""
  updateIntegrationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateIntegrationByIdInput!
  ): UpdateIntegrationPayload
  """Updates a single `Internalization` using its globally unique id and a patch."""
  updateInternalization(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateInternalizationInput!
  ): UpdateInternalizationPayload
  """Updates a single `Internalization` using a unique key and a patch."""
  updateInternalizationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateInternalizationByIdInput!
  ): UpdateInternalizationPayload
  """Updates a single `Invitation` using its globally unique id and a patch."""
  updateInvitation(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateInvitationInput!
  ): UpdateInvitationPayload
  """Updates a single `Invitation` using a unique key and a patch."""
  updateInvitationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateInvitationByIdInput!
  ): UpdateInvitationPayload
  """Updates a single `Invoice` using its globally unique id and a patch."""
  updateInvoice(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateInvoiceInput!
  ): UpdateInvoicePayload
  """Updates a single `Invoice` using a unique key and a patch."""
  updateInvoiceById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateInvoiceByIdInput!
  ): UpdateInvoicePayload
  """Updates a single `Knowledgebase` using its globally unique id and a patch."""
  updateKnowledgebase(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateKnowledgebaseInput!
  ): UpdateKnowledgebasePayload
  """Updates a single `Knowledgebase` using a unique key and a patch."""
  updateKnowledgebaseById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateKnowledgebaseByIdInput!
  ): UpdateKnowledgebasePayload
  """Updates a single `Lead` using its globally unique id and a patch."""
  updateLead(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateLeadInput!
  ): UpdateLeadPayload
  """Updates a single `Lead` using a unique key and a patch."""
  updateLeadById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateLeadByIdInput!
  ): UpdateLeadPayload
  """Updates a single `Manufacturer` using its globally unique id and a patch."""
  updateManufacturer(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateManufacturerInput!
  ): UpdateManufacturerPayload
  """Updates a single `Manufacturer` using a unique key and a patch."""
  updateManufacturerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateManufacturerByIdInput!
  ): UpdateManufacturerPayload
  """Updates a single `Mediamanager` using its globally unique id and a patch."""
  updateMediamanager(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateMediamanagerInput!
  ): UpdateMediamanagerPayload
  """Updates a single `Mediamanager` using a unique key and a patch."""
  updateMediamanagerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateMediamanagerByIdInput!
  ): UpdateMediamanagerPayload
  """Updates a single `Meeting` using its globally unique id and a patch."""
  updateMeeting(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateMeetingInput!
  ): UpdateMeetingPayload
  """Updates a single `Meeting` using a unique key and a patch."""
  updateMeetingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateMeetingByIdInput!
  ): UpdateMeetingPayload
  """Updates a single `Message` using its globally unique id and a patch."""
  updateMessage(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateMessageInput!
  ): UpdateMessagePayload
  """Updates a single `Message` using a unique key and a patch."""
  updateMessageById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateMessageByIdInput!
  ): UpdateMessagePayload
  """Updates a single `NewsletterSubscriber` using its globally unique id and a patch."""
  updateNewsletterSubscriber(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateNewsletterSubscriberInput!
  ): UpdateNewsletterSubscriberPayload
  """Updates a single `NewsletterSubscriber` using a unique key and a patch."""
  updateNewsletterSubscriberById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateNewsletterSubscriberByIdInput!
  ): UpdateNewsletterSubscriberPayload
  """Updates a single `Occassion` using its globally unique id and a patch."""
  updateOccassion(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateOccassionInput!
  ): UpdateOccassionPayload
  """Updates a single `Occassion` using a unique key and a patch."""
  updateOccassionById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateOccassionByIdInput!
  ): UpdateOccassionPayload
  """Updates a single `Ooto` using its globally unique id and a patch."""
  updateOoto(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateOotoInput!
  ): UpdateOotoPayload
  """Updates a single `Ooto` using a unique key and a patch."""
  updateOotoById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateOotoByIdInput!
  ): UpdateOotoPayload
  """Updates a single `Opportunity` using its globally unique id and a patch."""
  updateOpportunity(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateOpportunityInput!
  ): UpdateOpportunityPayload
  """Updates a single `Opportunity` using a unique key and a patch."""
  updateOpportunityById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateOpportunityByIdInput!
  ): UpdateOpportunityPayload
  """Updates a single `Order` using its globally unique id and a patch."""
  updateOrder(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateOrderInput!
  ): UpdateOrderPayload
  """Updates a single `Order` using a unique key and a patch."""
  updateOrderById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateOrderByIdInput!
  ): UpdateOrderPayload
  """Updates a single `Page` using its globally unique id and a patch."""
  updatePage(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePageInput!
  ): UpdatePagePayload
  """Updates a single `Page` using a unique key and a patch."""
  updatePageById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePageByIdInput!
  ): UpdatePagePayload
  """Updates a single `Partner` using its globally unique id and a patch."""
  updatePartner(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePartnerInput!
  ): UpdatePartnerPayload
  """Updates a single `Partner` using a unique key and a patch."""
  updatePartnerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePartnerByIdInput!
  ): UpdatePartnerPayload
  """Updates a single `Payment` using its globally unique id and a patch."""
  updatePayment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePaymentInput!
  ): UpdatePaymentPayload
  """Updates a single `Payment` using a unique key and a patch."""
  updatePaymentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePaymentByIdInput!
  ): UpdatePaymentPayload
  """Updates a single `PdfTemplate` using its globally unique id and a patch."""
  updatePdfTemplate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePdfTemplateInput!
  ): UpdatePdfTemplatePayload
  """Updates a single `PdfTemplate` using a unique key and a patch."""
  updatePdfTemplateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePdfTemplateByIdInput!
  ): UpdatePdfTemplatePayload
  """Updates a single `Permission` using its globally unique id and a patch."""
  updatePermission(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePermissionInput!
  ): UpdatePermissionPayload
  """Updates a single `Permission` using a unique key and a patch."""
  updatePermissionById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePermissionByIdInput!
  ): UpdatePermissionPayload
  """Updates a single `Plugin` using its globally unique id and a patch."""
  updatePlugin(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePluginInput!
  ): UpdatePluginPayload
  """Updates a single `Plugin` using a unique key and a patch."""
  updatePluginById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdatePluginByIdInput!
  ): UpdatePluginPayload
  """Updates a single `ProductAttribute` using its globally unique id and a patch."""
  updateProductAttribute(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProductAttributeInput!
  ): UpdateProductAttributePayload
  """Updates a single `ProductAttribute` using a unique key and a patch."""
  updateProductAttributeById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProductAttributeByIdInput!
  ): UpdateProductAttributePayload
  """Updates a single `ProductType` using its globally unique id and a patch."""
  updateProductType(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProductTypeInput!
  ): UpdateProductTypePayload
  """Updates a single `ProductType` using a unique key and a patch."""
  updateProductTypeById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProductTypeByIdInput!
  ): UpdateProductTypePayload
  """Updates a single `Product` using its globally unique id and a patch."""
  updateProduct(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProductInput!
  ): UpdateProductPayload
  """Updates a single `Product` using a unique key and a patch."""
  updateProductById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProductByIdInput!
  ): UpdateProductPayload
  """Updates a single `ProjectTemplate` using its globally unique id and a patch."""
  updateProjectTemplate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProjectTemplateInput!
  ): UpdateProjectTemplatePayload
  """Updates a single `ProjectTemplate` using a unique key and a patch."""
  updateProjectTemplateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProjectTemplateByIdInput!
  ): UpdateProjectTemplatePayload
  """Updates a single `Project` using its globally unique id and a patch."""
  updateProject(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProjectInput!
  ): UpdateProjectPayload
  """Updates a single `Project` using a unique key and a patch."""
  updateProjectById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProjectByIdInput!
  ): UpdateProjectPayload
  """Updates a single `Provider` using its globally unique id and a patch."""
  updateProvider(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProviderInput!
  ): UpdateProviderPayload
  """Updates a single `Provider` using a unique key and a patch."""
  updateProviderById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateProviderByIdInput!
  ): UpdateProviderPayload
  """Updates a single `Quote` using its globally unique id and a patch."""
  updateQuote(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateQuoteInput!
  ): UpdateQuotePayload
  """Updates a single `Quote` using a unique key and a patch."""
  updateQuoteById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateQuoteByIdInput!
  ): UpdateQuotePayload
  """Updates a single `Rating` using its globally unique id and a patch."""
  updateRating(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateRatingInput!
  ): UpdateRatingPayload
  """Updates a single `Rating` using a unique key and a patch."""
  updateRatingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateRatingByIdInput!
  ): UpdateRatingPayload
  """Updates a single `Report` using its globally unique id and a patch."""
  updateReport(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateReportInput!
  ): UpdateReportPayload
  """Updates a single `Report` using a unique key and a patch."""
  updateReportById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateReportByIdInput!
  ): UpdateReportPayload
  """Updates a single `Return` using its globally unique id and a patch."""
  updateReturn(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateReturnInput!
  ): UpdateReturnPayload
  """Updates a single `Return` using a unique key and a patch."""
  updateReturnById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateReturnByIdInput!
  ): UpdateReturnPayload
  """Updates a single `Review` using its globally unique id and a patch."""
  updateReview(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateReviewInput!
  ): UpdateReviewPayload
  """Updates a single `Review` using a unique key and a patch."""
  updateReviewById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateReviewByIdInput!
  ): UpdateReviewPayload
  """Updates a single `Reward` using its globally unique id and a patch."""
  updateReward(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateRewardInput!
  ): UpdateRewardPayload
  """Updates a single `Reward` using a unique key and a patch."""
  updateRewardById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateRewardByIdInput!
  ): UpdateRewardPayload
  """Updates a single `Scheduler` using its globally unique id and a patch."""
  updateScheduler(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSchedulerInput!
  ): UpdateSchedulerPayload
  """Updates a single `Scheduler` using a unique key and a patch."""
  updateSchedulerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSchedulerByIdInput!
  ): UpdateSchedulerPayload
  """Updates a single `Segment` using its globally unique id and a patch."""
  updateSegment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSegmentInput!
  ): UpdateSegmentPayload
  """Updates a single `Segment` using a unique key and a patch."""
  updateSegmentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSegmentByIdInput!
  ): UpdateSegmentPayload
  """Updates a single `Settingscustomer` using its globally unique id and a patch."""
  updateSettingscustomer(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingscustomerInput!
  ): UpdateSettingscustomerPayload
  """Updates a single `Settingscustomer` using a unique key and a patch."""
  updateSettingscustomerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingscustomerByIdInput!
  ): UpdateSettingscustomerPayload
  """Updates a single `Settingsgeneral` using its globally unique id and a patch."""
  updateSettingsgeneral(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingsgeneralInput!
  ): UpdateSettingsgeneralPayload
  """Updates a single `Settingsgeneral` using a unique key and a patch."""
  updateSettingsgeneralById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingsgeneralByIdInput!
  ): UpdateSettingsgeneralPayload
  """Updates a single `Settingshop` using its globally unique id and a patch."""
  updateSettingshop(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingshopInput!
  ): UpdateSettingshopPayload
  """Updates a single `Settingshop` using a unique key and a patch."""
  updateSettingshopById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingshopByIdInput!
  ): UpdateSettingshopPayload
  """Updates a single `Settingsmarketing` using its globally unique id and a patch."""
  updateSettingsmarketing(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingsmarketingInput!
  ): UpdateSettingsmarketingPayload
  """Updates a single `Settingsmarketing` using a unique key and a patch."""
  updateSettingsmarketingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingsmarketingByIdInput!
  ): UpdateSettingsmarketingPayload
  """Updates a single `Settingssale` using its globally unique id and a patch."""
  updateSettingssale(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingssaleInput!
  ): UpdateSettingssalePayload
  """Updates a single `Settingssale` using a unique key and a patch."""
  updateSettingssaleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSettingssaleByIdInput!
  ): UpdateSettingssalePayload
  """Updates a single `Shipment` using its globally unique id and a patch."""
  updateShipment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateShipmentInput!
  ): UpdateShipmentPayload
  """Updates a single `Shipment` using a unique key and a patch."""
  updateShipmentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateShipmentByIdInput!
  ): UpdateShipmentPayload
  """Updates a single `ShopSetting` using its globally unique id and a patch."""
  updateShopSetting(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateShopSettingInput!
  ): UpdateShopSettingPayload
  """Updates a single `ShopSetting` using a unique key and a patch."""
  updateShopSettingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateShopSettingByIdInput!
  ): UpdateShopSettingPayload
  """Updates a single `Shop` using its globally unique id and a patch."""
  updateShop(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateShopInput!
  ): UpdateShopPayload
  """Updates a single `Shop` using a unique key and a patch."""
  updateShopById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateShopByIdInput!
  ): UpdateShopPayload
  """Updates a single `SpecialDiscount` using its globally unique id and a patch."""
  updateSpecialDiscount(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSpecialDiscountInput!
  ): UpdateSpecialDiscountPayload
  """Updates a single `SpecialDiscount` using a unique key and a patch."""
  updateSpecialDiscountById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSpecialDiscountByIdInput!
  ): UpdateSpecialDiscountPayload
  """Updates a single `State` using its globally unique id and a patch."""
  updateState(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateStateInput!
  ): UpdateStatePayload
  """Updates a single `State` using a unique key and a patch."""
  updateStateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateStateByIdInput!
  ): UpdateStatePayload
  """Updates a single `Statistic` using its globally unique id and a patch."""
  updateStatistic(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateStatisticInput!
  ): UpdateStatisticPayload
  """Updates a single `Statistic` using a unique key and a patch."""
  updateStatisticById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateStatisticByIdInput!
  ): UpdateStatisticPayload
  """Updates a single `Stock` using its globally unique id and a patch."""
  updateStock(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateStockInput!
  ): UpdateStockPayload
  """Updates a single `Stock` using a unique key and a patch."""
  updateStockById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateStockByIdInput!
  ): UpdateStockPayload
  """Updates a single `Survey` using its globally unique id and a patch."""
  updateSurvey(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSurveyInput!
  ): UpdateSurveyPayload
  """Updates a single `Survey` using a unique key and a patch."""
  updateSurveyById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateSurveyByIdInput!
  ): UpdateSurveyPayload
  """Updates a single `Tag` using its globally unique id and a patch."""
  updateTag(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTagInput!
  ): UpdateTagPayload
  """Updates a single `Tag` using a unique key and a patch."""
  updateTagById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTagByIdInput!
  ): UpdateTagPayload
  """Updates a single `Target` using its globally unique id and a patch."""
  updateTarget(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTargetInput!
  ): UpdateTargetPayload
  """Updates a single `Target` using a unique key and a patch."""
  updateTargetById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTargetByIdInput!
  ): UpdateTargetPayload
  """Updates a single `TaxCategory` using its globally unique id and a patch."""
  updateTaxCategory(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTaxCategoryInput!
  ): UpdateTaxCategoryPayload
  """Updates a single `TaxCategory` using a unique key and a patch."""
  updateTaxCategoryById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTaxCategoryByIdInput!
  ): UpdateTaxCategoryPayload
  """Updates a single `TaxRate` using its globally unique id and a patch."""
  updateTaxRate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTaxRateInput!
  ): UpdateTaxRatePayload
  """Updates a single `TaxRate` using a unique key and a patch."""
  updateTaxRateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTaxRateByIdInput!
  ): UpdateTaxRatePayload
  """Updates a single `TaxRule` using its globally unique id and a patch."""
  updateTaxRule(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTaxRuleInput!
  ): UpdateTaxRulePayload
  """Updates a single `TaxRule` using a unique key and a patch."""
  updateTaxRuleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTaxRuleByIdInput!
  ): UpdateTaxRulePayload
  """Updates a single `Theme` using its globally unique id and a patch."""
  updateTheme(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateThemeInput!
  ): UpdateThemePayload
  """Updates a single `Theme` using a unique key and a patch."""
  updateThemeById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateThemeByIdInput!
  ): UpdateThemePayload
  """Updates a single `Ticketing` using its globally unique id and a patch."""
  updateTicketing(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTicketingInput!
  ): UpdateTicketingPayload
  """Updates a single `Ticketing` using a unique key and a patch."""
  updateTicketingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTicketingByIdInput!
  ): UpdateTicketingPayload
  """Updates a single `TodoList` using its globally unique id and a patch."""
  updateTodoList(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTodoListInput!
  ): UpdateTodoListPayload
  """Updates a single `TodoList` using a unique key and a patch."""
  updateTodoListById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTodoListByIdInput!
  ): UpdateTodoListPayload
  """Updates a single `Training` using its globally unique id and a patch."""
  updateTraining(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTrainingInput!
  ): UpdateTrainingPayload
  """Updates a single `Training` using a unique key and a patch."""
  updateTrainingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTrainingByIdInput!
  ): UpdateTrainingPayload
  """Updates a single `Transaction` using its globally unique id and a patch."""
  updateTransaction(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTransactionInput!
  ): UpdateTransactionPayload
  """Updates a single `Transaction` using a unique key and a patch."""
  updateTransactionById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateTransactionByIdInput!
  ): UpdateTransactionPayload
  """Updates a single `UrlRewrite` using its globally unique id and a patch."""
  updateUrlRewrite(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateUrlRewriteInput!
  ): UpdateUrlRewritePayload
  """Updates a single `UrlRewrite` using a unique key and a patch."""
  updateUrlRewriteById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateUrlRewriteByIdInput!
  ): UpdateUrlRewritePayload
  """Updates a single `UserRole` using its globally unique id and a patch."""
  updateUserRole(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateUserRoleInput!
  ): UpdateUserRolePayload
  """Updates a single `UserRole` using a unique key and a patch."""
  updateUserRoleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateUserRoleByIdInput!
  ): UpdateUserRolePayload
  """Updates a single `User` using its globally unique id and a patch."""
  updateUser(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateUserInput!
  ): UpdateUserPayload
  """Updates a single `User` using a unique key and a patch."""
  updateUserById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateUserByIdInput!
  ): UpdateUserPayload
  """Updates a single `Visit` using its globally unique id and a patch."""
  updateVisit(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateVisitInput!
  ): UpdateVisitPayload
  """Updates a single `Visit` using a unique key and a patch."""
  updateVisitById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateVisitByIdInput!
  ): UpdateVisitPayload
  """Updates a single `Warehouse` using its globally unique id and a patch."""
  updateWarehouse(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWarehouseInput!
  ): UpdateWarehousePayload
  """Updates a single `Warehouse` using a unique key and a patch."""
  updateWarehouseById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWarehouseByIdInput!
  ): UpdateWarehousePayload
  """Updates a single `Webhook` using its globally unique id and a patch."""
  updateWebhook(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWebhookInput!
  ): UpdateWebhookPayload
  """Updates a single `Webhook` using a unique key and a patch."""
  updateWebhookById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWebhookByIdInput!
  ): UpdateWebhookPayload
  """Updates a single `Website` using its globally unique id and a patch."""
  updateWebsite(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWebsiteInput!
  ): UpdateWebsitePayload
  """Updates a single `Website` using a unique key and a patch."""
  updateWebsiteById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWebsiteByIdInput!
  ): UpdateWebsitePayload
  """Updates a single `Wishlist` using its globally unique id and a patch."""
  updateWishlist(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWishlistInput!
  ): UpdateWishlistPayload
  """Updates a single `Wishlist` using a unique key and a patch."""
  updateWishlistById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWishlistByIdInput!
  ): UpdateWishlistPayload
  """Updates a single `Workspace` using its globally unique id and a patch."""
  updateWorkspace(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWorkspaceInput!
  ): UpdateWorkspacePayload
  """Updates a single `Workspace` using a unique key and a patch."""
  updateWorkspaceById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateWorkspaceByIdInput!
  ): UpdateWorkspacePayload
  """Updates a single `Zone` using its globally unique id and a patch."""
  updateZone(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateZoneInput!
  ): UpdateZonePayload
  """Updates a single `Zone` using a unique key and a patch."""
  updateZoneById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: UpdateZoneByIdInput!
  ): UpdateZonePayload
  """Deletes a single `Endofshift` using its globally unique id."""
  deleteEndofshift(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteEndofshiftInput!
  ): DeleteEndofshiftPayload
  """Deletes a single `Endofshift` using a unique key."""
  deleteEndofshiftById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteEndofshiftByIdInput!
  ): DeleteEndofshiftPayload
  """Deletes a single `_Schema` using its globally unique id."""
  deleteSchema(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSchemaInput!
  ): DeleteSchemaPayload
  """Deletes a single `_Schema` using a unique key."""
  deleteSchemaByClassName(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSchemaByClassNameInput!
  ): DeleteSchemaPayload
  """Deletes a single `_PrismaMigration` using its globally unique id."""
  deletePrismaMigration(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePrismaMigrationInput!
  ): DeletePrismaMigrationPayload
  """Deletes a single `_PrismaMigration` using a unique key."""
  deletePrismaMigrationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePrismaMigrationByIdInput!
  ): DeletePrismaMigrationPayload
  """Deletes a single `Account` using its globally unique id."""
  deleteAccount(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteAccountInput!
  ): DeleteAccountPayload
  """Deletes a single `Account` using a unique key."""
  deleteAccountById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteAccountByIdInput!
  ): DeleteAccountPayload
  """Deletes a single `Agreement` using its globally unique id."""
  deleteAgreement(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteAgreementInput!
  ): DeleteAgreementPayload
  """Deletes a single `Agreement` using a unique key."""
  deleteAgreementById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteAgreementByIdInput!
  ): DeleteAgreementPayload
  """Deletes a single `Analytic` using its globally unique id."""
  deleteAnalytic(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteAnalyticInput!
  ): DeleteAnalyticPayload
  """Deletes a single `Analytic` using a unique key."""
  deleteAnalyticById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteAnalyticByIdInput!
  ): DeleteAnalyticPayload
  """Deletes a single `Apitoken` using its globally unique id."""
  deleteApitoken(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteApitokenInput!
  ): DeleteApitokenPayload
  """Deletes a single `Apitoken` using a unique key."""
  deleteApitokenById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteApitokenByIdInput!
  ): DeleteApitokenPayload
  """Deletes a single `Article` using its globally unique id."""
  deleteArticle(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteArticleInput!
  ): DeleteArticlePayload
  """Deletes a single `Article` using a unique key."""
  deleteArticleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteArticleByIdInput!
  ): DeleteArticlePayload
  """Deletes a single `Brand` using its globally unique id."""
  deleteBrand(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteBrandInput!
  ): DeleteBrandPayload
  """Deletes a single `Brand` using a unique key."""
  deleteBrandById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteBrandByIdInput!
  ): DeleteBrandPayload
  """Deletes a single `CartPriceRule` using its globally unique id."""
  deleteCartPriceRule(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCartPriceRuleInput!
  ): DeleteCartPriceRulePayload
  """Deletes a single `CartPriceRule` using a unique key."""
  deleteCartPriceRuleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCartPriceRuleByIdInput!
  ): DeleteCartPriceRulePayload
  """Deletes a single `Case` using its globally unique id."""
  deleteCase(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCaseInput!
  ): DeleteCasePayload
  """Deletes a single `Case` using a unique key."""
  deleteCaseById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCaseByIdInput!
  ): DeleteCasePayload
  """Deletes a single `CatalogPriceRule` using its globally unique id."""
  deleteCatalogPriceRule(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCatalogPriceRuleInput!
  ): DeleteCatalogPriceRulePayload
  """Deletes a single `CatalogPriceRule` using a unique key."""
  deleteCatalogPriceRuleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCatalogPriceRuleByIdInput!
  ): DeleteCatalogPriceRulePayload
  """Deletes a single `Category` using its globally unique id."""
  deleteCategory(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCategoryInput!
  ): DeleteCategoryPayload
  """Deletes a single `Category` using a unique key."""
  deleteCategoryById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCategoryByIdInput!
  ): DeleteCategoryPayload
  """Deletes a single `Channel` using its globally unique id."""
  deleteChannel(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteChannelInput!
  ): DeleteChannelPayload
  """Deletes a single `Channel` using a unique key."""
  deleteChannelById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteChannelByIdInput!
  ): DeleteChannelPayload
  """Deletes a single `Checklist` using its globally unique id."""
  deleteChecklist(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteChecklistInput!
  ): DeleteChecklistPayload
  """Deletes a single `Checklist` using a unique key."""
  deleteChecklistById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteChecklistByIdInput!
  ): DeleteChecklistPayload
  """Deletes a single `City` using its globally unique id."""
  deleteCity(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCityInput!
  ): DeleteCityPayload
  """Deletes a single `City` using a unique key."""
  deleteCityById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCityByIdInput!
  ): DeleteCityPayload
  """Deletes a single `Collection` using its globally unique id."""
  deleteCollection(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCollectionInput!
  ): DeleteCollectionPayload
  """Deletes a single `Collection` using a unique key."""
  deleteCollectionById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCollectionByIdInput!
  ): DeleteCollectionPayload
  """Deletes a single `Comment` using its globally unique id."""
  deleteComment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCommentInput!
  ): DeleteCommentPayload
  """Deletes a single `Comment` using a unique key."""
  deleteCommentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCommentByIdInput!
  ): DeleteCommentPayload
  """Deletes a single `ContentType` using its globally unique id."""
  deleteContentType(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteContentTypeInput!
  ): DeleteContentTypePayload
  """Deletes a single `ContentType` using a unique key."""
  deleteContentTypeById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteContentTypeByIdInput!
  ): DeleteContentTypePayload
  """Deletes a single `Contract` using its globally unique id."""
  deleteContract(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteContractInput!
  ): DeleteContractPayload
  """Deletes a single `Contract` using a unique key."""
  deleteContractById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteContractByIdInput!
  ): DeleteContractPayload
  """Deletes a single `Country` using its globally unique id."""
  deleteCountry(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCountryInput!
  ): DeleteCountryPayload
  """Deletes a single `Country` using a unique key."""
  deleteCountryById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCountryByIdInput!
  ): DeleteCountryPayload
  """Deletes a single `Coupon` using its globally unique id."""
  deleteCoupon(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCouponInput!
  ): DeleteCouponPayload
  """Deletes a single `Coupon` using a unique key."""
  deleteCouponById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCouponByIdInput!
  ): DeleteCouponPayload
  """Deletes a single `CreditMemo` using its globally unique id."""
  deleteCreditMemo(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCreditMemoInput!
  ): DeleteCreditMemoPayload
  """Deletes a single `CreditMemo` using a unique key."""
  deleteCreditMemoByCreditMemoAndId(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCreditMemoByCreditMemoAndIdInput!
  ): DeleteCreditMemoPayload
  """Deletes a single `Currency` using its globally unique id."""
  deleteCurrency(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCurrencyInput!
  ): DeleteCurrencyPayload
  """Deletes a single `Currency` using a unique key."""
  deleteCurrencyById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCurrencyByIdInput!
  ): DeleteCurrencyPayload
  """Deletes a single `CurrencyRate` using its globally unique id."""
  deleteCurrencyRate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCurrencyRateInput!
  ): DeleteCurrencyRatePayload
  """Deletes a single `CurrencyRate` using a unique key."""
  deleteCurrencyRateByImportService(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCurrencyRateByImportServiceInput!
  ): DeleteCurrencyRatePayload
  """Deletes a single `CurrencyRate` using a unique key."""
  deleteCurrencyRateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCurrencyRateByIdInput!
  ): DeleteCurrencyRatePayload
  """Deletes a single `CurrencySymbol` using its globally unique id."""
  deleteCurrencySymbol(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCurrencySymbolInput!
  ): DeleteCurrencySymbolPayload
  """Deletes a single `CurrencySymbol` using a unique key."""
  deleteCurrencySymbolBySymbol(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCurrencySymbolBySymbolInput!
  ): DeleteCurrencySymbolPayload
  """Deletes a single `CurrencySymbol` using a unique key."""
  deleteCurrencySymbolById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCurrencySymbolByIdInput!
  ): DeleteCurrencySymbolPayload
  """Deletes a single `CustomerGroup` using its globally unique id."""
  deleteCustomerGroup(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCustomerGroupInput!
  ): DeleteCustomerGroupPayload
  """Deletes a single `CustomerGroup` using a unique key."""
  deleteCustomerGroupById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCustomerGroupByIdInput!
  ): DeleteCustomerGroupPayload
  """Deletes a single `CustomerPayment` using its globally unique id."""
  deleteCustomerPayment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCustomerPaymentInput!
  ): DeleteCustomerPaymentPayload
  """Deletes a single `CustomerPayment` using a unique key."""
  deleteCustomerPaymentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCustomerPaymentByIdInput!
  ): DeleteCustomerPaymentPayload
  """Deletes a single `Customer` using its globally unique id."""
  deleteCustomer(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCustomerInput!
  ): DeleteCustomerPayload
  """Deletes a single `Customer` using a unique key."""
  deleteCustomerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCustomerByIdInput!
  ): DeleteCustomerPayload
  """Deletes a single `Customization` using its globally unique id."""
  deleteCustomization(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCustomizationInput!
  ): DeleteCustomizationPayload
  """Deletes a single `Customization` using a unique key."""
  deleteCustomizationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteCustomizationByIdInput!
  ): DeleteCustomizationPayload
  """Deletes a single `Dashboard` using its globally unique id."""
  deleteDashboard(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteDashboardInput!
  ): DeleteDashboardPayload
  """Deletes a single `Dashboard` using a unique key."""
  deleteDashboardById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteDashboardByIdInput!
  ): DeleteDashboardPayload
  """Deletes a single `Deepdive` using its globally unique id."""
  deleteDeepdive(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteDeepdiveInput!
  ): DeleteDeepdivePayload
  """Deletes a single `Deepdive` using a unique key."""
  deleteDeepdiveById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteDeepdiveByIdInput!
  ): DeleteDeepdivePayload
  """Deletes a single `EmailTemplate` using its globally unique id."""
  deleteEmailTemplate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteEmailTemplateInput!
  ): DeleteEmailTemplatePayload
  """Deletes a single `EmailTemplate` using a unique key."""
  deleteEmailTemplateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteEmailTemplateByIdInput!
  ): DeleteEmailTemplatePayload
  """Deletes a single `Email` using its globally unique id."""
  deleteEmail(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteEmailInput!
  ): DeleteEmailPayload
  """Deletes a single `Email` using a unique key."""
  deleteEmailById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteEmailByIdInput!
  ): DeleteEmailPayload
  """Deletes a single `Event` using its globally unique id."""
  deleteEvent(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteEventInput!
  ): DeleteEventPayload
  """Deletes a single `Event` using a unique key."""
  deleteEventById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteEventByIdInput!
  ): DeleteEventPayload
  """Deletes a single `Fullfillment` using its globally unique id."""
  deleteFullfillment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteFullfillmentInput!
  ): DeleteFullfillmentPayload
  """Deletes a single `Fullfillment` using a unique key."""
  deleteFullfillmentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteFullfillmentByIdInput!
  ): DeleteFullfillmentPayload
  """Deletes a single `GeneralSetting` using its globally unique id."""
  deleteGeneralSetting(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteGeneralSettingInput!
  ): DeleteGeneralSettingPayload
  """Deletes a single `GeneralSetting` using a unique key."""
  deleteGeneralSettingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteGeneralSettingByIdInput!
  ): DeleteGeneralSettingPayload
  """Deletes a single `GiftCertificate` using its globally unique id."""
  deleteGiftCertificate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteGiftCertificateInput!
  ): DeleteGiftCertificatePayload
  """Deletes a single `GiftCertificate` using a unique key."""
  deleteGiftCertificateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteGiftCertificateByIdInput!
  ): DeleteGiftCertificatePayload
  """Deletes a single `Glossary` using its globally unique id."""
  deleteGlossary(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteGlossaryInput!
  ): DeleteGlossaryPayload
  """Deletes a single `Glossary` using a unique key."""
  deleteGlossaryById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteGlossaryByIdInput!
  ): DeleteGlossaryPayload
  """Deletes a single `Importm` using its globally unique id."""
  deleteImportm(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteImportmInput!
  ): DeleteImportmPayload
  """Deletes a single `Importm` using a unique key."""
  deleteImportmById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteImportmByIdInput!
  ): DeleteImportmPayload
  """Deletes a single `Integration` using its globally unique id."""
  deleteIntegration(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteIntegrationInput!
  ): DeleteIntegrationPayload
  """Deletes a single `Integration` using a unique key."""
  deleteIntegrationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteIntegrationByIdInput!
  ): DeleteIntegrationPayload
  """Deletes a single `Internalization` using its globally unique id."""
  deleteInternalization(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteInternalizationInput!
  ): DeleteInternalizationPayload
  """Deletes a single `Internalization` using a unique key."""
  deleteInternalizationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteInternalizationByIdInput!
  ): DeleteInternalizationPayload
  """Deletes a single `Invitation` using its globally unique id."""
  deleteInvitation(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteInvitationInput!
  ): DeleteInvitationPayload
  """Deletes a single `Invitation` using a unique key."""
  deleteInvitationById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteInvitationByIdInput!
  ): DeleteInvitationPayload
  """Deletes a single `Invoice` using its globally unique id."""
  deleteInvoice(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteInvoiceInput!
  ): DeleteInvoicePayload
  """Deletes a single `Invoice` using a unique key."""
  deleteInvoiceById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteInvoiceByIdInput!
  ): DeleteInvoicePayload
  """Deletes a single `Knowledgebase` using its globally unique id."""
  deleteKnowledgebase(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteKnowledgebaseInput!
  ): DeleteKnowledgebasePayload
  """Deletes a single `Knowledgebase` using a unique key."""
  deleteKnowledgebaseById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteKnowledgebaseByIdInput!
  ): DeleteKnowledgebasePayload
  """Deletes a single `Lead` using its globally unique id."""
  deleteLead(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteLeadInput!
  ): DeleteLeadPayload
  """Deletes a single `Lead` using a unique key."""
  deleteLeadById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteLeadByIdInput!
  ): DeleteLeadPayload
  """Deletes a single `Manufacturer` using its globally unique id."""
  deleteManufacturer(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteManufacturerInput!
  ): DeleteManufacturerPayload
  """Deletes a single `Manufacturer` using a unique key."""
  deleteManufacturerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteManufacturerByIdInput!
  ): DeleteManufacturerPayload
  """Deletes a single `Mediamanager` using its globally unique id."""
  deleteMediamanager(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteMediamanagerInput!
  ): DeleteMediamanagerPayload
  """Deletes a single `Mediamanager` using a unique key."""
  deleteMediamanagerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteMediamanagerByIdInput!
  ): DeleteMediamanagerPayload
  """Deletes a single `Meeting` using its globally unique id."""
  deleteMeeting(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteMeetingInput!
  ): DeleteMeetingPayload
  """Deletes a single `Meeting` using a unique key."""
  deleteMeetingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteMeetingByIdInput!
  ): DeleteMeetingPayload
  """Deletes a single `Message` using its globally unique id."""
  deleteMessage(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteMessageInput!
  ): DeleteMessagePayload
  """Deletes a single `Message` using a unique key."""
  deleteMessageById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteMessageByIdInput!
  ): DeleteMessagePayload
  """Deletes a single `NewsletterSubscriber` using its globally unique id."""
  deleteNewsletterSubscriber(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteNewsletterSubscriberInput!
  ): DeleteNewsletterSubscriberPayload
  """Deletes a single `NewsletterSubscriber` using a unique key."""
  deleteNewsletterSubscriberById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteNewsletterSubscriberByIdInput!
  ): DeleteNewsletterSubscriberPayload
  """Deletes a single `Occassion` using its globally unique id."""
  deleteOccassion(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteOccassionInput!
  ): DeleteOccassionPayload
  """Deletes a single `Occassion` using a unique key."""
  deleteOccassionById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteOccassionByIdInput!
  ): DeleteOccassionPayload
  """Deletes a single `Ooto` using its globally unique id."""
  deleteOoto(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteOotoInput!
  ): DeleteOotoPayload
  """Deletes a single `Ooto` using a unique key."""
  deleteOotoById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteOotoByIdInput!
  ): DeleteOotoPayload
  """Deletes a single `Opportunity` using its globally unique id."""
  deleteOpportunity(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteOpportunityInput!
  ): DeleteOpportunityPayload
  """Deletes a single `Opportunity` using a unique key."""
  deleteOpportunityById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteOpportunityByIdInput!
  ): DeleteOpportunityPayload
  """Deletes a single `Order` using its globally unique id."""
  deleteOrder(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteOrderInput!
  ): DeleteOrderPayload
  """Deletes a single `Order` using a unique key."""
  deleteOrderById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteOrderByIdInput!
  ): DeleteOrderPayload
  """Deletes a single `Page` using its globally unique id."""
  deletePage(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePageInput!
  ): DeletePagePayload
  """Deletes a single `Page` using a unique key."""
  deletePageById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePageByIdInput!
  ): DeletePagePayload
  """Deletes a single `Partner` using its globally unique id."""
  deletePartner(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePartnerInput!
  ): DeletePartnerPayload
  """Deletes a single `Partner` using a unique key."""
  deletePartnerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePartnerByIdInput!
  ): DeletePartnerPayload
  """Deletes a single `Payment` using its globally unique id."""
  deletePayment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePaymentInput!
  ): DeletePaymentPayload
  """Deletes a single `Payment` using a unique key."""
  deletePaymentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePaymentByIdInput!
  ): DeletePaymentPayload
  """Deletes a single `PdfTemplate` using its globally unique id."""
  deletePdfTemplate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePdfTemplateInput!
  ): DeletePdfTemplatePayload
  """Deletes a single `PdfTemplate` using a unique key."""
  deletePdfTemplateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePdfTemplateByIdInput!
  ): DeletePdfTemplatePayload
  """Deletes a single `Permission` using its globally unique id."""
  deletePermission(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePermissionInput!
  ): DeletePermissionPayload
  """Deletes a single `Permission` using a unique key."""
  deletePermissionById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePermissionByIdInput!
  ): DeletePermissionPayload
  """Deletes a single `Plugin` using its globally unique id."""
  deletePlugin(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePluginInput!
  ): DeletePluginPayload
  """Deletes a single `Plugin` using a unique key."""
  deletePluginById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeletePluginByIdInput!
  ): DeletePluginPayload
  """Deletes a single `ProductAttribute` using its globally unique id."""
  deleteProductAttribute(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProductAttributeInput!
  ): DeleteProductAttributePayload
  """Deletes a single `ProductAttribute` using a unique key."""
  deleteProductAttributeById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProductAttributeByIdInput!
  ): DeleteProductAttributePayload
  """Deletes a single `ProductType` using its globally unique id."""
  deleteProductType(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProductTypeInput!
  ): DeleteProductTypePayload
  """Deletes a single `ProductType` using a unique key."""
  deleteProductTypeById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProductTypeByIdInput!
  ): DeleteProductTypePayload
  """Deletes a single `Product` using its globally unique id."""
  deleteProduct(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProductInput!
  ): DeleteProductPayload
  """Deletes a single `Product` using a unique key."""
  deleteProductById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProductByIdInput!
  ): DeleteProductPayload
  """Deletes a single `ProjectTemplate` using its globally unique id."""
  deleteProjectTemplate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProjectTemplateInput!
  ): DeleteProjectTemplatePayload
  """Deletes a single `ProjectTemplate` using a unique key."""
  deleteProjectTemplateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProjectTemplateByIdInput!
  ): DeleteProjectTemplatePayload
  """Deletes a single `Project` using its globally unique id."""
  deleteProject(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProjectInput!
  ): DeleteProjectPayload
  """Deletes a single `Project` using a unique key."""
  deleteProjectById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProjectByIdInput!
  ): DeleteProjectPayload
  """Deletes a single `Provider` using its globally unique id."""
  deleteProvider(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProviderInput!
  ): DeleteProviderPayload
  """Deletes a single `Provider` using a unique key."""
  deleteProviderById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteProviderByIdInput!
  ): DeleteProviderPayload
  """Deletes a single `Quote` using its globally unique id."""
  deleteQuote(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteQuoteInput!
  ): DeleteQuotePayload
  """Deletes a single `Quote` using a unique key."""
  deleteQuoteById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteQuoteByIdInput!
  ): DeleteQuotePayload
  """Deletes a single `Rating` using its globally unique id."""
  deleteRating(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteRatingInput!
  ): DeleteRatingPayload
  """Deletes a single `Rating` using a unique key."""
  deleteRatingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteRatingByIdInput!
  ): DeleteRatingPayload
  """Deletes a single `Report` using its globally unique id."""
  deleteReport(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteReportInput!
  ): DeleteReportPayload
  """Deletes a single `Report` using a unique key."""
  deleteReportById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteReportByIdInput!
  ): DeleteReportPayload
  """Deletes a single `Return` using its globally unique id."""
  deleteReturn(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteReturnInput!
  ): DeleteReturnPayload
  """Deletes a single `Return` using a unique key."""
  deleteReturnById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteReturnByIdInput!
  ): DeleteReturnPayload
  """Deletes a single `Review` using its globally unique id."""
  deleteReview(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteReviewInput!
  ): DeleteReviewPayload
  """Deletes a single `Review` using a unique key."""
  deleteReviewById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteReviewByIdInput!
  ): DeleteReviewPayload
  """Deletes a single `Reward` using its globally unique id."""
  deleteReward(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteRewardInput!
  ): DeleteRewardPayload
  """Deletes a single `Reward` using a unique key."""
  deleteRewardById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteRewardByIdInput!
  ): DeleteRewardPayload
  """Deletes a single `Scheduler` using its globally unique id."""
  deleteScheduler(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSchedulerInput!
  ): DeleteSchedulerPayload
  """Deletes a single `Scheduler` using a unique key."""
  deleteSchedulerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSchedulerByIdInput!
  ): DeleteSchedulerPayload
  """Deletes a single `Segment` using its globally unique id."""
  deleteSegment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSegmentInput!
  ): DeleteSegmentPayload
  """Deletes a single `Segment` using a unique key."""
  deleteSegmentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSegmentByIdInput!
  ): DeleteSegmentPayload
  """Deletes a single `Settingscustomer` using its globally unique id."""
  deleteSettingscustomer(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingscustomerInput!
  ): DeleteSettingscustomerPayload
  """Deletes a single `Settingscustomer` using a unique key."""
  deleteSettingscustomerById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingscustomerByIdInput!
  ): DeleteSettingscustomerPayload
  """Deletes a single `Settingsgeneral` using its globally unique id."""
  deleteSettingsgeneral(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingsgeneralInput!
  ): DeleteSettingsgeneralPayload
  """Deletes a single `Settingsgeneral` using a unique key."""
  deleteSettingsgeneralById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingsgeneralByIdInput!
  ): DeleteSettingsgeneralPayload
  """Deletes a single `Settingshop` using its globally unique id."""
  deleteSettingshop(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingshopInput!
  ): DeleteSettingshopPayload
  """Deletes a single `Settingshop` using a unique key."""
  deleteSettingshopById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingshopByIdInput!
  ): DeleteSettingshopPayload
  """Deletes a single `Settingsmarketing` using its globally unique id."""
  deleteSettingsmarketing(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingsmarketingInput!
  ): DeleteSettingsmarketingPayload
  """Deletes a single `Settingsmarketing` using a unique key."""
  deleteSettingsmarketingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingsmarketingByIdInput!
  ): DeleteSettingsmarketingPayload
  """Deletes a single `Settingssale` using its globally unique id."""
  deleteSettingssale(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingssaleInput!
  ): DeleteSettingssalePayload
  """Deletes a single `Settingssale` using a unique key."""
  deleteSettingssaleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSettingssaleByIdInput!
  ): DeleteSettingssalePayload
  """Deletes a single `Shipment` using its globally unique id."""
  deleteShipment(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteShipmentInput!
  ): DeleteShipmentPayload
  """Deletes a single `Shipment` using a unique key."""
  deleteShipmentById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteShipmentByIdInput!
  ): DeleteShipmentPayload
  """Deletes a single `ShopSetting` using its globally unique id."""
  deleteShopSetting(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteShopSettingInput!
  ): DeleteShopSettingPayload
  """Deletes a single `ShopSetting` using a unique key."""
  deleteShopSettingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteShopSettingByIdInput!
  ): DeleteShopSettingPayload
  """Deletes a single `Shop` using its globally unique id."""
  deleteShop(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteShopInput!
  ): DeleteShopPayload
  """Deletes a single `Shop` using a unique key."""
  deleteShopById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteShopByIdInput!
  ): DeleteShopPayload
  """Deletes a single `SpecialDiscount` using its globally unique id."""
  deleteSpecialDiscount(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSpecialDiscountInput!
  ): DeleteSpecialDiscountPayload
  """Deletes a single `SpecialDiscount` using a unique key."""
  deleteSpecialDiscountById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSpecialDiscountByIdInput!
  ): DeleteSpecialDiscountPayload
  """Deletes a single `State` using its globally unique id."""
  deleteState(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteStateInput!
  ): DeleteStatePayload
  """Deletes a single `State` using a unique key."""
  deleteStateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteStateByIdInput!
  ): DeleteStatePayload
  """Deletes a single `Statistic` using its globally unique id."""
  deleteStatistic(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteStatisticInput!
  ): DeleteStatisticPayload
  """Deletes a single `Statistic` using a unique key."""
  deleteStatisticById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteStatisticByIdInput!
  ): DeleteStatisticPayload
  """Deletes a single `Stock` using its globally unique id."""
  deleteStock(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteStockInput!
  ): DeleteStockPayload
  """Deletes a single `Stock` using a unique key."""
  deleteStockById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteStockByIdInput!
  ): DeleteStockPayload
  """Deletes a single `Survey` using its globally unique id."""
  deleteSurvey(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSurveyInput!
  ): DeleteSurveyPayload
  """Deletes a single `Survey` using a unique key."""
  deleteSurveyById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteSurveyByIdInput!
  ): DeleteSurveyPayload
  """Deletes a single `Tag` using its globally unique id."""
  deleteTag(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTagInput!
  ): DeleteTagPayload
  """Deletes a single `Tag` using a unique key."""
  deleteTagById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTagByIdInput!
  ): DeleteTagPayload
  """Deletes a single `Target` using its globally unique id."""
  deleteTarget(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTargetInput!
  ): DeleteTargetPayload
  """Deletes a single `Target` using a unique key."""
  deleteTargetById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTargetByIdInput!
  ): DeleteTargetPayload
  """Deletes a single `TaxCategory` using its globally unique id."""
  deleteTaxCategory(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTaxCategoryInput!
  ): DeleteTaxCategoryPayload
  """Deletes a single `TaxCategory` using a unique key."""
  deleteTaxCategoryById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTaxCategoryByIdInput!
  ): DeleteTaxCategoryPayload
  """Deletes a single `TaxRate` using its globally unique id."""
  deleteTaxRate(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTaxRateInput!
  ): DeleteTaxRatePayload
  """Deletes a single `TaxRate` using a unique key."""
  deleteTaxRateById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTaxRateByIdInput!
  ): DeleteTaxRatePayload
  """Deletes a single `TaxRule` using its globally unique id."""
  deleteTaxRule(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTaxRuleInput!
  ): DeleteTaxRulePayload
  """Deletes a single `TaxRule` using a unique key."""
  deleteTaxRuleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTaxRuleByIdInput!
  ): DeleteTaxRulePayload
  """Deletes a single `Theme` using its globally unique id."""
  deleteTheme(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteThemeInput!
  ): DeleteThemePayload
  """Deletes a single `Theme` using a unique key."""
  deleteThemeById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteThemeByIdInput!
  ): DeleteThemePayload
  """Deletes a single `Ticketing` using its globally unique id."""
  deleteTicketing(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTicketingInput!
  ): DeleteTicketingPayload
  """Deletes a single `Ticketing` using a unique key."""
  deleteTicketingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTicketingByIdInput!
  ): DeleteTicketingPayload
  """Deletes a single `TodoList` using its globally unique id."""
  deleteTodoList(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTodoListInput!
  ): DeleteTodoListPayload
  """Deletes a single `TodoList` using a unique key."""
  deleteTodoListById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTodoListByIdInput!
  ): DeleteTodoListPayload
  """Deletes a single `Training` using its globally unique id."""
  deleteTraining(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTrainingInput!
  ): DeleteTrainingPayload
  """Deletes a single `Training` using a unique key."""
  deleteTrainingById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTrainingByIdInput!
  ): DeleteTrainingPayload
  """Deletes a single `Transaction` using its globally unique id."""
  deleteTransaction(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTransactionInput!
  ): DeleteTransactionPayload
  """Deletes a single `Transaction` using a unique key."""
  deleteTransactionById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteTransactionByIdInput!
  ): DeleteTransactionPayload
  """Deletes a single `UrlRewrite` using its globally unique id."""
  deleteUrlRewrite(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteUrlRewriteInput!
  ): DeleteUrlRewritePayload
  """Deletes a single `UrlRewrite` using a unique key."""
  deleteUrlRewriteById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteUrlRewriteByIdInput!
  ): DeleteUrlRewritePayload
  """Deletes a single `UserRole` using its globally unique id."""
  deleteUserRole(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteUserRoleInput!
  ): DeleteUserRolePayload
  """Deletes a single `UserRole` using a unique key."""
  deleteUserRoleById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteUserRoleByIdInput!
  ): DeleteUserRolePayload
  """Deletes a single `User` using its globally unique id."""
  deleteUser(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteUserInput!
  ): DeleteUserPayload
  """Deletes a single `User` using a unique key."""
  deleteUserById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteUserByIdInput!
  ): DeleteUserPayload
  """Deletes a single `Visit` using its globally unique id."""
  deleteVisit(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteVisitInput!
  ): DeleteVisitPayload
  """Deletes a single `Visit` using a unique key."""
  deleteVisitById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteVisitByIdInput!
  ): DeleteVisitPayload
  """Deletes a single `Warehouse` using its globally unique id."""
  deleteWarehouse(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWarehouseInput!
  ): DeleteWarehousePayload
  """Deletes a single `Warehouse` using a unique key."""
  deleteWarehouseById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWarehouseByIdInput!
  ): DeleteWarehousePayload
  """Deletes a single `Webhook` using its globally unique id."""
  deleteWebhook(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWebhookInput!
  ): DeleteWebhookPayload
  """Deletes a single `Webhook` using a unique key."""
  deleteWebhookById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWebhookByIdInput!
  ): DeleteWebhookPayload
  """Deletes a single `Website` using its globally unique id."""
  deleteWebsite(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWebsiteInput!
  ): DeleteWebsitePayload
  """Deletes a single `Website` using a unique key."""
  deleteWebsiteById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWebsiteByIdInput!
  ): DeleteWebsitePayload
  """Deletes a single `Wishlist` using its globally unique id."""
  deleteWishlist(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWishlistInput!
  ): DeleteWishlistPayload
  """Deletes a single `Wishlist` using a unique key."""
  deleteWishlistById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWishlistByIdInput!
  ): DeleteWishlistPayload
  """Deletes a single `Workspace` using its globally unique id."""
  deleteWorkspace(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWorkspaceInput!
  ): DeleteWorkspacePayload
  """Deletes a single `Workspace` using a unique key."""
  deleteWorkspaceById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteWorkspaceByIdInput!
  ): DeleteWorkspacePayload
  """Deletes a single `Zone` using its globally unique id."""
  deleteZone(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteZoneInput!
  ): DeleteZonePayload
  """Deletes a single `Zone` using a unique key."""
  deleteZoneById(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: DeleteZoneByIdInput!
  ): DeleteZonePayload
  idempotencyDeleteExpiredRecords(
    """The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."""
    input: IdempotencyDeleteExpiredRecordsInput!
  ): IdempotencyDeleteExpiredRecordsPayload
}

"""The output of our create `Endofshift` mutation."""
type CreateEndofshiftPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Endofshift` that was created by this mutation."""
  endofshift: Endofshift
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Endofshift`. May be used by Relay 1."""
  endofshiftEdge(
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EndofshiftsEdge
}

"""All input for the create `Endofshift` mutation."""
input CreateEndofshiftInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Endofshift` to be created by this mutation."""
  endofshift: EndofshiftInput!
}

"""An input for mutations affecting `Endofshift`"""
input EndofshiftInput {
  id: BigInt
  createdAt: Datetime
  content: String
  login: String
  mcms: String
  nextShift: String
  projects: String
  tickets: String
  whid: String
}

"""The output of our create `_Schema` mutation."""
type CreateSchemaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `_Schema` that was created by this mutation."""
  _schema: _Schema
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `_Schema`. May be used by Relay 1."""
  _schemaEdge(
    """The method to use when ordering `_Schema`."""
    orderBy: [_SchemasOrderBy!] = [PRIMARY_KEY_ASC]
  ): _SchemasEdge
}

"""All input for the create `_Schema` mutation."""
input CreateSchemaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `_Schema` to be created by this mutation."""
  _schema: _SchemaInput!
}

"""An input for mutations affecting `_Schema`"""
input _SchemaInput {
  className: String!
  schema: JSON
  isParseClass: Boolean
}

"""The output of our create `_PrismaMigration` mutation."""
type CreatePrismaMigrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `_PrismaMigration` that was created by this mutation."""
  _prismaMigration: _PrismaMigration
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `_PrismaMigration`. May be used by Relay 1."""
  _prismaMigrationEdge(
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): _PrismaMigrationsEdge
}

"""All input for the create `_PrismaMigration` mutation."""
input CreatePrismaMigrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `_PrismaMigration` to be created by this mutation."""
  _prismaMigration: _PrismaMigrationInput!
}

"""An input for mutations affecting `_PrismaMigration`"""
input _PrismaMigrationInput {
  id: String!
  checksum: String!
  finishedAt: Datetime
  migrationName: String!
  logs: String
  rolledBackAt: Datetime
  startedAt: Datetime
  appliedStepsCount: Int
}

"""The output of our create `Account` mutation."""
type CreateAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Account` that was created by this mutation."""
  account: Account
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Account`. May be used by Relay 1."""
  accountEdge(
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge
}

"""All input for the create `Account` mutation."""
input CreateAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Account` to be created by this mutation."""
  account: AccountInput!
}

"""An input for mutations affecting `Account`"""
input AccountInput {
  id: BigInt
  createdAt: Datetime
  name: String
  website: String
  officePhone: String
  fax: String
  email: String
  address: String
  postalcode: String
  city: String
  state: String
  country: String
  assignedTo: String
  altAddress: String
  altPostalcode: String
  altCity: String
  altState: String
  altCountry: String
  type: String
  industry: String
  employees: String
  annualRevenue: String
  memberOf: String
  campaign: String
}

"""The output of our create `Agreement` mutation."""
type CreateAgreementPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Agreement` that was created by this mutation."""
  agreement: Agreement
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Agreement`. May be used by Relay 1."""
  agreementEdge(
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgreementsEdge
}

"""All input for the create `Agreement` mutation."""
input CreateAgreementInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Agreement` to be created by this mutation."""
  agreement: AgreementInput!
}

"""An input for mutations affecting `Agreement`"""
input AgreementInput {
  id: BigInt
  referenceId: String!
  created: Datetime
  updated: Datetime
  content: String
  name: String
  image: String
  excerpt: String
  type: String
  userId: String!
  shopId: String!
}

"""The output of our create `Analytic` mutation."""
type CreateAnalyticPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Analytic` that was created by this mutation."""
  analytic: Analytic
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Analytic`. May be used by Relay 1."""
  analyticEdge(
    """The method to use when ordering `Analytic`."""
    orderBy: [AnalyticsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnalyticsEdge
}

"""All input for the create `Analytic` mutation."""
input CreateAnalyticInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Analytic` to be created by this mutation."""
  analytic: AnalyticInput!
}

"""An input for mutations affecting `Analytic`"""
input AnalyticInput {
  id: BigInt
  createdAt: Datetime
  name: String
  country: String
  shareData: String
  websiteName: String
  clientId: String
  clientSecret: String
  trackingId: String
  propertyName: String
  url: String
  defaultView: String
  category: String
  propertyHit: String
  trackingCode: String
  dataCollection: Boolean
  dataRetention: Boolean
  searchAnalytics: String
}

"""The output of our create `Apitoken` mutation."""
type CreateApitokenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Apitoken` that was created by this mutation."""
  apitoken: Apitoken
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Apitoken`. May be used by Relay 1."""
  apitokenEdge(
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): ApitokensEdge
}

"""All input for the create `Apitoken` mutation."""
input CreateApitokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Apitoken` to be created by this mutation."""
  apitoken: ApitokenInput!
}

"""An input for mutations affecting `Apitoken`"""
input ApitokenInput {
  id: BigInt
  createdAt: Datetime
  name: String!
  tokenType: String
  description: String
  token: BigInt!
}

"""The output of our create `Article` mutation."""
type CreateArticlePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Article` that was created by this mutation."""
  article: Article
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Article`. May be used by Relay 1."""
  articleEdge(
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArticlesEdge
}

"""All input for the create `Article` mutation."""
input CreateArticleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Article` to be created by this mutation."""
  article: ArticleInput!
}

"""An input for mutations affecting `Article`"""
input ArticleInput {
  id: Int
  name: String!
  excerpt: String!
  content: String
  image: String
  categories: String
  customers: String
  users: String
  published: String
  custId: Int
  isPublic: String
  metaDescription: String
  metaName: String
  metaUrl: String
  tags: String
}

"""The output of our create `Brand` mutation."""
type CreateBrandPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Brand` that was created by this mutation."""
  brand: Brand
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Brand`."""
  productByProduct: Product
  """An edge for our `Brand`. May be used by Relay 1."""
  brandEdge(
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BrandsEdge
}

"""All input for the create `Brand` mutation."""
input CreateBrandInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Brand` to be created by this mutation."""
  brand: BrandInput!
}

"""An input for mutations affecting `Brand`"""
input BrandInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
}

"""The output of our create `CartPriceRule` mutation."""
type CreateCartPriceRulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CartPriceRule` that was created by this mutation."""
  cartPriceRule: CartPriceRule
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CartPriceRule`. May be used by Relay 1."""
  cartPriceRuleEdge(
    """The method to use when ordering `CartPriceRule`."""
    orderBy: [CartPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CartPriceRulesEdge
}

"""All input for the create `CartPriceRule` mutation."""
input CreateCartPriceRuleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `CartPriceRule` to be created by this mutation."""
  cartPriceRule: CartPriceRuleInput!
}

"""An input for mutations affecting `CartPriceRule`"""
input CartPriceRuleInput {
  id: Int
  rule: String
  description: String
  active: Boolean
  coupon: String
  usesPerCustomer: String
  priority: String
  startDate: Date
  endDate: Date
  status: String
  website: String
  actionsApply: String
  actionsDiscountAmount: BigFloat
  actionsDiscardSubsequentRules: Boolean
  actionsMaxQtyDiscountIsAppliedTo: BigFloat
  actionsDiscountQtyStep: BigFloat
  actionsApplyShippingAmount: Boolean
}

"""The output of our create `Case` mutation."""
type CreateCasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Case` that was created by this mutation."""
  case: Case
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Case`. May be used by Relay 1."""
  caseEdge(
    """The method to use when ordering `Case`."""
    orderBy: [CasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CasesEdge
}

"""All input for the create `Case` mutation."""
input CreateCaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Case` to be created by this mutation."""
  case: CaseInput!
}

"""An input for mutations affecting `Case`"""
input CaseInput {
  id: BigInt
  createdAt: Datetime
  caseNumber: Int
  state: String
  type: String
  subject: String
  description: String
  resolution: String
  priority: String
  status: String
  accountName: String
  assignedTo: String
  dateModified: Datetime
}

"""The output of our create `CatalogPriceRule` mutation."""
type CreateCatalogPriceRulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CatalogPriceRule` that was created by this mutation."""
  catalogPriceRule: CatalogPriceRule
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CatalogPriceRule`. May be used by Relay 1."""
  catalogPriceRuleEdge(
    """The method to use when ordering `CatalogPriceRule`."""
    orderBy: [CatalogPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CatalogPriceRulesEdge
}

"""All input for the create `CatalogPriceRule` mutation."""
input CreateCatalogPriceRuleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `CatalogPriceRule` to be created by this mutation."""
  catalogPriceRule: CatalogPriceRuleInput!
}

"""An input for mutations affecting `CatalogPriceRule`"""
input CatalogPriceRuleInput {
  id: Int
  rule: String
  description: String
  active: Boolean
  customerGroups: String
  priority: String
  startDate: Date
  endDate: Date
  status: String
  website: String
  actionsApply: String
  actionsDiscountAmount: BigFloat
  actionsDiscardSubsequentRules: Boolean
}

"""The output of our create `Category` mutation."""
type CreateCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Category` that was created by this mutation."""
  category: Category
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""All input for the create `Category` mutation."""
input CreateCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Category` to be created by this mutation."""
  category: CategoryInput!
}

"""An input for mutations affecting `Category`"""
input CategoryInput {
  id: Int
  thumbnail: String
  name: String!
  visibility: String
  status: Boolean
  websites: String
  product: String
  country: String
  description: String
  content: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
}

"""The output of our create `Channel` mutation."""
type CreateChannelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Channel` that was created by this mutation."""
  channel: Channel
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Channel`. May be used by Relay 1."""
  channelEdge(
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChannelsEdge
}

"""All input for the create `Channel` mutation."""
input CreateChannelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Channel` to be created by this mutation."""
  channel: ChannelInput!
}

"""An input for mutations affecting `Channel`"""
input ChannelInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  currency: String
  defaultLang: String
  includeTax: String
  defaultZone: String
  defaultShipping: String
  clientId: String
  clientSecret: String
}

"""The output of our create `Checklist` mutation."""
type CreateChecklistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Checklist` that was created by this mutation."""
  checklist: Checklist
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Checklist`. May be used by Relay 1."""
  checklistEdge(
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChecklistsEdge
}

"""All input for the create `Checklist` mutation."""
input CreateChecklistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Checklist` to be created by this mutation."""
  checklist: ChecklistInput!
}

"""An input for mutations affecting `Checklist`"""
input ChecklistInput {
  id: BigInt
  createdAt: Datetime
  username: String
  location: String
  regionalManager: String
  manager: String
  description: String
  ticket: String
  project: String
  region: String
  country: String
  media: String
  prodId: String
}

"""The output of our create `City` mutation."""
type CreateCityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `City` that was created by this mutation."""
  city: City
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `City`. May be used by Relay 1."""
  cityEdge(
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge
}

"""All input for the create `City` mutation."""
input CreateCityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `City` to be created by this mutation."""
  city: CityInput!
}

"""An input for mutations affecting `City`"""
input CityInput {
  id: Int
  name: String!
  description: String
  state: String
  country: String
  postalCode: String
  image: String
}

"""The output of our create `Collection` mutation."""
type CreateCollectionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Collection` that was created by this mutation."""
  collection: Collection
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Collection`. May be used by Relay 1."""
  collectionEdge(
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CollectionsEdge
}

"""All input for the create `Collection` mutation."""
input CreateCollectionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Collection` to be created by this mutation."""
  collection: CollectionInput!
}

"""An input for mutations affecting `Collection`"""
input CollectionInput {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  image: String
  product: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
}

"""The output of our create `Comment` mutation."""
type CreateCommentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Comment` that was created by this mutation."""
  comment: Comment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Comment`."""
  customerByCustId: Customer
  """An edge for our `Comment`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentsEdge
}

"""All input for the create `Comment` mutation."""
input CreateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Comment` to be created by this mutation."""
  comment: CommentInput!
}

"""An input for mutations affecting `Comment`"""
input CommentInput {
  id: Int
  customerName: String!
  description: String
  image: String
  response: String
  published: Datetime
  custId: Int
}

"""The output of our create `ContentType` mutation."""
type CreateContentTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ContentType` that was created by this mutation."""
  contentType: ContentType
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `ContentType`. May be used by Relay 1."""
  contentTypeEdge(
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContentTypesEdge
}

"""All input for the create `ContentType` mutation."""
input CreateContentTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `ContentType` to be created by this mutation."""
  contentType: ContentTypeInput!
}

"""An input for mutations affecting `ContentType`"""
input ContentTypeInput {
  id: BigInt
  createdAt: Datetime
  text: String
  number: BigFloat
  json: JSON
  link: String
  email: String
  uid: UUID
  date: Date
  time: Time
  timestamp: Datetime
  boolean: Boolean
  richText: String
  password: String
  media: String
  databaseName: String
}

"""The output of our create `Contract` mutation."""
type CreateContractPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Contract` that was created by this mutation."""
  contract: Contract
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Contract`. May be used by Relay 1."""
  contractEdge(
    """The method to use when ordering `Contract`."""
    orderBy: [ContractsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContractsEdge
}

"""All input for the create `Contract` mutation."""
input CreateContractInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Contract` to be created by this mutation."""
  contract: ContractInput!
}

"""An input for mutations affecting `Contract`"""
input ContractInput {
  id: BigInt
  contractTitle: String
  contractValue: String
  startDate: String
  endDate: String
  renewalReminder: String
  customerSignedDate: String
  companySignedDate: String
  status: String
  contractManager: String
  account: String
  contact: String
  description: String
  opportunity: String
  contractType: String
  currency: String
  lineItems: String
  total: String
  discount: String
  subtotal: String
  shipping: String
  shippingTax: String
  tax: String
  grandTotal: String
  createdAt: Datetime
}

"""The output of our create `Country` mutation."""
type CreateCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Country` that was created by this mutation."""
  country: Country
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Country`. May be used by Relay 1."""
  countryEdge(
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge
}

"""All input for the create `Country` mutation."""
input CreateCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Country` to be created by this mutation."""
  country: CountryInput!
}

"""An input for mutations affecting `Country`"""
input CountryInput {
  id: Int
  name: String!
  description: String
  image: String
  region: String
}

"""The output of our create `Coupon` mutation."""
type CreateCouponPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Coupon` that was created by this mutation."""
  coupon: Coupon
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Coupon`."""
  productByProdId: Product
  """An edge for our `Coupon`. May be used by Relay 1."""
  couponEdge(
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CouponsEdge
}

"""All input for the create `Coupon` mutation."""
input CreateCouponInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Coupon` to be created by this mutation."""
  coupon: CouponInput!
}

"""An input for mutations affecting `Coupon`"""
input CouponInput {
  id: BigInt
  name: String!
  excerpt: String
  discount: String
  image: String
  published: Datetime
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  prodId: BigInt
}

"""The output of our create `CreditMemo` mutation."""
type CreateCreditMemoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CreditMemo` that was created by this mutation."""
  creditMemo: CreditMemo
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `CreditMemo`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `CreditMemo`."""
  productByProdId: Product
  """An edge for our `CreditMemo`. May be used by Relay 1."""
  creditMemoEdge(
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!] = [PRIMARY_KEY_ASC]
  ): CreditMemosEdge
}

"""All input for the create `CreditMemo` mutation."""
input CreateCreditMemoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `CreditMemo` to be created by this mutation."""
  creditMemo: CreditMemoInput!
}

"""An input for mutations affecting `CreditMemo`"""
input CreditMemoInput {
  creditMemo: String!
  orderNumber: Int
  created: Datetime
  billToName: String!
  status: String
  refunded: String
  action: String
  id: BigInt
  custId: Int
  prodId: BigInt
}

"""The output of our create `Currency` mutation."""
type CreateCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Currency` that was created by this mutation."""
  currency: Currency
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
}

"""All input for the create `Currency` mutation."""
input CreateCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Currency` to be created by this mutation."""
  currency: CurrencyInput!
}

"""An input for mutations affecting `Currency`"""
input CurrencyInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  region: String
}

"""The output of our create `CurrencyRate` mutation."""
type CreateCurrencyRatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CurrencyRate` that was created by this mutation."""
  currencyRate: CurrencyRate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CurrencyRate`. May be used by Relay 1."""
  currencyRateEdge(
    """The method to use when ordering `CurrencyRate`."""
    orderBy: [CurrencyRatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencyRatesEdge
}

"""All input for the create `CurrencyRate` mutation."""
input CreateCurrencyRateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `CurrencyRate` to be created by this mutation."""
  currencyRate: CurrencyRateInput!
}

"""An input for mutations affecting `CurrencyRate`"""
input CurrencyRateInput {
  importService: String!
  usd: Float
  id: BigInt
}

"""The output of our create `CurrencySymbol` mutation."""
type CreateCurrencySymbolPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CurrencySymbol` that was created by this mutation."""
  currencySymbol: CurrencySymbol
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CurrencySymbol`. May be used by Relay 1."""
  currencySymbolEdge(
    """The method to use when ordering `CurrencySymbol`."""
    orderBy: [CurrencySymbolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencySymbolsEdge
}

"""All input for the create `CurrencySymbol` mutation."""
input CreateCurrencySymbolInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `CurrencySymbol` to be created by this mutation."""
  currencySymbol: CurrencySymbolInput!
}

"""An input for mutations affecting `CurrencySymbol`"""
input CurrencySymbolInput {
  symbol: String!
  useStandard: Boolean
  id: BigInt
}

"""The output of our create `CustomerGroup` mutation."""
type CreateCustomerGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CustomerGroup` that was created by this mutation."""
  customerGroup: CustomerGroup
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `CustomerGroup`."""
  customerByCustId: Customer
  """An edge for our `CustomerGroup`. May be used by Relay 1."""
  customerGroupEdge(
    """The method to use when ordering `CustomerGroup`."""
    orderBy: [CustomerGroupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomerGroupsEdge
}

"""All input for the create `CustomerGroup` mutation."""
input CreateCustomerGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `CustomerGroup` to be created by this mutation."""
  customerGroup: CustomerGroupInput!
}

"""An input for mutations affecting `CustomerGroup`"""
input CustomerGroupInput {
  id: BigInt
  createdAt: Datetime
  name: String
  taxClass: String
  custId: Int
}

"""The output of our create `CustomerPayment` mutation."""
type CreateCustomerPaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CustomerPayment` that was created by this mutation."""
  customerPayment: CustomerPayment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `CustomerPayment`."""
  customerByCustId: Customer
  """An edge for our `CustomerPayment`. May be used by Relay 1."""
  customerPaymentEdge(
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomerPaymentsEdge
}

"""All input for the create `CustomerPayment` mutation."""
input CreateCustomerPaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `CustomerPayment` to be created by this mutation."""
  customerPayment: CustomerPaymentInput!
}

"""An input for mutations affecting `CustomerPayment`"""
input CustomerPaymentInput {
  id: BigInt
  createdAt: Datetime
  custId: Int
  paymentInfo: String
  provider: String
  accountNo: BigInt
  expiry: BigInt
}

"""The output of our create `Customer` mutation."""
type CreateCustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Customer` that was created by this mutation."""
  customer: Customer
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Customer`. May be used by Relay 1."""
  customerEdge(
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersEdge
}

"""All input for the create `Customer` mutation."""
input CreateCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Customer` to be created by this mutation."""
  customer: CustomerInput!
}

"""An input for mutations affecting `Customer`"""
input CustomerInput {
  id: Int
  thumbnail: String
  namePrefix: String
  firstName: String!
  middleName: String
  lastName: String!
  email: String!
  customerGroup: String
  phone: String
  zipcode: String
  nameSuffix: String
  websites: String
  product: String
  country: String
  state: String
  customerSince: Datetime
  confirmedEmail: String
  dateOfBirth: String
  taxVatNumber: String
  gender: String
  description: String
  shortDescription: String
  image: String
  address: String
  addressTwo: String
  paymentType: String
  username: String
  password: String
}

"""The output of our create `Customization` mutation."""
type CreateCustomizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Customization` that was created by this mutation."""
  customization: Customization
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Customization`. May be used by Relay 1."""
  customizationEdge(
    """The method to use when ordering `Customization`."""
    orderBy: [CustomizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomizationsEdge
}

"""All input for the create `Customization` mutation."""
input CreateCustomizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Customization` to be created by this mutation."""
  customization: CustomizationInput!
}

"""An input for mutations affecting `Customization`"""
input CustomizationInput {
  id: Int
  createdAt: Datetime
  siteName: String
  navLink: String
  notification: String
  banner: String
  footerLink: String
  announcement: String
  email: String
  siteUrl: String
  allowSignup: String
}

"""The output of our create `Dashboard` mutation."""
type CreateDashboardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Dashboard` that was created by this mutation."""
  dashboard: Dashboard
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Dashboard`. May be used by Relay 1."""
  dashboardEdge(
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DashboardsEdge
}

"""All input for the create `Dashboard` mutation."""
input CreateDashboardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Dashboard` to be created by this mutation."""
  dashboard: DashboardInput!
}

"""An input for mutations affecting `Dashboard`"""
input DashboardInput {
  id: BigInt
  createdAt: Datetime
  name: String
  clientId: String
  clientSecret: String
  privacy: String
  category: String
  url: String
  media: String
  task: String
  reports: String
  tasks: String
  projects: String
  tickets: String
  customers: String
  checklists: String
  visits: String
  users: String
  products: String
  articles: String
  sales: String
}

"""The output of our create `Deepdive` mutation."""
type CreateDeepdivePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Deepdive` that was created by this mutation."""
  deepdive: Deepdive
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Deepdive`. May be used by Relay 1."""
  deepdiveEdge(
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DeepdivesEdge
}

"""All input for the create `Deepdive` mutation."""
input CreateDeepdiveInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Deepdive` to be created by this mutation."""
  deepdive: DeepdiveInput!
}

"""An input for mutations affecting `Deepdive`"""
input DeepdiveInput {
  id: BigInt
  createdAt: Datetime
  endDate: String
  content: String
  attendees: String
  login: String
  startDate: String
  whid: String
}

"""The output of our create `EmailTemplate` mutation."""
type CreateEmailTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `EmailTemplate` that was created by this mutation."""
  emailTemplate: EmailTemplate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `EmailTemplate`. May be used by Relay 1."""
  emailTemplateEdge(
    """The method to use when ordering `EmailTemplate`."""
    orderBy: [EmailTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmailTemplatesEdge
}

"""All input for the create `EmailTemplate` mutation."""
input CreateEmailTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `EmailTemplate` to be created by this mutation."""
  emailTemplate: EmailTemplateInput!
}

"""An input for mutations affecting `EmailTemplate`"""
input EmailTemplateInput {
  id: BigInt
  createdAt: Datetime
  name: String
  assignedTo: String
  type: String
  active: String
  insertVariable: String
  subject: String
  content: String
  header: String
  footer: String
  width: String
  height: String
  media: String
}

"""The output of our create `Email` mutation."""
type CreateEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Email` that was created by this mutation."""
  email: Email
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Email`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Email`."""
  userByStaffId: User
  """An edge for our `Email`. May be used by Relay 1."""
  emailEdge(
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmailsEdge
}

"""All input for the create `Email` mutation."""
input CreateEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Email` to be created by this mutation."""
  email: EmailInput!
}

"""An input for mutations affecting `Email`"""
input EmailInput {
  id: Int
  createdAt: Datetime
  subject: String
  content: String
  custId: Int
  bcc: String
  cc: String
  from: String
  media: String
  staffId: Int
}

"""The output of our create `Event` mutation."""
type CreateEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Event` that was created by this mutation."""
  event: Event
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the create `Event` mutation."""
input CreateEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Event` to be created by this mutation."""
  event: EventInput!
}

"""An input for mutations affecting `Event`"""
input EventInput {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  tickets: String
  image: String
  start: String
  end: String
  category: String
  city: String
  state: String
  country: String
  postalcode: String
}

"""The output of our create `Fullfillment` mutation."""
type CreateFullfillmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Fullfillment` that was created by this mutation."""
  fullfillment: Fullfillment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Fullfillment`. May be used by Relay 1."""
  fullfillmentEdge(
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FullfillmentsEdge
}

"""All input for the create `Fullfillment` mutation."""
input CreateFullfillmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Fullfillment` to be created by this mutation."""
  fullfillment: FullfillmentInput!
}

"""An input for mutations affecting `Fullfillment`"""
input FullfillmentInput {
  id: BigInt
  createdAt: Datetime
  name: String
  shippingZones: String
  company: String
  address: String
  addressTwo: String
  city: String
  state: String
  zipcode: String
  country: String
  countryArea: String
  phone: String
  pickup: String
  stock: String
}

"""The output of our create `GeneralSetting` mutation."""
type CreateGeneralSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `GeneralSetting` that was created by this mutation."""
  generalSetting: GeneralSetting
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `GeneralSetting`. May be used by Relay 1."""
  generalSettingEdge(
    """The method to use when ordering `GeneralSetting`."""
    orderBy: [GeneralSettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GeneralSettingsEdge
}

"""All input for the create `GeneralSetting` mutation."""
input CreateGeneralSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `GeneralSetting` to be created by this mutation."""
  generalSetting: GeneralSettingInput!
}

"""An input for mutations affecting `GeneralSetting`"""
input GeneralSettingInput {
  id: BigInt
  createdAt: Datetime
  title: String
  tagline: String
  url: String
  email: String
  accessRestrictions: String
  restrictionMode: String
  startupPage: String
  landingPage: String
  httpResponse: String
  storeEmail: String
  storeContact: String
  storeContactTwo: String
  customerSupport: String
}

"""The output of our create `GiftCertificate` mutation."""
type CreateGiftCertificatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `GiftCertificate` that was created by this mutation."""
  giftCertificate: GiftCertificate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `GiftCertificate`. May be used by Relay 1."""
  giftCertificateEdge(
    """The method to use when ordering `GiftCertificate`."""
    orderBy: [GiftCertificatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GiftCertificatesEdge
}

"""All input for the create `GiftCertificate` mutation."""
input CreateGiftCertificateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `GiftCertificate` to be created by this mutation."""
  giftCertificate: GiftCertificateInput!
}

"""An input for mutations affecting `GiftCertificate`"""
input GiftCertificateInput {
  id: BigInt
  name: String!
  excerpt: String
  discount: String
  image: String
  published: Datetime
  specialOffers: String
  rewards: String
  coupons: String
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  type: String
}

"""The output of our create `Glossary` mutation."""
type CreateGlossaryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Glossary` that was created by this mutation."""
  glossary: Glossary
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Glossary`. May be used by Relay 1."""
  glossaryEdge(
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GlossariesEdge
}

"""All input for the create `Glossary` mutation."""
input CreateGlossaryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Glossary` to be created by this mutation."""
  glossary: GlossaryInput!
}

"""An input for mutations affecting `Glossary`"""
input GlossaryInput {
  id: Int
  name: String!
  content: String
  image: String
  published: Datetime
}

"""The output of our create `Importm` mutation."""
type CreateImportmPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Importm` that was created by this mutation."""
  importm: Importm
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Importm`. May be used by Relay 1."""
  importmEdge(
    """The method to use when ordering `Importm`."""
    orderBy: [ImportmsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImportmsEdge
}

"""All input for the create `Importm` mutation."""
input CreateImportmInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Importm` to be created by this mutation."""
  importm: ImportmInput!
}

"""An input for mutations affecting `Importm`"""
input ImportmInput {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  file: String
  url: String
  image: String
}

"""The output of our create `Integration` mutation."""
type CreateIntegrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Integration` that was created by this mutation."""
  integration: Integration
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Integration`. May be used by Relay 1."""
  integrationEdge(
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): IntegrationsEdge
}

"""All input for the create `Integration` mutation."""
input CreateIntegrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Integration` to be created by this mutation."""
  integration: IntegrationInput!
}

"""An input for mutations affecting `Integration`"""
input IntegrationInput {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  media: String
  location: String
  category: String
}

"""The output of our create `Internalization` mutation."""
type CreateInternalizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Internalization` that was created by this mutation."""
  internalization: Internalization
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Internalization`. May be used by Relay 1."""
  internalizationEdge(
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InternalizationsEdge
}

"""All input for the create `Internalization` mutation."""
input CreateInternalizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Internalization` to be created by this mutation."""
  internalization: InternalizationInput!
}

"""An input for mutations affecting `Internalization`"""
input InternalizationInput {
  id: BigInt
  createdAt: Datetime
  name: String
  region: String
  description: String
  default: String
  website: String
}

"""The output of our create `Invitation` mutation."""
type CreateInvitationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Invitation` that was created by this mutation."""
  invitation: Invitation
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Invitation`. May be used by Relay 1."""
  invitationEdge(
    """The method to use when ordering `Invitation`."""
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsEdge
}

"""All input for the create `Invitation` mutation."""
input CreateInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Invitation` to be created by this mutation."""
  invitation: InvitationInput!
}

"""An input for mutations affecting `Invitation`"""
input InvitationInput {
  id: BigInt
  createdAt: Datetime
  invoiceDate: Datetime
  email: String
  billingAddress: String
  shippingAddress: String
  orderNumber: String
  grandTotalPurchased: String
  paymentMethod: String
  status: String
  media: String
  content: String
}

"""The output of our create `Invoice` mutation."""
type CreateInvoicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Invoice` that was created by this mutation."""
  invoice: Invoice
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Invoice`. May be used by Relay 1."""
  invoiceEdge(
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvoicesEdge
}

"""All input for the create `Invoice` mutation."""
input CreateInvoiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Invoice` to be created by this mutation."""
  invoice: InvoiceInput!
}

"""An input for mutations affecting `Invoice`"""
input InvoiceInput {
  invoice: Int
  orderNumber: BigInt
  invoiceDate: Datetime
  billToName: String!
  billingAddress: String
  grandTotalBase: String
  grandTotalPurchased: String
  status: String
  shippingAddress: String
  customerName: String
  email: String
  customerGroup: String
  paymentMethod: String
  shippingInformation: String
  subtotal: String
  shippingAndHandling: String
  id: BigInt
}

"""The output of our create `Knowledgebase` mutation."""
type CreateKnowledgebasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Knowledgebase` that was created by this mutation."""
  knowledgebase: Knowledgebase
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Knowledgebase`. May be used by Relay 1."""
  knowledgebaseEdge(
    """The method to use when ordering `Knowledgebase`."""
    orderBy: [KnowledgebasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): KnowledgebasesEdge
}

"""All input for the create `Knowledgebase` mutation."""
input CreateKnowledgebaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Knowledgebase` to be created by this mutation."""
  knowledgebase: KnowledgebaseInput!
}

"""An input for mutations affecting `Knowledgebase`"""
input KnowledgebaseInput {
  id: BigInt
  createdAt: Datetime
  name: String
  status: String
  revision: String
  content: String
  resolution: String
  author: String
  approver: String
  dateModified: Datetime
}

"""The output of our create `Lead` mutation."""
type CreateLeadPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Lead` that was created by this mutation."""
  lead: Lead
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Lead`. May be used by Relay 1."""
  leadEdge(
    """The method to use when ordering `Lead`."""
    orderBy: [LeadsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LeadsEdge
}

"""All input for the create `Lead` mutation."""
input CreateLeadInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Lead` to be created by this mutation."""
  lead: LeadInput!
}

"""An input for mutations affecting `Lead`"""
input LeadInput {
  id: BigInt
  createdAt: Datetime
  prefix: String
  firstName: String
  lastName: String
  department: String
  accountName: String
  address: String
  postalcode: String
  city: String
  state: String
  country: String
  email: String
  description: String
  fax: String
  website: String
  mobile: String
  jobTitle: String
  altAddress: String
  altPostalcode: String
  altCity: String
  altState: String
  altCountry: String
  officePhone: String
  status: String
  statusDescription: String
  opportunityAmount: String
  campaign: String
  leadSource: String
  leadSourceDescription: String
  referredBy: String
  customerName: String
}

"""The output of our create `Manufacturer` mutation."""
type CreateManufacturerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Manufacturer` that was created by this mutation."""
  manufacturer: Manufacturer
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Manufacturer`."""
  productByProduct: Product
  """An edge for our `Manufacturer`. May be used by Relay 1."""
  manufacturerEdge(
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ManufacturersEdge
}

"""All input for the create `Manufacturer` mutation."""
input CreateManufacturerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Manufacturer` to be created by this mutation."""
  manufacturer: ManufacturerInput!
}

"""An input for mutations affecting `Manufacturer`"""
input ManufacturerInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
}

"""The output of our create `Mediamanager` mutation."""
type CreateMediamanagerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Mediamanager` that was created by this mutation."""
  mediamanager: Mediamanager
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Brand` that is related to this `Mediamanager`."""
  brandByBrands: Brand
  """Reads a single `Customer` that is related to this `Mediamanager`."""
  customerByAuthor: Customer
  """Reads a single `Agreement` that is related to this `Mediamanager`."""
  agreementByAgreements: Agreement
  """Reads a single `Comment` that is related to this `Mediamanager`."""
  commentByComment: Comment
  """Reads a single `TodoList` that is related to this `Mediamanager`."""
  todoListByTaskName: TodoList
  """Reads a single `User` that is related to this `Mediamanager`."""
  userByMembers: User
  """Reads a single `Product` that is related to this `Mediamanager`."""
  productByProducts: Product
  """An edge for our `Mediamanager`. May be used by Relay 1."""
  mediamanagerEdge(
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
  ): MediamanagersEdge
}

"""All input for the create `Mediamanager` mutation."""
input CreateMediamanagerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Mediamanager` to be created by this mutation."""
  mediamanager: MediamanagerInput!
}

"""An input for mutations affecting `Mediamanager`"""
input MediamanagerInput {
  id: Int
  createdAt: Datetime
  name: String
  description: String
  media: String
  keywords: String
  tags: String
  brands: BigInt
  status: String
  expirationDate: String
  copyright: String
  dimensions: String
  author: Int
  contentType: String
  versions: String
  watermarkName: String
  watermarkDescription: String
  watermarkMedia: String
  agreements: Int
  albums: String
  comment: Int
  workspace: String
  taskName: BigInt
  taskDescription: String
  taskType: String
  members: Int
  products: BigInt
}

"""The output of our create `Meeting` mutation."""
type CreateMeetingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Meeting` that was created by this mutation."""
  meeting: Meeting
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Meeting`. May be used by Relay 1."""
  meetingEdge(
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeetingsEdge
}

"""All input for the create `Meeting` mutation."""
input CreateMeetingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Meeting` to be created by this mutation."""
  meeting: MeetingInput!
}

"""An input for mutations affecting `Meeting`"""
input MeetingInput {
  id: BigInt
  createdAt: Datetime
  subject: String
  startDate: String
  endDate: String
  duration: String
  status: String
  relatedTo: String
  reminders: String
  content: String
  assignedTo: String
  invitees: String
  scheduling: String
}

"""The output of our create `Message` mutation."""
type CreateMessagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Message` that was created by this mutation."""
  message: Message
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Message`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Message`."""
  userByStaffId: User
  """An edge for our `Message`. May be used by Relay 1."""
  messageEdge(
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessagesEdge
}

"""All input for the create `Message` mutation."""
input CreateMessageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Message` to be created by this mutation."""
  message: MessageInput!
}

"""An input for mutations affecting `Message`"""
input MessageInput {
  id: Int
  from: String
  createdAt: Datetime
  subject: String
  content: String
  sender: String
  custId: Int
  media: String
  staffId: Int
}

"""The output of our create `NewsletterSubscriber` mutation."""
type CreateNewsletterSubscriberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `NewsletterSubscriber` that was created by this mutation."""
  newsletterSubscriber: NewsletterSubscriber
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `NewsletterSubscriber`."""
  customerByCustId: Customer
  """An edge for our `NewsletterSubscriber`. May be used by Relay 1."""
  newsletterSubscriberEdge(
    """The method to use when ordering `NewsletterSubscriber`."""
    orderBy: [NewsletterSubscribersOrderBy!] = [PRIMARY_KEY_ASC]
  ): NewsletterSubscribersEdge
}

"""All input for the create `NewsletterSubscriber` mutation."""
input CreateNewsletterSubscriberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `NewsletterSubscriber` to be created by this mutation."""
  newsletterSubscriber: NewsletterSubscriberInput!
}

"""An input for mutations affecting `NewsletterSubscriber`"""
input NewsletterSubscriberInput {
  id: Int
  email: String!
  customerFirstName: String
  customerLastName: String
  store: String
  status: String
  websites: String
  createdAt: Datetime
  custId: Int
}

"""The output of our create `Occassion` mutation."""
type CreateOccassionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Occassion` that was created by this mutation."""
  occassion: Occassion
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Occassion`."""
  productByProducts: Product
  """Reads a single `Wishlist` that is related to this `Occassion`."""
  wishlistByWishlists: Wishlist
  """An edge for our `Occassion`. May be used by Relay 1."""
  occassionEdge(
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OccassionsEdge
}

"""All input for the create `Occassion` mutation."""
input CreateOccassionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Occassion` to be created by this mutation."""
  occassion: OccassionInput!
}

"""An input for mutations affecting `Occassion`"""
input OccassionInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  category: String
  tags: String
  description: String
  products: BigInt
  wishlists: BigInt
}

"""The output of our create `Ooto` mutation."""
type CreateOotoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Ooto` that was created by this mutation."""
  ooto: Ooto
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Ooto`. May be used by Relay 1."""
  ootoEdge(
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!] = [PRIMARY_KEY_ASC]
  ): OotosEdge
}

"""All input for the create `Ooto` mutation."""
input CreateOotoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Ooto` to be created by this mutation."""
  ooto: OotoInput!
}

"""An input for mutations affecting `Ooto`"""
input OotoInput {
  id: BigInt
  createdAt: Datetime
  login: String
  startDate: String
  endDate: String
  note: String
  usingTime: String
  location: String
}

"""The output of our create `Opportunity` mutation."""
type CreateOpportunityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Opportunity` that was created by this mutation."""
  opportunity: Opportunity
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Opportunity`. May be used by Relay 1."""
  opportunityEdge(
    """The method to use when ordering `Opportunity`."""
    orderBy: [OpportunitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OpportunitiesEdge
}

"""All input for the create `Opportunity` mutation."""
input CreateOpportunityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Opportunity` to be created by this mutation."""
  opportunity: OpportunityInput!
}

"""An input for mutations affecting `Opportunity`"""
input OpportunityInput {
  id: BigInt
  createdAt: Datetime
  name: String
  amount: String
  salesStage: String
  currency: String
  probability: String
  nextStep: String
  description: String
  assignedTo: String
  leadSource: String
  campaign: String
  type: String
  accountName: String
  expectedCloseDate: String
}

"""The output of our create `Order` mutation."""
type CreateOrderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Order` that was created by this mutation."""
  order: Order
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Order`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `Order`."""
  productByProdId: Product
  """An edge for our `Order`. May be used by Relay 1."""
  orderEdge(
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrdersEdge
}

"""All input for the create `Order` mutation."""
input CreateOrderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Order` to be created by this mutation."""
  order: OrderInput!
}

"""An input for mutations affecting `Order`"""
input OrderInput {
  id: Int
  purchasePoint: Int
  purchaseDate: Datetime
  billToName: String!
  shipToName: String
  grandTotalBase: Int
  grandTotalPurchased: Int
  status: Boolean
  action: Boolean
  allocatedSources: String
  braintreeTransactionSource: String
  custId: Int
  prodId: BigInt
}

"""The output of our create `Page` mutation."""
type CreatePagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Page` that was created by this mutation."""
  page: Page
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Page`. May be used by Relay 1."""
  pageEdge(
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PagesEdge
}

"""All input for the create `Page` mutation."""
input CreatePageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Page` to be created by this mutation."""
  page: PageInput!
}

"""An input for mutations affecting `Page`"""
input PageInput {
  id: BigInt
  enablePage: Boolean
  title: String!
  contentTitle: String
  content: String
  urlKey: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  createdAt: Datetime
}

"""The output of our create `Partner` mutation."""
type CreatePartnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Partner` that was created by this mutation."""
  partner: Partner
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Partner`. May be used by Relay 1."""
  partnerEdge(
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnersEdge
}

"""All input for the create `Partner` mutation."""
input CreatePartnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Partner` to be created by this mutation."""
  partner: PartnerInput!
}

"""An input for mutations affecting `Partner`"""
input PartnerInput {
  id: BigInt
  createdAt: Datetime
  name: String
  address: String
  city: String
  state: String
  country: String
  isPublic: String
  businessType: String
}

"""The output of our create `Payment` mutation."""
type CreatePaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Payment` that was created by this mutation."""
  payment: Payment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Payment`. May be used by Relay 1."""
  paymentEdge(
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsEdge
}

"""All input for the create `Payment` mutation."""
input CreatePaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Payment` to be created by this mutation."""
  payment: PaymentInput!
}

"""An input for mutations affecting `Payment`"""
input PaymentInput {
  id: BigInt
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String!
  active: String
  country: String
}

"""The output of our create `PdfTemplate` mutation."""
type CreatePdfTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `PdfTemplate` that was created by this mutation."""
  pdfTemplate: PdfTemplate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `PdfTemplate`. May be used by Relay 1."""
  pdfTemplateEdge(
    """The method to use when ordering `PdfTemplate`."""
    orderBy: [PdfTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PdfTemplatesEdge
}

"""All input for the create `PdfTemplate` mutation."""
input CreatePdfTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `PdfTemplate` to be created by this mutation."""
  pdfTemplate: PdfTemplateInput!
}

"""An input for mutations affecting `PdfTemplate`"""
input PdfTemplateInput {
  id: BigInt
  createdAt: Datetime
  name: String
  assignedTo: String
  type: String
  active: String
  pageSize: String
  orientation: String
  content: String
  header: String
  footer: String
  marginLeft: String
  marginRight: String
  marginTop: String
  marginBottom: String
  marginHeader: String
  marginFooter: String
}

"""The output of our create `Permission` mutation."""
type CreatePermissionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Permission` that was created by this mutation."""
  permission: Permission
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Permission`. May be used by Relay 1."""
  permissionEdge(
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PermissionsEdge
}

"""All input for the create `Permission` mutation."""
input CreatePermissionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Permission` to be created by this mutation."""
  permission: PermissionInput!
}

"""An input for mutations affecting `Permission`"""
input PermissionInput {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  role: String
  create: String
  read: String
  update: String
  delete: String
  users: String
}

"""The output of our create `Plugin` mutation."""
type CreatePluginPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Plugin` that was created by this mutation."""
  plugin: Plugin
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Plugin`. May be used by Relay 1."""
  pluginEdge(
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PluginsEdge
}

"""All input for the create `Plugin` mutation."""
input CreatePluginInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Plugin` to be created by this mutation."""
  plugin: PluginInput!
}

"""An input for mutations affecting `Plugin`"""
input PluginInput {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  githubLink: String
  description: String
  logo: String
  screenshots: String
  lastUpdated: Datetime
  publisherName: String
  agreeTerms: Boolean
  publisherEmail: String
}

"""The output of our create `ProductAttribute` mutation."""
type CreateProductAttributePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ProductAttribute` that was created by this mutation."""
  productAttribute: ProductAttribute
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `ProductAttribute`."""
  productByProdId: Product
  """An edge for our `ProductAttribute`. May be used by Relay 1."""
  productAttributeEdge(
    """The method to use when ordering `ProductAttribute`."""
    orderBy: [ProductAttributesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductAttributesEdge
}

"""All input for the create `ProductAttribute` mutation."""
input CreateProductAttributeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `ProductAttribute` to be created by this mutation."""
  productAttribute: ProductAttributeInput!
}

"""An input for mutations affecting `ProductAttribute`"""
input ProductAttributeInput {
  id: BigInt
  defaultLabel: String
  attributeCode: String
  filterOptions: String
  useSearch: String
  layeredNavigation: Boolean
  searchResultsLayeredNavigation: Boolean
  position: String
  promoRuleConditions: Boolean
  allowHtmlTagsStorefront: Boolean
  visibleCatalogPagesStorefront: Boolean
  usedProductListing: Boolean
  usedSortingProductListing: Boolean
  prodId: BigInt
  attributeClass: String
  attributeValue: String
  columnOptions: String
  facetedNavigation: Boolean
  isPublic: String
  metaDescription: String
  metaName: Boolean
  metaUrl: String
}

"""The output of our create `ProductType` mutation."""
type CreateProductTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ProductType` that was created by this mutation."""
  productType: ProductType
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `ProductType`."""
  productByProdId: Product
  """An edge for our `ProductType`. May be used by Relay 1."""
  productTypeEdge(
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductTypesEdge
}

"""All input for the create `ProductType` mutation."""
input CreateProductTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `ProductType` to be created by this mutation."""
  productType: ProductTypeInput!
}

"""An input for mutations affecting `ProductType`"""
input ProductTypeInput {
  id: BigInt
  typeName: String
  taxes: String
  isShippable: String
  metaUrl: String
  metaDescription: String
  filterOptions: String
  productType: String
  prodId: BigInt
}

"""The output of our create `Product` mutation."""
type CreateProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Product` that was created by this mutation."""
  product: Product
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Product`."""
  productByRelatedProduct: Product
  """An edge for our `Product`. May be used by Relay 1."""
  productEdge(
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge
}

"""All input for the create `Product` mutation."""
input CreateProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Product` to be created by this mutation."""
  product: ProductInput!
}

"""An input for mutations affecting `Product`"""
input ProductInput {
  id: BigInt
  sku: BigInt
  thumbnail: String
  name: String!
  types: String
  attributes: String
  price: String
  quantityPerSource: String
  salableQuantity: String
  visibility: String
  status: Boolean
  websites: String
  product: String
  taxClass: String
  stockStatus: String
  weight: String
  categories: String
  createdAt: Datetime
  country: String
  size: String
  format: String
  height: String
  content: String
  shortDescription: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  file: String
  manufacture: String
  partNumber: String
  contract: String
  costString: String
  manufacturerPartNumber: String
  relatedProduct: BigInt
  tags: String
  brand: String
  occassions: String
  customerType: String
  family: String
  zone: String
  variants: String
}

"""The output of our create `ProjectTemplate` mutation."""
type CreateProjectTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ProjectTemplate` that was created by this mutation."""
  projectTemplate: ProjectTemplate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `ProjectTemplate`. May be used by Relay 1."""
  projectTemplateEdge(
    """The method to use when ordering `ProjectTemplate`."""
    orderBy: [ProjectTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectTemplatesEdge
}

"""All input for the create `ProjectTemplate` mutation."""
input CreateProjectTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `ProjectTemplate` to be created by this mutation."""
  projectTemplate: ProjectTemplateInput!
}

"""An input for mutations affecting `ProjectTemplate`"""
input ProjectTemplateInput {
  id: BigInt
  name: String
  status: String
  considerWorkingDays: String
  priority: String
  projectManager: String
  resource: String
  content: String
}

"""The output of our create `Project` mutation."""
type CreateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Project` that was created by this mutation."""
  project: Project
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Project`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Project`."""
  userByStaffId: User
  """Reads a single `TodoList` that is related to this `Project`."""
  todoListByTaskId: TodoList
  """Reads a single `Ticketing` that is related to this `Project`."""
  ticketingByTicketId: Ticketing
  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""All input for the create `Project` mutation."""
input CreateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Project` to be created by this mutation."""
  project: ProjectInput!
}

"""An input for mutations affecting `Project`"""
input ProjectInput {
  id: BigInt
  name: String
  projectManager: String
  startDate: String
  endDate: String
  resource: String
  considerworkingdays: String
  projectTemplate: String
  status: String
  createdAt: Datetime
  priority: String
  assignee: String
  doing: String
  done: String
  sectionRule: String
  goalName: String
  goalTimeperiod: String
  goalPrivacy: String
  goalCollaborators: String
  goalUpdatemethod: String
  goalProgressSource: String
  goalMeasurement: String
  custId: Int
  staffId: Int
  taskId: BigInt
  ticketId: BigInt
}

"""The output of our create `Provider` mutation."""
type CreateProviderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Provider` that was created by this mutation."""
  provider: Provider
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Provider`. May be used by Relay 1."""
  providerEdge(
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProvidersEdge
}

"""All input for the create `Provider` mutation."""
input CreateProviderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Provider` to be created by this mutation."""
  provider: ProviderInput!
}

"""An input for mutations affecting `Provider`"""
input ProviderInput {
  id: BigInt
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String!
  active: String
}

"""The output of our create `Quote` mutation."""
type CreateQuotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Quote` that was created by this mutation."""
  quote: Quote
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Quote`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `Quote`."""
  productByProdId: Product
  """Reads a single `Order` that is related to this `Quote`."""
  orderByOrderId: Order
  """An edge for our `Quote`. May be used by Relay 1."""
  quoteEdge(
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): QuotesEdge
}

"""All input for the create `Quote` mutation."""
input CreateQuoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Quote` to be created by this mutation."""
  quote: QuoteInput!
}

"""An input for mutations affecting `Quote`"""
input QuoteInput {
  id: BigInt
  name: String!
  grandTotal: String
  createdAt: Datetime
  categories: String
  validUntil: String
  quoteStage: String
  customers: String
  custId: Int
  prodId: BigInt
  orderId: Int
  account: String
  approvalIssues: String
  approvalStatus: String
  assignedTo: String
  billingCity: String
  billingCountry: String
  billingPostal: String
  billingState: String
  billingStreet: String
  contact: String
  currency: String
  discount: String
  invoiceStatus: String
  lineItemDiscount: String
  lineItemGroupTotal: String
  lineItemName: String
  lineItemSubtotal: String
  lineItemTax: String
  lineItemTotal: String
  paymentTerms: String
  shipping: String
  shippingCity: String
  shippingCountry: String
  shippingPostal: String
  shippingState: String
  shippingStreet: String
  shippingTax: String
  subtotal: String
  tax: String
  total: String
}

"""The output of our create `Rating` mutation."""
type CreateRatingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Rating` that was created by this mutation."""
  rating: Rating
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Rating`."""
  productByProdId: Product
  """An edge for our `Rating`. May be used by Relay 1."""
  ratingEdge(
    """The method to use when ordering `Rating`."""
    orderBy: [RatingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RatingsEdge
}

"""All input for the create `Rating` mutation."""
input CreateRatingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Rating` to be created by this mutation."""
  rating: RatingInput!
}

"""An input for mutations affecting `Rating`"""
input RatingInput {
  id: BigInt
  defaultValue: String
  defaultStoreView: String
  ratingVisibility: String
  active: Boolean
  sortOrder: BigFloat
  prodId: BigInt
}

"""The output of our create `Report` mutation."""
type CreateReportPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Report` that was created by this mutation."""
  report: Report
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Report`. May be used by Relay 1."""
  reportEdge(
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReportsEdge
}

"""All input for the create `Report` mutation."""
input CreateReportInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Report` to be created by this mutation."""
  report: ReportInput!
}

"""An input for mutations affecting `Report`"""
input ReportInput {
  id: BigInt
  customer: String
  email: String
  products: String
  quantity: BigFloat
  subtotal: String
  appliedCoupon: String
  created: Datetime
  updated: Datetime
  ipAddress: String
}

"""The output of our create `Return` mutation."""
type CreateReturnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Return` that was created by this mutation."""
  return: Return
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Return`."""
  productByProdId: Product
  """Reads a single `Customer` that is related to this `Return`."""
  customerByCustId: Customer
  """An edge for our `Return`. May be used by Relay 1."""
  returnEdge(
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReturnsEdge
}

"""All input for the create `Return` mutation."""
input CreateReturnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Return` to be created by this mutation."""
  return: ReturnInput!
}

"""An input for mutations affecting `Return`"""
input ReturnInput {
  id: BigInt
  createdAt: Datetime
  name: String
  validity: String
  returnPrefix: String
  prodId: BigInt
  custId: Int
}

"""The output of our create `Review` mutation."""
type CreateReviewPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Review` that was created by this mutation."""
  review: Review
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Review`. May be used by Relay 1."""
  reviewEdge(
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReviewsEdge
}

"""All input for the create `Review` mutation."""
input CreateReviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Review` to be created by this mutation."""
  review: ReviewInput!
}

"""An input for mutations affecting `Review`"""
input ReviewInput {
  id: BigInt
  firstName: String
  lastName: String
  content: String
  websites: String
  createdAt: Datetime
  shopId: Int
  commentId: Int
}

"""The output of our create `Reward` mutation."""
type CreateRewardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Reward` that was created by this mutation."""
  reward: Reward
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Reward`. May be used by Relay 1."""
  rewardEdge(
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RewardsEdge
}

"""All input for the create `Reward` mutation."""
input CreateRewardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Reward` to be created by this mutation."""
  reward: RewardInput!
}

"""An input for mutations affecting `Reward`"""
input RewardInput {
  id: BigInt
  name: String!
  slug: String
  level: String
  createdAt: Datetime
  coupons: String
  expiration: Date
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""The output of our create `Scheduler` mutation."""
type CreateSchedulerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Scheduler` that was created by this mutation."""
  scheduler: Scheduler
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Scheduler`. May be used by Relay 1."""
  schedulerEdge(
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SchedulersEdge
}

"""All input for the create `Scheduler` mutation."""
input CreateSchedulerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Scheduler` to be created by this mutation."""
  scheduler: SchedulerInput!
}

"""An input for mutations affecting `Scheduler`"""
input SchedulerInput {
  id: BigInt
  createdAt: Datetime
  endDate: String
  level: String
  login: String
  notes: String
  startDate: String
  whid: String
}

"""The output of our create `Segment` mutation."""
type CreateSegmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Segment` that was created by this mutation."""
  segment: Segment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Segment`. May be used by Relay 1."""
  segmentEdge(
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SegmentsEdge
}

"""All input for the create `Segment` mutation."""
input CreateSegmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Segment` to be created by this mutation."""
  segment: SegmentInput!
}

"""An input for mutations affecting `Segment`"""
input SegmentInput {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  website: String
  status: String
  applyTo: String
  customers: String
}

"""The output of our create `Settingscustomer` mutation."""
type CreateSettingscustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingscustomer` that was created by this mutation."""
  settingscustomer: Settingscustomer
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingscustomer`. May be used by Relay 1."""
  settingscustomerEdge(
    """The method to use when ordering `Settingscustomer`."""
    orderBy: [SettingscustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingscustomersEdge
}

"""All input for the create `Settingscustomer` mutation."""
input CreateSettingscustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Settingscustomer` to be created by this mutation."""
  settingscustomer: SettingscustomerInput!
}

"""An input for mutations affecting `Settingscustomer`"""
input SettingscustomerInput {
  id: BigInt
  createdAt: Datetime
  loginAsCustomer: String
  shareCustomerAccounts: String
  onlineMinutesInterval: String
  customerDataLifetime: String
  emailAfterRegistration: String
}

"""The output of our create `Settingsgeneral` mutation."""
type CreateSettingsgeneralPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingsgeneral` that was created by this mutation."""
  settingsgeneral: Settingsgeneral
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingsgeneral`. May be used by Relay 1."""
  settingsgeneralEdge(
    """The method to use when ordering `Settingsgeneral`."""
    orderBy: [SettingsgeneralsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsgeneralsEdge
}

"""All input for the create `Settingsgeneral` mutation."""
input CreateSettingsgeneralInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Settingsgeneral` to be created by this mutation."""
  settingsgeneral: SettingsgeneralInput!
}

"""An input for mutations affecting `Settingsgeneral`"""
input SettingsgeneralInput {
  id: BigInt
  createdAt: Datetime
  siteTitle: String
  siteTagline: String
  siteWebsite: String
  email: String
  awsS3: String
  googleDrive: String
}

"""The output of our create `Settingshop` mutation."""
type CreateSettingshopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingshop` that was created by this mutation."""
  settingshop: Settingshop
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingshop`. May be used by Relay 1."""
  settingshopEdge(
    """The method to use when ordering `Settingshop`."""
    orderBy: [SettingshopsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingshopsEdge
}

"""All input for the create `Settingshop` mutation."""
input CreateSettingshopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Settingshop` to be created by this mutation."""
  settingshop: SettingshopInput!
}

"""An input for mutations affecting `Settingshop`"""
input SettingshopInput {
  id: BigInt
  enableProductAssignment: String
  productVideos: String
  sellerPayouts: String
  adminApproval: String
  enableReviewSystem: String
  customerRateVendor: String
  multishipping: String
  vendorTransactionId: String
  enableVendorProductAttribute: String
}

"""The output of our create `Settingsmarketing` mutation."""
type CreateSettingsmarketingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingsmarketing` that was created by this mutation."""
  settingsmarketing: Settingsmarketing
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingsmarketing`. May be used by Relay 1."""
  settingsmarketingEdge(
    """The method to use when ordering `Settingsmarketing`."""
    orderBy: [SettingsmarketingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsmarketingsEdge
}

"""All input for the create `Settingsmarketing` mutation."""
input CreateSettingsmarketingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Settingsmarketing` to be created by this mutation."""
  settingsmarketing: SettingsmarketingInput!
}

"""An input for mutations affecting `Settingsmarketing`"""
input SettingsmarketingInput {
  id: BigInt
  mailPort: String
  recaptchaApi: String
  adsenseApi: String
  sitemapUrl: String
  customerDataLifetime: String
  mailServer: String
}

"""The output of our create `Settingssale` mutation."""
type CreateSettingssalePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingssale` that was created by this mutation."""
  settingssale: Settingssale
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingssale`. May be used by Relay 1."""
  settingssaleEdge(
    """The method to use when ordering `Settingssale`."""
    orderBy: [SettingssalesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingssalesEdge
}

"""All input for the create `Settingssale` mutation."""
input CreateSettingssaleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Settingssale` to be created by this mutation."""
  settingssale: SettingssaleInput!
}

"""An input for mutations affecting `Settingssale`"""
input SettingssaleInput {
  id: BigInt
  createdAt: Datetime
  analyticsAccountType: String
  analyticsAccountNumber: String
  analyticsAnonymizeip: String
  analyticsContentExperiments: String
  adwordsConversionid: String
  adwordsConversionlanguage: String
  adwordsConversionformat: String
  adwordsConversioncolor: String
  adwordsConversionlabel: String
  adwordsConversionvalueType: String
  adwordsSendorder: String
  tagManagerAnonymizeip: String
  tagManagerContentexperiments: String
  tagManagerContainerid: String
}

"""The output of our create `Shipment` mutation."""
type CreateShipmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Shipment` that was created by this mutation."""
  shipment: Shipment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Shipment`. May be used by Relay 1."""
  shipmentEdge(
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShipmentsEdge
}

"""All input for the create `Shipment` mutation."""
input CreateShipmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Shipment` to be created by this mutation."""
  shipment: ShipmentInput!
}

"""An input for mutations affecting `Shipment`"""
input ShipmentInput {
  product: String
  speedGrade: String
  shipDate: Datetime
  carrierName: String!
  transitTime: String
  trackingUrl: String
  image: String
  id: BigInt
  clientId: String
  clientSecret: String
  country: String
  website: String
}

"""The output of our create `ShopSetting` mutation."""
type CreateShopSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ShopSetting` that was created by this mutation."""
  shopSetting: ShopSetting
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `ShopSetting`. May be used by Relay 1."""
  shopSettingEdge(
    """The method to use when ordering `ShopSetting`."""
    orderBy: [ShopSettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShopSettingsEdge
}

"""All input for the create `ShopSetting` mutation."""
input CreateShopSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `ShopSetting` to be created by this mutation."""
  shopSetting: ShopSettingInput!
}

"""An input for mutations affecting `ShopSetting`"""
input ShopSettingInput {
  id: BigInt
  createdAt: Datetime
  storeName: String
  storePhone: String
  storeHours: String
  country: String
  region: String
  zipcode: String
  city: String
  address: String
  addressTwo: String
  vatNumber: String
  allowState: String
  stateRequiredFor: String
  allowCountries: String
  defaultCountry: String
  optionalZip: String
  europeanUnionCountries: String
  topDestinations: String
  baseCurrency: String
  defaultCurrency: String
  allowedCurrency: String
}

"""The output of our create `Shop` mutation."""
type CreateShopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Shop` that was created by this mutation."""
  shop: Shop
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Shop`. May be used by Relay 1."""
  shopEdge(
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShopsEdge
}

"""All input for the create `Shop` mutation."""
input CreateShopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Shop` to be created by this mutation."""
  shop: ShopInput!
}

"""An input for mutations affecting `Shop`"""
input ShopInput {
  id: BigInt
  name: String!
  description: String
  image: String
  website: String
  products: String
  articles: String
  customers: String
  comments: String
  coupons: String
  categories: String
  polls: String
  quotes: String
  reviews: String
  giftCertificates: String
  rating: String
  tags: String
  users: String
  invoices: String
  reports: String
  rewardPoints: String
  specialDiscounts: String
  statistics: String
  stocks: String
  country: String
  physicalStore: String
  type: String
}

"""The output of our create `SpecialDiscount` mutation."""
type CreateSpecialDiscountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `SpecialDiscount` that was created by this mutation."""
  specialDiscount: SpecialDiscount
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `SpecialDiscount`. May be used by Relay 1."""
  specialDiscountEdge(
    """The method to use when ordering `SpecialDiscount`."""
    orderBy: [SpecialDiscountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SpecialDiscountsEdge
}

"""All input for the create `SpecialDiscount` mutation."""
input CreateSpecialDiscountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `SpecialDiscount` to be created by this mutation."""
  specialDiscount: SpecialDiscountInput!
}

"""An input for mutations affecting `SpecialDiscount`"""
input SpecialDiscountInput {
  id: BigInt
  name: String!
  excerpt: String
  image: String
  published: Datetime
  rewards: String
  coupons: String
  expiration: Date
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  discount: String
}

"""The output of our create `State` mutation."""
type CreateStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `State` that was created by this mutation."""
  state: State
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `State`. May be used by Relay 1."""
  stateEdge(
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatesEdge
}

"""All input for the create `State` mutation."""
input CreateStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `State` to be created by this mutation."""
  state: StateInput!
}

"""An input for mutations affecting `State`"""
input StateInput {
  id: BigInt
  name: String!
  description: String
  country: String
  image: String
}

"""The output of our create `Statistic` mutation."""
type CreateStatisticPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Statistic` that was created by this mutation."""
  statistic: Statistic
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Statistic`. May be used by Relay 1."""
  statisticEdge(
    """The method to use when ordering `Statistic`."""
    orderBy: [StatisticsOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatisticsEdge
}

"""All input for the create `Statistic` mutation."""
input CreateStatisticInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Statistic` to be created by this mutation."""
  statistic: StatisticInput!
}

"""An input for mutations affecting `Statistic`"""
input StatisticInput {
  id: BigInt
  name: String!
  excerpt: String
  description: String
  image: String
  published: Datetime
  specialOffers: String
  reports: String
  rewards: String
  coupons: String
  expiration: Date
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""The output of our create `Stock` mutation."""
type CreateStockPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Stock` that was created by this mutation."""
  stock: Stock
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Stock`. May be used by Relay 1."""
  stockEdge(
    """The method to use when ordering `Stock`."""
    orderBy: [StocksOrderBy!] = [PRIMARY_KEY_ASC]
  ): StocksEdge
}

"""All input for the create `Stock` mutation."""
input CreateStockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Stock` to be created by this mutation."""
  stock: StockInput!
}

"""An input for mutations affecting `Stock`"""
input StockInput {
  id: BigInt
  name: String!
  enabled: Boolean
  description: String
  website: String
  sources: String
}

"""The output of our create `Survey` mutation."""
type CreateSurveyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Survey` that was created by this mutation."""
  survey: Survey
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Survey`. May be used by Relay 1."""
  surveyEdge(
    """The method to use when ordering `Survey`."""
    orderBy: [SurveysOrderBy!] = [PRIMARY_KEY_ASC]
  ): SurveysEdge
}

"""All input for the create `Survey` mutation."""
input CreateSurveyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Survey` to be created by this mutation."""
  survey: SurveyInput!
}

"""An input for mutations affecting `Survey`"""
input SurveyInput {
  id: BigInt
  createdAt: Datetime
  name: String
  assignedTo: String
  status: String
  description: String
  question: String
  answer: String
  submitText: String
  satisfiedText: String
  neitherText: String
  dissatisfiedText: String
}

"""The output of our create `Tag` mutation."""
type CreateTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Tag` that was created by this mutation."""
  tag: Tag
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsEdge
}

"""All input for the create `Tag` mutation."""
input CreateTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Tag` to be created by this mutation."""
  tag: TagInput!
}

"""An input for mutations affecting `Tag`"""
input TagInput {
  id: BigInt
  name: String!
  excerpt: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""The output of our create `Target` mutation."""
type CreateTargetPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Target` that was created by this mutation."""
  target: Target
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Target`. May be used by Relay 1."""
  targetEdge(
    """The method to use when ordering `Target`."""
    orderBy: [TargetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TargetsEdge
}

"""All input for the create `Target` mutation."""
input CreateTargetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Target` to be created by this mutation."""
  target: TargetInput!
}

"""An input for mutations affecting `Target`"""
input TargetInput {
  id: BigInt
  createdAt: Datetime
  prefix: String
  firstName: String
  lastName: String
  department: String
  accountName: String
  address: String
  postalcode: String
  city: String
  state: String
  country: String
  email: String
  description: String
  fax: String
  website: String
  mobile: String
  jobTitle: String
  altAddress: String
  altPostalcode: String
  altCity: String
  altState: String
  altCountry: String
  officePhone: String
  customerName: String
  emailOptOut: String
  donotcall: String
}

"""The output of our create `TaxCategory` mutation."""
type CreateTaxCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TaxCategory` that was created by this mutation."""
  taxCategory: TaxCategory
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `TaxCategory`. May be used by Relay 1."""
  taxCategoryEdge(
    """The method to use when ordering `TaxCategory`."""
    orderBy: [TaxCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxCategoriesEdge
}

"""All input for the create `TaxCategory` mutation."""
input CreateTaxCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `TaxCategory` to be created by this mutation."""
  taxCategory: TaxCategoryInput!
}

"""An input for mutations affecting `TaxCategory`"""
input TaxCategoryInput {
  id: BigInt
  createdAt: Datetime
  name: String
  default: String
}

"""The output of our create `TaxRate` mutation."""
type CreateTaxRatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TaxRate` that was created by this mutation."""
  taxRate: TaxRate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `TaxRate`."""
  productByProdId: Product
  """An edge for our `TaxRate`. May be used by Relay 1."""
  taxRateEdge(
    """The method to use when ordering `TaxRate`."""
    orderBy: [TaxRatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxRatesEdge
}

"""All input for the create `TaxRate` mutation."""
input CreateTaxRateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `TaxRate` to be created by this mutation."""
  taxRate: TaxRateInput!
}

"""An input for mutations affecting `TaxRate`"""
input TaxRateInput {
  id: BigInt
  taxIdentifier: String!
  zipPostIsRange: Boolean
  postcode: String
  state: String
  country: String
  ratePercent: String
  defaultStoreView: String
  prodId: BigInt
}

"""The output of our create `TaxRule` mutation."""
type CreateTaxRulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TaxRule` that was created by this mutation."""
  taxRule: TaxRule
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `TaxRule`."""
  productByProdId: Product
  """An edge for our `TaxRule`. May be used by Relay 1."""
  taxRuleEdge(
    """The method to use when ordering `TaxRule`."""
    orderBy: [TaxRulesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxRulesEdge
}

"""All input for the create `TaxRule` mutation."""
input CreateTaxRuleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `TaxRule` to be created by this mutation."""
  taxRule: TaxRuleInput!
}

"""An input for mutations affecting `TaxRule`"""
input TaxRuleInput {
  id: BigInt
  name: String!
  taxRate: String
  prodId: BigInt
}

"""The output of our create `Theme` mutation."""
type CreateThemePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Theme` that was created by this mutation."""
  theme: Theme
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Website` that is related to this `Theme`."""
  websiteByWebsiteId: Website
  """An edge for our `Theme`. May be used by Relay 1."""
  themeEdge(
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ThemesEdge
}

"""All input for the create `Theme` mutation."""
input CreateThemeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Theme` to be created by this mutation."""
  theme: ThemeInput!
}

"""An input for mutations affecting `Theme`"""
input ThemeInput {
  id: BigInt
  title: String
  parentTheme: String
  themePath: String
  action: String
  websiteId: BigInt
}

"""The output of our create `Ticketing` mutation."""
type CreateTicketingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Ticketing` that was created by this mutation."""
  ticketing: Ticketing
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Ticketing`. May be used by Relay 1."""
  ticketingEdge(
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TicketingsEdge
}

"""All input for the create `Ticketing` mutation."""
input CreateTicketingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Ticketing` to be created by this mutation."""
  ticketing: TicketingInput!
}

"""An input for mutations affecting `Ticketing`"""
input TicketingInput {
  id: BigInt
  createdAt: Datetime
  name: String
  location: String
  date: String
  severity: String
  team: String
  requester: String
  requesterEmail: String
  content: String
  department: String
  media: String
  projects: String
  ticketType: String
  comment: String
  products: String
  priority: String
  status: String
  resolution: String
  assignedTo: String
  dateModified: Datetime
  accountName: String
  level: String
}

"""The output of our create `TodoList` mutation."""
type CreateTodoListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TodoList` that was created by this mutation."""
  todoList: TodoList
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `TodoList`. May be used by Relay 1."""
  todoListEdge(
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TodoListsEdge
}

"""All input for the create `TodoList` mutation."""
input CreateTodoListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `TodoList` to be created by this mutation."""
  todoList: TodoListInput!
}

"""An input for mutations affecting `TodoList`"""
input TodoListInput {
  id: BigInt
  createdAt: Datetime
  subject: String
  startDate: String
  dueDate: String
  priority: String
  description: String
  status: String
  relatedTo: String
  contact: String
  assignedTo: String
  dateModified: Datetime
  task: String
  checklists: String
  visits: String
  projects: String
  tickets: String
  cases: String
  surveys: String
  articles: String
  endofshift: String
  name: String
}

"""The output of our create `Training` mutation."""
type CreateTrainingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Training` that was created by this mutation."""
  training: Training
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Comment` that is related to this `Training`."""
  commentByComment: Comment
  """Reads a single `Country` that is related to this `Training`."""
  countryByCountry: Country
  """Reads a single `State` that is related to this `Training`."""
  stateByState: State
  """Reads a single `Product` that is related to this `Training`."""
  productByProducts: Product
  """Reads a single `Checklist` that is related to this `Training`."""
  checklistByChecklists: Checklist
  """An edge for our `Training`. May be used by Relay 1."""
  trainingEdge(
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TrainingsEdge
}

"""All input for the create `Training` mutation."""
input CreateTrainingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Training` to be created by this mutation."""
  training: TrainingInput!
}

"""An input for mutations affecting `Training`"""
input TrainingInput {
  id: BigInt
  createdAt: Datetime
  name: String
  subject: String
  content: String
  media: String
  link: String
  steps: String
  updated: Datetime
  analytics: String
  competency: String
  course: String
  grade: String
  school: String
  comment: Int
  address: String
  country: Int
  state: Int
  postal: String
  teacher: String
  student: String
  anncouncement: String
  resource: String
  badges: String
  isPublic: String
  isCompleted: String
  speakers: String
  fieldTrips: String
  assignments: String
  assignmentsDueDate: String
  origanlityReport: String
  products: BigInt
  faqs: String
  languages: String
  checklists: BigInt
  city: String
  meetups: String
  lab: String
  digiboards: String
}

"""The output of our create `Transaction` mutation."""
type CreateTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Transaction` that was created by this mutation."""
  transaction: Transaction
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Order` that is related to this `Transaction`."""
  orderByOrderId: Order
  """Reads a single `CustomerPayment` that is related to this `Transaction`."""
  customerPaymentByPaymentMethod: CustomerPayment
  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""All input for the create `Transaction` mutation."""
input CreateTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Transaction` to be created by this mutation."""
  transaction: TransactionInput!
}

"""An input for mutations affecting `Transaction`"""
input TransactionInput {
  id: BigInt
  orderId: Int
  transactionId: Int
  parentTransactionId: Int
  created: Datetime
  paymentMethod: BigInt
  closed: String
}

"""The output of our create `UrlRewrite` mutation."""
type CreateUrlRewritePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `UrlRewrite` that was created by this mutation."""
  urlRewrite: UrlRewrite
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `UrlRewrite`. May be used by Relay 1."""
  urlRewriteEdge(
    """The method to use when ordering `UrlRewrite`."""
    orderBy: [UrlRewritesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UrlRewritesEdge
}

"""All input for the create `UrlRewrite` mutation."""
input CreateUrlRewriteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `UrlRewrite` to be created by this mutation."""
  urlRewrite: UrlRewriteInput!
}

"""An input for mutations affecting `UrlRewrite`"""
input UrlRewriteInput {
  id: BigInt
  requestPath: String
  description: String
  redirectType: Boolean
  targetPath: String
  store: String
}

"""The output of our create `UserRole` mutation."""
type CreateUserRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `UserRole` that was created by this mutation."""
  userRole: UserRole
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `UserRole`. May be used by Relay 1."""
  userRoleEdge(
    """The method to use when ordering `UserRole`."""
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserRolesEdge
}

"""All input for the create `UserRole` mutation."""
input CreateUserRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `UserRole` to be created by this mutation."""
  userRole: UserRoleInput!
}

"""An input for mutations affecting `UserRole`"""
input UserRoleInput {
  id: BigInt
  roleName: String!
  content: String
  createdAt: Datetime
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `User` that was created by this mutation."""
  user: User
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  id: BigInt
  username: String!
  firstName: String!
  lastName: String
  email: String!
  password: String!
  interfaceLocale: String
  value: String
  permissions: String
  createdAt: Datetime
}

"""The output of our create `Visit` mutation."""
type CreateVisitPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Visit` that was created by this mutation."""
  visit: Visit
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Visit`. May be used by Relay 1."""
  visitEdge(
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VisitsEdge
}

"""All input for the create `Visit` mutation."""
input CreateVisitInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Visit` to be created by this mutation."""
  visit: VisitInput!
}

"""An input for mutations affecting `Visit`"""
input VisitInput {
  id: BigInt
  createdAt: Datetime
  location: String
  username: String
  reason: String
  content: String
  emergency: String
  startDate: String
  endDate: String
  task: String
  meeting: String
}

"""The output of our create `Warehouse` mutation."""
type CreateWarehousePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Warehouse` that was created by this mutation."""
  warehouse: Warehouse
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Warehouse`. May be used by Relay 1."""
  warehouseEdge(
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WarehousesEdge
}

"""All input for the create `Warehouse` mutation."""
input CreateWarehouseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Warehouse` to be created by this mutation."""
  warehouse: WarehouseInput!
}

"""An input for mutations affecting `Warehouse`"""
input WarehouseInput {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  city: String
  state: String
  country: String
  postal: String
  status: String
  image: String
  products: String
  category: String
  isPublic: String
}

"""The output of our create `Webhook` mutation."""
type CreateWebhookPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Webhook` that was created by this mutation."""
  webhook: Webhook
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Webhook`. May be used by Relay 1."""
  webhookEdge(
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhooksEdge
}

"""All input for the create `Webhook` mutation."""
input CreateWebhookInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Webhook` to be created by this mutation."""
  webhook: WebhookInput!
}

"""An input for mutations affecting `Webhook`"""
input WebhookInput {
  id: BigInt
  createdAt: Datetime
  name: String!
  url: String!
  headers: String
  create: String
  retrieve: String
  update: String
  delete: String
  publish: String
  unpublish: String
}

"""The output of our create `Website` mutation."""
type CreateWebsitePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Website` that was created by this mutation."""
  website: Website
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Website`. May be used by Relay 1."""
  websiteEdge(
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebsitesEdge
}

"""All input for the create `Website` mutation."""
input CreateWebsiteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Website` to be created by this mutation."""
  website: WebsiteInput!
}

"""An input for mutations affecting `Website`"""
input WebsiteInput {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  shop: String
  store: String
  image: String
  category: String
}

"""The output of our create `Wishlist` mutation."""
type CreateWishlistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Wishlist` that was created by this mutation."""
  wishlist: Wishlist
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Wishlist`. May be used by Relay 1."""
  wishlistEdge(
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): WishlistsEdge
}

"""All input for the create `Wishlist` mutation."""
input CreateWishlistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Wishlist` to be created by this mutation."""
  wishlist: WishlistInput!
}

"""An input for mutations affecting `Wishlist`"""
input WishlistInput {
  id: BigInt
  createdAt: Datetime
  name: String
  customers: String
  visibility: String
  products: String
  quantity: String
}

"""The output of our create `Workspace` mutation."""
type CreateWorkspacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Workspace` that was created by this mutation."""
  workspace: Workspace
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Workspace`."""
  customerByCustomers: Customer
  """Reads a single `User` that is related to this `Workspace`."""
  userByUsers: User
  """Reads a single `Product` that is related to this `Workspace`."""
  productByProducts: Product
  """Reads a single `TodoList` that is related to this `Workspace`."""
  todoListByTasks: TodoList
  """Reads a single `Brand` that is related to this `Workspace`."""
  brandByBrands: Brand
  """Reads a single `Shop` that is related to this `Workspace`."""
  shopByShops: Shop
  """Reads a single `Category` that is related to this `Workspace`."""
  categoryByCategory: Category
  """Reads a single `Project` that is related to this `Workspace`."""
  projectByProjects: Project
  """An edge for our `Workspace`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspacesEdge
}

"""All input for the create `Workspace` mutation."""
input CreateWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Workspace` to be created by this mutation."""
  workspace: WorkspaceInput!
}

"""An input for mutations affecting `Workspace`"""
input WorkspaceInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  description: String
  customers: Int
  users: Int
  products: BigInt
  tasks: BigInt
  brands: BigInt
  shops: Int
  category: Int
  isPublic: Boolean
  projects: BigInt
  author: String
  media: String
}

"""The output of our create `Zone` mutation."""
type CreateZonePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Zone` that was created by this mutation."""
  zone: Zone
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Zone`. May be used by Relay 1."""
  zoneEdge(
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ZonesEdge
}

"""All input for the create `Zone` mutation."""
input CreateZoneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The `Zone` to be created by this mutation."""
  zone: ZoneInput!
}

"""An input for mutations affecting `Zone`"""
input ZoneInput {
  id: BigInt
  createdAt: Datetime
  name: String
  updatedAt: Datetime
  scope: String
  type: String
  country: String
  code: String
}

"""The output of our update `Endofshift` mutation."""
type UpdateEndofshiftPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Endofshift` that was updated by this mutation."""
  endofshift: Endofshift
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Endofshift`. May be used by Relay 1."""
  endofshiftEdge(
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EndofshiftsEdge
}

"""All input for the `updateEndofshift` mutation."""
input UpdateEndofshiftInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Endofshift` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Endofshift` being updated."""
  endofshiftPatch: EndofshiftPatch!
}

"""Represents an update to a `Endofshift`. Fields that are set will be updated."""
input EndofshiftPatch {
  id: BigInt
  createdAt: Datetime
  content: String
  login: String
  mcms: String
  nextShift: String
  projects: String
  tickets: String
  whid: String
}

"""All input for the `updateEndofshiftById` mutation."""
input UpdateEndofshiftByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Endofshift` being updated."""
  endofshiftPatch: EndofshiftPatch!
  id: BigInt!
}

"""The output of our update `_Schema` mutation."""
type UpdateSchemaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `_Schema` that was updated by this mutation."""
  _schema: _Schema
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `_Schema`. May be used by Relay 1."""
  _schemaEdge(
    """The method to use when ordering `_Schema`."""
    orderBy: [_SchemasOrderBy!] = [PRIMARY_KEY_ASC]
  ): _SchemasEdge
}

"""All input for the `updateSchema` mutation."""
input UpdateSchemaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `_Schema` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `_Schema` being updated."""
  _schemaPatch: _SchemaPatch!
}

"""Represents an update to a `_Schema`. Fields that are set will be updated."""
input _SchemaPatch {
  className: String
  schema: JSON
  isParseClass: Boolean
}

"""All input for the `updateSchemaByClassName` mutation."""
input UpdateSchemaByClassNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `_Schema` being updated."""
  _schemaPatch: _SchemaPatch!
  className: String!
}

"""The output of our update `_PrismaMigration` mutation."""
type UpdatePrismaMigrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `_PrismaMigration` that was updated by this mutation."""
  _prismaMigration: _PrismaMigration
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `_PrismaMigration`. May be used by Relay 1."""
  _prismaMigrationEdge(
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): _PrismaMigrationsEdge
}

"""All input for the `updatePrismaMigration` mutation."""
input UpdatePrismaMigrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `_PrismaMigration` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `_PrismaMigration` being updated."""
  _prismaMigrationPatch: _PrismaMigrationPatch!
}

"""Represents an update to a `_PrismaMigration`. Fields that are set will be updated."""
input _PrismaMigrationPatch {
  id: String
  checksum: String
  finishedAt: Datetime
  migrationName: String
  logs: String
  rolledBackAt: Datetime
  startedAt: Datetime
  appliedStepsCount: Int
}

"""All input for the `updatePrismaMigrationById` mutation."""
input UpdatePrismaMigrationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `_PrismaMigration` being updated."""
  _prismaMigrationPatch: _PrismaMigrationPatch!
  id: String!
}

"""The output of our update `Account` mutation."""
type UpdateAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Account` that was updated by this mutation."""
  account: Account
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Account`. May be used by Relay 1."""
  accountEdge(
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge
}

"""All input for the `updateAccount` mutation."""
input UpdateAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Account` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Account` being updated."""
  accountPatch: AccountPatch!
}

"""Represents an update to a `Account`. Fields that are set will be updated."""
input AccountPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  website: String
  officePhone: String
  fax: String
  email: String
  address: String
  postalcode: String
  city: String
  state: String
  country: String
  assignedTo: String
  altAddress: String
  altPostalcode: String
  altCity: String
  altState: String
  altCountry: String
  type: String
  industry: String
  employees: String
  annualRevenue: String
  memberOf: String
  campaign: String
}

"""All input for the `updateAccountById` mutation."""
input UpdateAccountByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Account` being updated."""
  accountPatch: AccountPatch!
  id: BigInt!
}

"""The output of our update `Agreement` mutation."""
type UpdateAgreementPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Agreement` that was updated by this mutation."""
  agreement: Agreement
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Agreement`. May be used by Relay 1."""
  agreementEdge(
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgreementsEdge
}

"""All input for the `updateAgreement` mutation."""
input UpdateAgreementInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Agreement` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Agreement` being updated."""
  agreementPatch: AgreementPatch!
}

"""Represents an update to a `Agreement`. Fields that are set will be updated."""
input AgreementPatch {
  id: BigInt
  referenceId: String
  created: Datetime
  updated: Datetime
  content: String
  name: String
  image: String
  excerpt: String
  type: String
  userId: String
  shopId: String
}

"""All input for the `updateAgreementById` mutation."""
input UpdateAgreementByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Agreement` being updated."""
  agreementPatch: AgreementPatch!
  id: BigInt!
}

"""The output of our update `Analytic` mutation."""
type UpdateAnalyticPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Analytic` that was updated by this mutation."""
  analytic: Analytic
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Analytic`. May be used by Relay 1."""
  analyticEdge(
    """The method to use when ordering `Analytic`."""
    orderBy: [AnalyticsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnalyticsEdge
}

"""All input for the `updateAnalytic` mutation."""
input UpdateAnalyticInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Analytic` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Analytic` being updated."""
  analyticPatch: AnalyticPatch!
}

"""Represents an update to a `Analytic`. Fields that are set will be updated."""
input AnalyticPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  country: String
  shareData: String
  websiteName: String
  clientId: String
  clientSecret: String
  trackingId: String
  propertyName: String
  url: String
  defaultView: String
  category: String
  propertyHit: String
  trackingCode: String
  dataCollection: Boolean
  dataRetention: Boolean
  searchAnalytics: String
}

"""All input for the `updateAnalyticById` mutation."""
input UpdateAnalyticByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Analytic` being updated."""
  analyticPatch: AnalyticPatch!
  id: BigInt!
}

"""The output of our update `Apitoken` mutation."""
type UpdateApitokenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Apitoken` that was updated by this mutation."""
  apitoken: Apitoken
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Apitoken`. May be used by Relay 1."""
  apitokenEdge(
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): ApitokensEdge
}

"""All input for the `updateApitoken` mutation."""
input UpdateApitokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Apitoken` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Apitoken` being updated."""
  apitokenPatch: ApitokenPatch!
}

"""Represents an update to a `Apitoken`. Fields that are set will be updated."""
input ApitokenPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  tokenType: String
  description: String
  token: BigInt
}

"""All input for the `updateApitokenById` mutation."""
input UpdateApitokenByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Apitoken` being updated."""
  apitokenPatch: ApitokenPatch!
  id: BigInt!
}

"""The output of our update `Article` mutation."""
type UpdateArticlePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Article` that was updated by this mutation."""
  article: Article
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Article`. May be used by Relay 1."""
  articleEdge(
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArticlesEdge
}

"""All input for the `updateArticle` mutation."""
input UpdateArticleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Article` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Article` being updated."""
  articlePatch: ArticlePatch!
}

"""Represents an update to a `Article`. Fields that are set will be updated."""
input ArticlePatch {
  id: Int
  name: String
  excerpt: String
  content: String
  image: String
  categories: String
  customers: String
  users: String
  published: String
  custId: Int
  isPublic: String
  metaDescription: String
  metaName: String
  metaUrl: String
  tags: String
}

"""All input for the `updateArticleById` mutation."""
input UpdateArticleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Article` being updated."""
  articlePatch: ArticlePatch!
  id: Int!
}

"""The output of our update `Brand` mutation."""
type UpdateBrandPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Brand` that was updated by this mutation."""
  brand: Brand
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Brand`."""
  productByProduct: Product
  """An edge for our `Brand`. May be used by Relay 1."""
  brandEdge(
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BrandsEdge
}

"""All input for the `updateBrand` mutation."""
input UpdateBrandInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Brand` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Brand` being updated."""
  brandPatch: BrandPatch!
}

"""Represents an update to a `Brand`. Fields that are set will be updated."""
input BrandPatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
}

"""All input for the `updateBrandById` mutation."""
input UpdateBrandByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Brand` being updated."""
  brandPatch: BrandPatch!
  id: BigInt!
}

"""The output of our update `CartPriceRule` mutation."""
type UpdateCartPriceRulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CartPriceRule` that was updated by this mutation."""
  cartPriceRule: CartPriceRule
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CartPriceRule`. May be used by Relay 1."""
  cartPriceRuleEdge(
    """The method to use when ordering `CartPriceRule`."""
    orderBy: [CartPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CartPriceRulesEdge
}

"""All input for the `updateCartPriceRule` mutation."""
input UpdateCartPriceRuleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CartPriceRule` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `CartPriceRule` being updated."""
  cartPriceRulePatch: CartPriceRulePatch!
}

"""Represents an update to a `CartPriceRule`. Fields that are set will be updated."""
input CartPriceRulePatch {
  id: Int
  rule: String
  description: String
  active: Boolean
  coupon: String
  usesPerCustomer: String
  priority: String
  startDate: Date
  endDate: Date
  status: String
  website: String
  actionsApply: String
  actionsDiscountAmount: BigFloat
  actionsDiscardSubsequentRules: Boolean
  actionsMaxQtyDiscountIsAppliedTo: BigFloat
  actionsDiscountQtyStep: BigFloat
  actionsApplyShippingAmount: Boolean
}

"""All input for the `updateCartPriceRuleById` mutation."""
input UpdateCartPriceRuleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `CartPriceRule` being updated."""
  cartPriceRulePatch: CartPriceRulePatch!
  id: Int!
}

"""The output of our update `Case` mutation."""
type UpdateCasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Case` that was updated by this mutation."""
  case: Case
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Case`. May be used by Relay 1."""
  caseEdge(
    """The method to use when ordering `Case`."""
    orderBy: [CasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CasesEdge
}

"""All input for the `updateCase` mutation."""
input UpdateCaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Case` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Case` being updated."""
  casePatch: CasePatch!
}

"""Represents an update to a `Case`. Fields that are set will be updated."""
input CasePatch {
  id: BigInt
  createdAt: Datetime
  caseNumber: Int
  state: String
  type: String
  subject: String
  description: String
  resolution: String
  priority: String
  status: String
  accountName: String
  assignedTo: String
  dateModified: Datetime
}

"""All input for the `updateCaseById` mutation."""
input UpdateCaseByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Case` being updated."""
  casePatch: CasePatch!
  id: BigInt!
}

"""The output of our update `CatalogPriceRule` mutation."""
type UpdateCatalogPriceRulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CatalogPriceRule` that was updated by this mutation."""
  catalogPriceRule: CatalogPriceRule
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CatalogPriceRule`. May be used by Relay 1."""
  catalogPriceRuleEdge(
    """The method to use when ordering `CatalogPriceRule`."""
    orderBy: [CatalogPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CatalogPriceRulesEdge
}

"""All input for the `updateCatalogPriceRule` mutation."""
input UpdateCatalogPriceRuleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CatalogPriceRule` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `CatalogPriceRule` being updated."""
  catalogPriceRulePatch: CatalogPriceRulePatch!
}

"""Represents an update to a `CatalogPriceRule`. Fields that are set will be updated."""
input CatalogPriceRulePatch {
  id: Int
  rule: String
  description: String
  active: Boolean
  customerGroups: String
  priority: String
  startDate: Date
  endDate: Date
  status: String
  website: String
  actionsApply: String
  actionsDiscountAmount: BigFloat
  actionsDiscardSubsequentRules: Boolean
}

"""All input for the `updateCatalogPriceRuleById` mutation."""
input UpdateCatalogPriceRuleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `CatalogPriceRule` being updated."""
  catalogPriceRulePatch: CatalogPriceRulePatch!
  id: Int!
}

"""The output of our update `Category` mutation."""
type UpdateCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Category` that was updated by this mutation."""
  category: Category
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""All input for the `updateCategory` mutation."""
input UpdateCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Category` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Category` being updated."""
  categoryPatch: CategoryPatch!
}

"""Represents an update to a `Category`. Fields that are set will be updated."""
input CategoryPatch {
  id: Int
  thumbnail: String
  name: String
  visibility: String
  status: Boolean
  websites: String
  product: String
  country: String
  description: String
  content: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
}

"""All input for the `updateCategoryById` mutation."""
input UpdateCategoryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Category` being updated."""
  categoryPatch: CategoryPatch!
  id: Int!
}

"""The output of our update `Channel` mutation."""
type UpdateChannelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Channel` that was updated by this mutation."""
  channel: Channel
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Channel`. May be used by Relay 1."""
  channelEdge(
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChannelsEdge
}

"""All input for the `updateChannel` mutation."""
input UpdateChannelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Channel` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Channel` being updated."""
  channelPatch: ChannelPatch!
}

"""Represents an update to a `Channel`. Fields that are set will be updated."""
input ChannelPatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  currency: String
  defaultLang: String
  includeTax: String
  defaultZone: String
  defaultShipping: String
  clientId: String
  clientSecret: String
}

"""All input for the `updateChannelById` mutation."""
input UpdateChannelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Channel` being updated."""
  channelPatch: ChannelPatch!
  id: BigInt!
}

"""The output of our update `Checklist` mutation."""
type UpdateChecklistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Checklist` that was updated by this mutation."""
  checklist: Checklist
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Checklist`. May be used by Relay 1."""
  checklistEdge(
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChecklistsEdge
}

"""All input for the `updateChecklist` mutation."""
input UpdateChecklistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Checklist` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Checklist` being updated."""
  checklistPatch: ChecklistPatch!
}

"""Represents an update to a `Checklist`. Fields that are set will be updated."""
input ChecklistPatch {
  id: BigInt
  createdAt: Datetime
  username: String
  location: String
  regionalManager: String
  manager: String
  description: String
  ticket: String
  project: String
  region: String
  country: String
  media: String
  prodId: String
}

"""All input for the `updateChecklistById` mutation."""
input UpdateChecklistByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Checklist` being updated."""
  checklistPatch: ChecklistPatch!
  id: BigInt!
}

"""The output of our update `City` mutation."""
type UpdateCityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `City` that was updated by this mutation."""
  city: City
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `City`. May be used by Relay 1."""
  cityEdge(
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge
}

"""All input for the `updateCity` mutation."""
input UpdateCityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `City` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `City` being updated."""
  cityPatch: CityPatch!
}

"""Represents an update to a `City`. Fields that are set will be updated."""
input CityPatch {
  id: Int
  name: String
  description: String
  state: String
  country: String
  postalCode: String
  image: String
}

"""All input for the `updateCityById` mutation."""
input UpdateCityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `City` being updated."""
  cityPatch: CityPatch!
  id: Int!
}

"""The output of our update `Collection` mutation."""
type UpdateCollectionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Collection` that was updated by this mutation."""
  collection: Collection
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Collection`. May be used by Relay 1."""
  collectionEdge(
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CollectionsEdge
}

"""All input for the `updateCollection` mutation."""
input UpdateCollectionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Collection` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Collection` being updated."""
  collectionPatch: CollectionPatch!
}

"""Represents an update to a `Collection`. Fields that are set will be updated."""
input CollectionPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  image: String
  product: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
}

"""All input for the `updateCollectionById` mutation."""
input UpdateCollectionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Collection` being updated."""
  collectionPatch: CollectionPatch!
  id: BigInt!
}

"""The output of our update `Comment` mutation."""
type UpdateCommentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Comment` that was updated by this mutation."""
  comment: Comment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Comment`."""
  customerByCustId: Customer
  """An edge for our `Comment`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentsEdge
}

"""All input for the `updateComment` mutation."""
input UpdateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Comment` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Comment` being updated."""
  commentPatch: CommentPatch!
}

"""Represents an update to a `Comment`. Fields that are set will be updated."""
input CommentPatch {
  id: Int
  customerName: String
  description: String
  image: String
  response: String
  published: Datetime
  custId: Int
}

"""All input for the `updateCommentById` mutation."""
input UpdateCommentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Comment` being updated."""
  commentPatch: CommentPatch!
  id: Int!
}

"""The output of our update `ContentType` mutation."""
type UpdateContentTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ContentType` that was updated by this mutation."""
  contentType: ContentType
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `ContentType`. May be used by Relay 1."""
  contentTypeEdge(
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContentTypesEdge
}

"""All input for the `updateContentType` mutation."""
input UpdateContentTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ContentType` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `ContentType` being updated."""
  contentTypePatch: ContentTypePatch!
}

"""Represents an update to a `ContentType`. Fields that are set will be updated."""
input ContentTypePatch {
  id: BigInt
  createdAt: Datetime
  text: String
  number: BigFloat
  json: JSON
  link: String
  email: String
  uid: UUID
  date: Date
  time: Time
  timestamp: Datetime
  boolean: Boolean
  richText: String
  password: String
  media: String
  databaseName: String
}

"""All input for the `updateContentTypeById` mutation."""
input UpdateContentTypeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `ContentType` being updated."""
  contentTypePatch: ContentTypePatch!
  id: BigInt!
}

"""The output of our update `Contract` mutation."""
type UpdateContractPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Contract` that was updated by this mutation."""
  contract: Contract
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Contract`. May be used by Relay 1."""
  contractEdge(
    """The method to use when ordering `Contract`."""
    orderBy: [ContractsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContractsEdge
}

"""All input for the `updateContract` mutation."""
input UpdateContractInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Contract` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Contract` being updated."""
  contractPatch: ContractPatch!
}

"""Represents an update to a `Contract`. Fields that are set will be updated."""
input ContractPatch {
  id: BigInt
  contractTitle: String
  contractValue: String
  startDate: String
  endDate: String
  renewalReminder: String
  customerSignedDate: String
  companySignedDate: String
  status: String
  contractManager: String
  account: String
  contact: String
  description: String
  opportunity: String
  contractType: String
  currency: String
  lineItems: String
  total: String
  discount: String
  subtotal: String
  shipping: String
  shippingTax: String
  tax: String
  grandTotal: String
  createdAt: Datetime
}

"""All input for the `updateContractById` mutation."""
input UpdateContractByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Contract` being updated."""
  contractPatch: ContractPatch!
  id: BigInt!
}

"""The output of our update `Country` mutation."""
type UpdateCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Country` that was updated by this mutation."""
  country: Country
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Country`. May be used by Relay 1."""
  countryEdge(
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge
}

"""All input for the `updateCountry` mutation."""
input UpdateCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Country` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Country` being updated."""
  countryPatch: CountryPatch!
}

"""Represents an update to a `Country`. Fields that are set will be updated."""
input CountryPatch {
  id: Int
  name: String
  description: String
  image: String
  region: String
}

"""All input for the `updateCountryById` mutation."""
input UpdateCountryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Country` being updated."""
  countryPatch: CountryPatch!
  id: Int!
}

"""The output of our update `Coupon` mutation."""
type UpdateCouponPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Coupon` that was updated by this mutation."""
  coupon: Coupon
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Coupon`."""
  productByProdId: Product
  """An edge for our `Coupon`. May be used by Relay 1."""
  couponEdge(
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CouponsEdge
}

"""All input for the `updateCoupon` mutation."""
input UpdateCouponInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Coupon` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Coupon` being updated."""
  couponPatch: CouponPatch!
}

"""Represents an update to a `Coupon`. Fields that are set will be updated."""
input CouponPatch {
  id: BigInt
  name: String
  excerpt: String
  discount: String
  image: String
  published: Datetime
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  prodId: BigInt
}

"""All input for the `updateCouponById` mutation."""
input UpdateCouponByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Coupon` being updated."""
  couponPatch: CouponPatch!
  id: BigInt!
}

"""The output of our update `CreditMemo` mutation."""
type UpdateCreditMemoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CreditMemo` that was updated by this mutation."""
  creditMemo: CreditMemo
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `CreditMemo`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `CreditMemo`."""
  productByProdId: Product
  """An edge for our `CreditMemo`. May be used by Relay 1."""
  creditMemoEdge(
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!] = [PRIMARY_KEY_ASC]
  ): CreditMemosEdge
}

"""All input for the `updateCreditMemo` mutation."""
input UpdateCreditMemoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CreditMemo` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `CreditMemo` being updated."""
  creditMemoPatch: CreditMemoPatch!
}

"""Represents an update to a `CreditMemo`. Fields that are set will be updated."""
input CreditMemoPatch {
  creditMemo: String
  orderNumber: Int
  created: Datetime
  billToName: String
  status: String
  refunded: String
  action: String
  id: BigInt
  custId: Int
  prodId: BigInt
}

"""All input for the `updateCreditMemoByCreditMemoAndId` mutation."""
input UpdateCreditMemoByCreditMemoAndIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `CreditMemo` being updated."""
  creditMemoPatch: CreditMemoPatch!
  creditMemo: String!
  id: BigInt!
}

"""The output of our update `Currency` mutation."""
type UpdateCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Currency` that was updated by this mutation."""
  currency: Currency
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
}

"""All input for the `updateCurrency` mutation."""
input UpdateCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Currency` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Currency` being updated."""
  currencyPatch: CurrencyPatch!
}

"""Represents an update to a `Currency`. Fields that are set will be updated."""
input CurrencyPatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  region: String
}

"""All input for the `updateCurrencyById` mutation."""
input UpdateCurrencyByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Currency` being updated."""
  currencyPatch: CurrencyPatch!
  id: BigInt!
}

"""The output of our update `CurrencyRate` mutation."""
type UpdateCurrencyRatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CurrencyRate` that was updated by this mutation."""
  currencyRate: CurrencyRate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CurrencyRate`. May be used by Relay 1."""
  currencyRateEdge(
    """The method to use when ordering `CurrencyRate`."""
    orderBy: [CurrencyRatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencyRatesEdge
}

"""All input for the `updateCurrencyRate` mutation."""
input UpdateCurrencyRateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CurrencyRate` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `CurrencyRate` being updated."""
  currencyRatePatch: CurrencyRatePatch!
}

"""Represents an update to a `CurrencyRate`. Fields that are set will be updated."""
input CurrencyRatePatch {
  importService: String
  usd: Float
  id: BigInt
}

"""All input for the `updateCurrencyRateByImportService` mutation."""
input UpdateCurrencyRateByImportServiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `CurrencyRate` being updated."""
  currencyRatePatch: CurrencyRatePatch!
  importService: String!
}

"""All input for the `updateCurrencyRateById` mutation."""
input UpdateCurrencyRateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `CurrencyRate` being updated."""
  currencyRatePatch: CurrencyRatePatch!
  id: BigInt!
}

"""The output of our update `CurrencySymbol` mutation."""
type UpdateCurrencySymbolPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CurrencySymbol` that was updated by this mutation."""
  currencySymbol: CurrencySymbol
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CurrencySymbol`. May be used by Relay 1."""
  currencySymbolEdge(
    """The method to use when ordering `CurrencySymbol`."""
    orderBy: [CurrencySymbolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencySymbolsEdge
}

"""All input for the `updateCurrencySymbol` mutation."""
input UpdateCurrencySymbolInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CurrencySymbol` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `CurrencySymbol` being updated."""
  currencySymbolPatch: CurrencySymbolPatch!
}

"""Represents an update to a `CurrencySymbol`. Fields that are set will be updated."""
input CurrencySymbolPatch {
  symbol: String
  useStandard: Boolean
  id: BigInt
}

"""All input for the `updateCurrencySymbolBySymbol` mutation."""
input UpdateCurrencySymbolBySymbolInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `CurrencySymbol` being updated."""
  currencySymbolPatch: CurrencySymbolPatch!
  symbol: String!
}

"""All input for the `updateCurrencySymbolById` mutation."""
input UpdateCurrencySymbolByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `CurrencySymbol` being updated."""
  currencySymbolPatch: CurrencySymbolPatch!
  id: BigInt!
}

"""The output of our update `CustomerGroup` mutation."""
type UpdateCustomerGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CustomerGroup` that was updated by this mutation."""
  customerGroup: CustomerGroup
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `CustomerGroup`."""
  customerByCustId: Customer
  """An edge for our `CustomerGroup`. May be used by Relay 1."""
  customerGroupEdge(
    """The method to use when ordering `CustomerGroup`."""
    orderBy: [CustomerGroupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomerGroupsEdge
}

"""All input for the `updateCustomerGroup` mutation."""
input UpdateCustomerGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CustomerGroup` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `CustomerGroup` being updated."""
  customerGroupPatch: CustomerGroupPatch!
}

"""Represents an update to a `CustomerGroup`. Fields that are set will be updated."""
input CustomerGroupPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  taxClass: String
  custId: Int
}

"""All input for the `updateCustomerGroupById` mutation."""
input UpdateCustomerGroupByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `CustomerGroup` being updated."""
  customerGroupPatch: CustomerGroupPatch!
  id: BigInt!
}

"""The output of our update `CustomerPayment` mutation."""
type UpdateCustomerPaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CustomerPayment` that was updated by this mutation."""
  customerPayment: CustomerPayment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `CustomerPayment`."""
  customerByCustId: Customer
  """An edge for our `CustomerPayment`. May be used by Relay 1."""
  customerPaymentEdge(
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomerPaymentsEdge
}

"""All input for the `updateCustomerPayment` mutation."""
input UpdateCustomerPaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CustomerPayment` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `CustomerPayment` being updated."""
  customerPaymentPatch: CustomerPaymentPatch!
}

"""Represents an update to a `CustomerPayment`. Fields that are set will be updated."""
input CustomerPaymentPatch {
  id: BigInt
  createdAt: Datetime
  custId: Int
  paymentInfo: String
  provider: String
  accountNo: BigInt
  expiry: BigInt
}

"""All input for the `updateCustomerPaymentById` mutation."""
input UpdateCustomerPaymentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `CustomerPayment` being updated."""
  customerPaymentPatch: CustomerPaymentPatch!
  id: BigInt!
}

"""The output of our update `Customer` mutation."""
type UpdateCustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Customer` that was updated by this mutation."""
  customer: Customer
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Customer`. May be used by Relay 1."""
  customerEdge(
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersEdge
}

"""All input for the `updateCustomer` mutation."""
input UpdateCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Customer` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Customer` being updated."""
  customerPatch: CustomerPatch!
}

"""Represents an update to a `Customer`. Fields that are set will be updated."""
input CustomerPatch {
  id: Int
  thumbnail: String
  namePrefix: String
  firstName: String
  middleName: String
  lastName: String
  email: String
  customerGroup: String
  phone: String
  zipcode: String
  nameSuffix: String
  websites: String
  product: String
  country: String
  state: String
  customerSince: Datetime
  confirmedEmail: String
  dateOfBirth: String
  taxVatNumber: String
  gender: String
  description: String
  shortDescription: String
  image: String
  address: String
  addressTwo: String
  paymentType: String
  username: String
  password: String
}

"""All input for the `updateCustomerById` mutation."""
input UpdateCustomerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Customer` being updated."""
  customerPatch: CustomerPatch!
  id: Int!
}

"""The output of our update `Customization` mutation."""
type UpdateCustomizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Customization` that was updated by this mutation."""
  customization: Customization
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Customization`. May be used by Relay 1."""
  customizationEdge(
    """The method to use when ordering `Customization`."""
    orderBy: [CustomizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomizationsEdge
}

"""All input for the `updateCustomization` mutation."""
input UpdateCustomizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Customization` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Customization` being updated."""
  customizationPatch: CustomizationPatch!
}

"""Represents an update to a `Customization`. Fields that are set will be updated."""
input CustomizationPatch {
  id: Int
  createdAt: Datetime
  siteName: String
  navLink: String
  notification: String
  banner: String
  footerLink: String
  announcement: String
  email: String
  siteUrl: String
  allowSignup: String
}

"""All input for the `updateCustomizationById` mutation."""
input UpdateCustomizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Customization` being updated."""
  customizationPatch: CustomizationPatch!
  id: Int!
}

"""The output of our update `Dashboard` mutation."""
type UpdateDashboardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Dashboard` that was updated by this mutation."""
  dashboard: Dashboard
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Dashboard`. May be used by Relay 1."""
  dashboardEdge(
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DashboardsEdge
}

"""All input for the `updateDashboard` mutation."""
input UpdateDashboardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Dashboard` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Dashboard` being updated."""
  dashboardPatch: DashboardPatch!
}

"""Represents an update to a `Dashboard`. Fields that are set will be updated."""
input DashboardPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  clientId: String
  clientSecret: String
  privacy: String
  category: String
  url: String
  media: String
  task: String
  reports: String
  tasks: String
  projects: String
  tickets: String
  customers: String
  checklists: String
  visits: String
  users: String
  products: String
  articles: String
  sales: String
}

"""All input for the `updateDashboardById` mutation."""
input UpdateDashboardByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Dashboard` being updated."""
  dashboardPatch: DashboardPatch!
  id: BigInt!
}

"""The output of our update `Deepdive` mutation."""
type UpdateDeepdivePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Deepdive` that was updated by this mutation."""
  deepdive: Deepdive
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Deepdive`. May be used by Relay 1."""
  deepdiveEdge(
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DeepdivesEdge
}

"""All input for the `updateDeepdive` mutation."""
input UpdateDeepdiveInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Deepdive` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Deepdive` being updated."""
  deepdivePatch: DeepdivePatch!
}

"""Represents an update to a `Deepdive`. Fields that are set will be updated."""
input DeepdivePatch {
  id: BigInt
  createdAt: Datetime
  endDate: String
  content: String
  attendees: String
  login: String
  startDate: String
  whid: String
}

"""All input for the `updateDeepdiveById` mutation."""
input UpdateDeepdiveByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Deepdive` being updated."""
  deepdivePatch: DeepdivePatch!
  id: BigInt!
}

"""The output of our update `EmailTemplate` mutation."""
type UpdateEmailTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `EmailTemplate` that was updated by this mutation."""
  emailTemplate: EmailTemplate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `EmailTemplate`. May be used by Relay 1."""
  emailTemplateEdge(
    """The method to use when ordering `EmailTemplate`."""
    orderBy: [EmailTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmailTemplatesEdge
}

"""All input for the `updateEmailTemplate` mutation."""
input UpdateEmailTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `EmailTemplate` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `EmailTemplate` being updated."""
  emailTemplatePatch: EmailTemplatePatch!
}

"""Represents an update to a `EmailTemplate`. Fields that are set will be updated."""
input EmailTemplatePatch {
  id: BigInt
  createdAt: Datetime
  name: String
  assignedTo: String
  type: String
  active: String
  insertVariable: String
  subject: String
  content: String
  header: String
  footer: String
  width: String
  height: String
  media: String
}

"""All input for the `updateEmailTemplateById` mutation."""
input UpdateEmailTemplateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `EmailTemplate` being updated."""
  emailTemplatePatch: EmailTemplatePatch!
  id: BigInt!
}

"""The output of our update `Email` mutation."""
type UpdateEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Email` that was updated by this mutation."""
  email: Email
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Email`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Email`."""
  userByStaffId: User
  """An edge for our `Email`. May be used by Relay 1."""
  emailEdge(
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmailsEdge
}

"""All input for the `updateEmail` mutation."""
input UpdateEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Email` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Email` being updated."""
  emailPatch: EmailPatch!
}

"""Represents an update to a `Email`. Fields that are set will be updated."""
input EmailPatch {
  id: Int
  createdAt: Datetime
  subject: String
  content: String
  custId: Int
  bcc: String
  cc: String
  from: String
  media: String
  staffId: Int
}

"""All input for the `updateEmailById` mutation."""
input UpdateEmailByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Email` being updated."""
  emailPatch: EmailPatch!
  id: Int!
}

"""The output of our update `Event` mutation."""
type UpdateEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Event` that was updated by this mutation."""
  event: Event
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the `updateEvent` mutation."""
input UpdateEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Event` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Event` being updated."""
  eventPatch: EventPatch!
}

"""Represents an update to a `Event`. Fields that are set will be updated."""
input EventPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  tickets: String
  image: String
  start: String
  end: String
  category: String
  city: String
  state: String
  country: String
  postalcode: String
}

"""All input for the `updateEventById` mutation."""
input UpdateEventByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Event` being updated."""
  eventPatch: EventPatch!
  id: BigInt!
}

"""The output of our update `Fullfillment` mutation."""
type UpdateFullfillmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Fullfillment` that was updated by this mutation."""
  fullfillment: Fullfillment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Fullfillment`. May be used by Relay 1."""
  fullfillmentEdge(
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FullfillmentsEdge
}

"""All input for the `updateFullfillment` mutation."""
input UpdateFullfillmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Fullfillment` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Fullfillment` being updated."""
  fullfillmentPatch: FullfillmentPatch!
}

"""Represents an update to a `Fullfillment`. Fields that are set will be updated."""
input FullfillmentPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  shippingZones: String
  company: String
  address: String
  addressTwo: String
  city: String
  state: String
  zipcode: String
  country: String
  countryArea: String
  phone: String
  pickup: String
  stock: String
}

"""All input for the `updateFullfillmentById` mutation."""
input UpdateFullfillmentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Fullfillment` being updated."""
  fullfillmentPatch: FullfillmentPatch!
  id: BigInt!
}

"""The output of our update `GeneralSetting` mutation."""
type UpdateGeneralSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `GeneralSetting` that was updated by this mutation."""
  generalSetting: GeneralSetting
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `GeneralSetting`. May be used by Relay 1."""
  generalSettingEdge(
    """The method to use when ordering `GeneralSetting`."""
    orderBy: [GeneralSettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GeneralSettingsEdge
}

"""All input for the `updateGeneralSetting` mutation."""
input UpdateGeneralSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `GeneralSetting` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `GeneralSetting` being updated."""
  generalSettingPatch: GeneralSettingPatch!
}

"""Represents an update to a `GeneralSetting`. Fields that are set will be updated."""
input GeneralSettingPatch {
  id: BigInt
  createdAt: Datetime
  title: String
  tagline: String
  url: String
  email: String
  accessRestrictions: String
  restrictionMode: String
  startupPage: String
  landingPage: String
  httpResponse: String
  storeEmail: String
  storeContact: String
  storeContactTwo: String
  customerSupport: String
}

"""All input for the `updateGeneralSettingById` mutation."""
input UpdateGeneralSettingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `GeneralSetting` being updated."""
  generalSettingPatch: GeneralSettingPatch!
  id: BigInt!
}

"""The output of our update `GiftCertificate` mutation."""
type UpdateGiftCertificatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `GiftCertificate` that was updated by this mutation."""
  giftCertificate: GiftCertificate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `GiftCertificate`. May be used by Relay 1."""
  giftCertificateEdge(
    """The method to use when ordering `GiftCertificate`."""
    orderBy: [GiftCertificatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GiftCertificatesEdge
}

"""All input for the `updateGiftCertificate` mutation."""
input UpdateGiftCertificateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `GiftCertificate` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `GiftCertificate` being updated."""
  giftCertificatePatch: GiftCertificatePatch!
}

"""Represents an update to a `GiftCertificate`. Fields that are set will be updated."""
input GiftCertificatePatch {
  id: BigInt
  name: String
  excerpt: String
  discount: String
  image: String
  published: Datetime
  specialOffers: String
  rewards: String
  coupons: String
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  type: String
}

"""All input for the `updateGiftCertificateById` mutation."""
input UpdateGiftCertificateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `GiftCertificate` being updated."""
  giftCertificatePatch: GiftCertificatePatch!
  id: BigInt!
}

"""The output of our update `Glossary` mutation."""
type UpdateGlossaryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Glossary` that was updated by this mutation."""
  glossary: Glossary
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Glossary`. May be used by Relay 1."""
  glossaryEdge(
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GlossariesEdge
}

"""All input for the `updateGlossary` mutation."""
input UpdateGlossaryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Glossary` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Glossary` being updated."""
  glossaryPatch: GlossaryPatch!
}

"""Represents an update to a `Glossary`. Fields that are set will be updated."""
input GlossaryPatch {
  id: Int
  name: String
  content: String
  image: String
  published: Datetime
}

"""All input for the `updateGlossaryById` mutation."""
input UpdateGlossaryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Glossary` being updated."""
  glossaryPatch: GlossaryPatch!
  id: Int!
}

"""The output of our update `Importm` mutation."""
type UpdateImportmPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Importm` that was updated by this mutation."""
  importm: Importm
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Importm`. May be used by Relay 1."""
  importmEdge(
    """The method to use when ordering `Importm`."""
    orderBy: [ImportmsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImportmsEdge
}

"""All input for the `updateImportm` mutation."""
input UpdateImportmInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Importm` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Importm` being updated."""
  importmPatch: ImportmPatch!
}

"""Represents an update to a `Importm`. Fields that are set will be updated."""
input ImportmPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  file: String
  url: String
  image: String
}

"""All input for the `updateImportmById` mutation."""
input UpdateImportmByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Importm` being updated."""
  importmPatch: ImportmPatch!
  id: BigInt!
}

"""The output of our update `Integration` mutation."""
type UpdateIntegrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Integration` that was updated by this mutation."""
  integration: Integration
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Integration`. May be used by Relay 1."""
  integrationEdge(
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): IntegrationsEdge
}

"""All input for the `updateIntegration` mutation."""
input UpdateIntegrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Integration` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Integration` being updated."""
  integrationPatch: IntegrationPatch!
}

"""Represents an update to a `Integration`. Fields that are set will be updated."""
input IntegrationPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  media: String
  location: String
  category: String
}

"""All input for the `updateIntegrationById` mutation."""
input UpdateIntegrationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Integration` being updated."""
  integrationPatch: IntegrationPatch!
  id: BigInt!
}

"""The output of our update `Internalization` mutation."""
type UpdateInternalizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Internalization` that was updated by this mutation."""
  internalization: Internalization
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Internalization`. May be used by Relay 1."""
  internalizationEdge(
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InternalizationsEdge
}

"""All input for the `updateInternalization` mutation."""
input UpdateInternalizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Internalization` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Internalization` being updated."""
  internalizationPatch: InternalizationPatch!
}

"""Represents an update to a `Internalization`. Fields that are set will be updated."""
input InternalizationPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  region: String
  description: String
  default: String
  website: String
}

"""All input for the `updateInternalizationById` mutation."""
input UpdateInternalizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Internalization` being updated."""
  internalizationPatch: InternalizationPatch!
  id: BigInt!
}

"""The output of our update `Invitation` mutation."""
type UpdateInvitationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Invitation` that was updated by this mutation."""
  invitation: Invitation
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Invitation`. May be used by Relay 1."""
  invitationEdge(
    """The method to use when ordering `Invitation`."""
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsEdge
}

"""All input for the `updateInvitation` mutation."""
input UpdateInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Invitation` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Invitation` being updated."""
  invitationPatch: InvitationPatch!
}

"""Represents an update to a `Invitation`. Fields that are set will be updated."""
input InvitationPatch {
  id: BigInt
  createdAt: Datetime
  invoiceDate: Datetime
  email: String
  billingAddress: String
  shippingAddress: String
  orderNumber: String
  grandTotalPurchased: String
  paymentMethod: String
  status: String
  media: String
  content: String
}

"""All input for the `updateInvitationById` mutation."""
input UpdateInvitationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Invitation` being updated."""
  invitationPatch: InvitationPatch!
  id: BigInt!
}

"""The output of our update `Invoice` mutation."""
type UpdateInvoicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Invoice` that was updated by this mutation."""
  invoice: Invoice
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Invoice`. May be used by Relay 1."""
  invoiceEdge(
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvoicesEdge
}

"""All input for the `updateInvoice` mutation."""
input UpdateInvoiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Invoice` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Invoice` being updated."""
  invoicePatch: InvoicePatch!
}

"""Represents an update to a `Invoice`. Fields that are set will be updated."""
input InvoicePatch {
  invoice: Int
  orderNumber: BigInt
  invoiceDate: Datetime
  billToName: String
  billingAddress: String
  grandTotalBase: String
  grandTotalPurchased: String
  status: String
  shippingAddress: String
  customerName: String
  email: String
  customerGroup: String
  paymentMethod: String
  shippingInformation: String
  subtotal: String
  shippingAndHandling: String
  id: BigInt
}

"""All input for the `updateInvoiceById` mutation."""
input UpdateInvoiceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Invoice` being updated."""
  invoicePatch: InvoicePatch!
  id: BigInt!
}

"""The output of our update `Knowledgebase` mutation."""
type UpdateKnowledgebasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Knowledgebase` that was updated by this mutation."""
  knowledgebase: Knowledgebase
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Knowledgebase`. May be used by Relay 1."""
  knowledgebaseEdge(
    """The method to use when ordering `Knowledgebase`."""
    orderBy: [KnowledgebasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): KnowledgebasesEdge
}

"""All input for the `updateKnowledgebase` mutation."""
input UpdateKnowledgebaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Knowledgebase` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Knowledgebase` being updated."""
  knowledgebasePatch: KnowledgebasePatch!
}

"""Represents an update to a `Knowledgebase`. Fields that are set will be updated."""
input KnowledgebasePatch {
  id: BigInt
  createdAt: Datetime
  name: String
  status: String
  revision: String
  content: String
  resolution: String
  author: String
  approver: String
  dateModified: Datetime
}

"""All input for the `updateKnowledgebaseById` mutation."""
input UpdateKnowledgebaseByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Knowledgebase` being updated."""
  knowledgebasePatch: KnowledgebasePatch!
  id: BigInt!
}

"""The output of our update `Lead` mutation."""
type UpdateLeadPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Lead` that was updated by this mutation."""
  lead: Lead
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Lead`. May be used by Relay 1."""
  leadEdge(
    """The method to use when ordering `Lead`."""
    orderBy: [LeadsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LeadsEdge
}

"""All input for the `updateLead` mutation."""
input UpdateLeadInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Lead` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Lead` being updated."""
  leadPatch: LeadPatch!
}

"""Represents an update to a `Lead`. Fields that are set will be updated."""
input LeadPatch {
  id: BigInt
  createdAt: Datetime
  prefix: String
  firstName: String
  lastName: String
  department: String
  accountName: String
  address: String
  postalcode: String
  city: String
  state: String
  country: String
  email: String
  description: String
  fax: String
  website: String
  mobile: String
  jobTitle: String
  altAddress: String
  altPostalcode: String
  altCity: String
  altState: String
  altCountry: String
  officePhone: String
  status: String
  statusDescription: String
  opportunityAmount: String
  campaign: String
  leadSource: String
  leadSourceDescription: String
  referredBy: String
  customerName: String
}

"""All input for the `updateLeadById` mutation."""
input UpdateLeadByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Lead` being updated."""
  leadPatch: LeadPatch!
  id: BigInt!
}

"""The output of our update `Manufacturer` mutation."""
type UpdateManufacturerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Manufacturer` that was updated by this mutation."""
  manufacturer: Manufacturer
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Manufacturer`."""
  productByProduct: Product
  """An edge for our `Manufacturer`. May be used by Relay 1."""
  manufacturerEdge(
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ManufacturersEdge
}

"""All input for the `updateManufacturer` mutation."""
input UpdateManufacturerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Manufacturer` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Manufacturer` being updated."""
  manufacturerPatch: ManufacturerPatch!
}

"""Represents an update to a `Manufacturer`. Fields that are set will be updated."""
input ManufacturerPatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
}

"""All input for the `updateManufacturerById` mutation."""
input UpdateManufacturerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Manufacturer` being updated."""
  manufacturerPatch: ManufacturerPatch!
  id: BigInt!
}

"""The output of our update `Mediamanager` mutation."""
type UpdateMediamanagerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Mediamanager` that was updated by this mutation."""
  mediamanager: Mediamanager
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Brand` that is related to this `Mediamanager`."""
  brandByBrands: Brand
  """Reads a single `Customer` that is related to this `Mediamanager`."""
  customerByAuthor: Customer
  """Reads a single `Agreement` that is related to this `Mediamanager`."""
  agreementByAgreements: Agreement
  """Reads a single `Comment` that is related to this `Mediamanager`."""
  commentByComment: Comment
  """Reads a single `TodoList` that is related to this `Mediamanager`."""
  todoListByTaskName: TodoList
  """Reads a single `User` that is related to this `Mediamanager`."""
  userByMembers: User
  """Reads a single `Product` that is related to this `Mediamanager`."""
  productByProducts: Product
  """An edge for our `Mediamanager`. May be used by Relay 1."""
  mediamanagerEdge(
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
  ): MediamanagersEdge
}

"""All input for the `updateMediamanager` mutation."""
input UpdateMediamanagerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Mediamanager` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Mediamanager` being updated."""
  mediamanagerPatch: MediamanagerPatch!
}

"""Represents an update to a `Mediamanager`. Fields that are set will be updated."""
input MediamanagerPatch {
  id: Int
  createdAt: Datetime
  name: String
  description: String
  media: String
  keywords: String
  tags: String
  brands: BigInt
  status: String
  expirationDate: String
  copyright: String
  dimensions: String
  author: Int
  contentType: String
  versions: String
  watermarkName: String
  watermarkDescription: String
  watermarkMedia: String
  agreements: Int
  albums: String
  comment: Int
  workspace: String
  taskName: BigInt
  taskDescription: String
  taskType: String
  members: Int
  products: BigInt
}

"""All input for the `updateMediamanagerById` mutation."""
input UpdateMediamanagerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Mediamanager` being updated."""
  mediamanagerPatch: MediamanagerPatch!
  id: Int!
}

"""The output of our update `Meeting` mutation."""
type UpdateMeetingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Meeting` that was updated by this mutation."""
  meeting: Meeting
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Meeting`. May be used by Relay 1."""
  meetingEdge(
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeetingsEdge
}

"""All input for the `updateMeeting` mutation."""
input UpdateMeetingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Meeting` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Meeting` being updated."""
  meetingPatch: MeetingPatch!
}

"""Represents an update to a `Meeting`. Fields that are set will be updated."""
input MeetingPatch {
  id: BigInt
  createdAt: Datetime
  subject: String
  startDate: String
  endDate: String
  duration: String
  status: String
  relatedTo: String
  reminders: String
  content: String
  assignedTo: String
  invitees: String
  scheduling: String
}

"""All input for the `updateMeetingById` mutation."""
input UpdateMeetingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Meeting` being updated."""
  meetingPatch: MeetingPatch!
  id: BigInt!
}

"""The output of our update `Message` mutation."""
type UpdateMessagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Message` that was updated by this mutation."""
  message: Message
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Message`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Message`."""
  userByStaffId: User
  """An edge for our `Message`. May be used by Relay 1."""
  messageEdge(
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessagesEdge
}

"""All input for the `updateMessage` mutation."""
input UpdateMessageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Message` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Message` being updated."""
  messagePatch: MessagePatch!
}

"""Represents an update to a `Message`. Fields that are set will be updated."""
input MessagePatch {
  id: Int
  from: String
  createdAt: Datetime
  subject: String
  content: String
  sender: String
  custId: Int
  media: String
  staffId: Int
}

"""All input for the `updateMessageById` mutation."""
input UpdateMessageByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Message` being updated."""
  messagePatch: MessagePatch!
  id: Int!
}

"""The output of our update `NewsletterSubscriber` mutation."""
type UpdateNewsletterSubscriberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `NewsletterSubscriber` that was updated by this mutation."""
  newsletterSubscriber: NewsletterSubscriber
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `NewsletterSubscriber`."""
  customerByCustId: Customer
  """An edge for our `NewsletterSubscriber`. May be used by Relay 1."""
  newsletterSubscriberEdge(
    """The method to use when ordering `NewsletterSubscriber`."""
    orderBy: [NewsletterSubscribersOrderBy!] = [PRIMARY_KEY_ASC]
  ): NewsletterSubscribersEdge
}

"""All input for the `updateNewsletterSubscriber` mutation."""
input UpdateNewsletterSubscriberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `NewsletterSubscriber` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `NewsletterSubscriber` being updated."""
  newsletterSubscriberPatch: NewsletterSubscriberPatch!
}

"""Represents an update to a `NewsletterSubscriber`. Fields that are set will be updated."""
input NewsletterSubscriberPatch {
  id: Int
  email: String
  customerFirstName: String
  customerLastName: String
  store: String
  status: String
  websites: String
  createdAt: Datetime
  custId: Int
}

"""All input for the `updateNewsletterSubscriberById` mutation."""
input UpdateNewsletterSubscriberByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `NewsletterSubscriber` being updated."""
  newsletterSubscriberPatch: NewsletterSubscriberPatch!
  id: Int!
}

"""The output of our update `Occassion` mutation."""
type UpdateOccassionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Occassion` that was updated by this mutation."""
  occassion: Occassion
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Occassion`."""
  productByProducts: Product
  """Reads a single `Wishlist` that is related to this `Occassion`."""
  wishlistByWishlists: Wishlist
  """An edge for our `Occassion`. May be used by Relay 1."""
  occassionEdge(
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OccassionsEdge
}

"""All input for the `updateOccassion` mutation."""
input UpdateOccassionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Occassion` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Occassion` being updated."""
  occassionPatch: OccassionPatch!
}

"""Represents an update to a `Occassion`. Fields that are set will be updated."""
input OccassionPatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  category: String
  tags: String
  description: String
  products: BigInt
  wishlists: BigInt
}

"""All input for the `updateOccassionById` mutation."""
input UpdateOccassionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Occassion` being updated."""
  occassionPatch: OccassionPatch!
  id: BigInt!
}

"""The output of our update `Ooto` mutation."""
type UpdateOotoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Ooto` that was updated by this mutation."""
  ooto: Ooto
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Ooto`. May be used by Relay 1."""
  ootoEdge(
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!] = [PRIMARY_KEY_ASC]
  ): OotosEdge
}

"""All input for the `updateOoto` mutation."""
input UpdateOotoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Ooto` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Ooto` being updated."""
  ootoPatch: OotoPatch!
}

"""Represents an update to a `Ooto`. Fields that are set will be updated."""
input OotoPatch {
  id: BigInt
  createdAt: Datetime
  login: String
  startDate: String
  endDate: String
  note: String
  usingTime: String
  location: String
}

"""All input for the `updateOotoById` mutation."""
input UpdateOotoByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Ooto` being updated."""
  ootoPatch: OotoPatch!
  id: BigInt!
}

"""The output of our update `Opportunity` mutation."""
type UpdateOpportunityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Opportunity` that was updated by this mutation."""
  opportunity: Opportunity
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Opportunity`. May be used by Relay 1."""
  opportunityEdge(
    """The method to use when ordering `Opportunity`."""
    orderBy: [OpportunitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OpportunitiesEdge
}

"""All input for the `updateOpportunity` mutation."""
input UpdateOpportunityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Opportunity` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Opportunity` being updated."""
  opportunityPatch: OpportunityPatch!
}

"""Represents an update to a `Opportunity`. Fields that are set will be updated."""
input OpportunityPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  amount: String
  salesStage: String
  currency: String
  probability: String
  nextStep: String
  description: String
  assignedTo: String
  leadSource: String
  campaign: String
  type: String
  accountName: String
  expectedCloseDate: String
}

"""All input for the `updateOpportunityById` mutation."""
input UpdateOpportunityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Opportunity` being updated."""
  opportunityPatch: OpportunityPatch!
  id: BigInt!
}

"""The output of our update `Order` mutation."""
type UpdateOrderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Order` that was updated by this mutation."""
  order: Order
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Order`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `Order`."""
  productByProdId: Product
  """An edge for our `Order`. May be used by Relay 1."""
  orderEdge(
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrdersEdge
}

"""All input for the `updateOrder` mutation."""
input UpdateOrderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Order` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Order` being updated."""
  orderPatch: OrderPatch!
}

"""Represents an update to a `Order`. Fields that are set will be updated."""
input OrderPatch {
  id: Int
  purchasePoint: Int
  purchaseDate: Datetime
  billToName: String
  shipToName: String
  grandTotalBase: Int
  grandTotalPurchased: Int
  status: Boolean
  action: Boolean
  allocatedSources: String
  braintreeTransactionSource: String
  custId: Int
  prodId: BigInt
}

"""All input for the `updateOrderById` mutation."""
input UpdateOrderByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Order` being updated."""
  orderPatch: OrderPatch!
  id: Int!
}

"""The output of our update `Page` mutation."""
type UpdatePagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Page` that was updated by this mutation."""
  page: Page
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Page`. May be used by Relay 1."""
  pageEdge(
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PagesEdge
}

"""All input for the `updatePage` mutation."""
input UpdatePageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Page` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Page` being updated."""
  pagePatch: PagePatch!
}

"""Represents an update to a `Page`. Fields that are set will be updated."""
input PagePatch {
  id: BigInt
  enablePage: Boolean
  title: String
  contentTitle: String
  content: String
  urlKey: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  createdAt: Datetime
}

"""All input for the `updatePageById` mutation."""
input UpdatePageByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Page` being updated."""
  pagePatch: PagePatch!
  id: BigInt!
}

"""The output of our update `Partner` mutation."""
type UpdatePartnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Partner` that was updated by this mutation."""
  partner: Partner
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Partner`. May be used by Relay 1."""
  partnerEdge(
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnersEdge
}

"""All input for the `updatePartner` mutation."""
input UpdatePartnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Partner` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Partner` being updated."""
  partnerPatch: PartnerPatch!
}

"""Represents an update to a `Partner`. Fields that are set will be updated."""
input PartnerPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  address: String
  city: String
  state: String
  country: String
  isPublic: String
  businessType: String
}

"""All input for the `updatePartnerById` mutation."""
input UpdatePartnerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Partner` being updated."""
  partnerPatch: PartnerPatch!
  id: BigInt!
}

"""The output of our update `Payment` mutation."""
type UpdatePaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Payment` that was updated by this mutation."""
  payment: Payment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Payment`. May be used by Relay 1."""
  paymentEdge(
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsEdge
}

"""All input for the `updatePayment` mutation."""
input UpdatePaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Payment` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Payment` being updated."""
  paymentPatch: PaymentPatch!
}

"""Represents an update to a `Payment`. Fields that are set will be updated."""
input PaymentPatch {
  id: BigInt
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String
  active: String
  country: String
}

"""All input for the `updatePaymentById` mutation."""
input UpdatePaymentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Payment` being updated."""
  paymentPatch: PaymentPatch!
  id: BigInt!
}

"""The output of our update `PdfTemplate` mutation."""
type UpdatePdfTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `PdfTemplate` that was updated by this mutation."""
  pdfTemplate: PdfTemplate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `PdfTemplate`. May be used by Relay 1."""
  pdfTemplateEdge(
    """The method to use when ordering `PdfTemplate`."""
    orderBy: [PdfTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PdfTemplatesEdge
}

"""All input for the `updatePdfTemplate` mutation."""
input UpdatePdfTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `PdfTemplate` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `PdfTemplate` being updated."""
  pdfTemplatePatch: PdfTemplatePatch!
}

"""Represents an update to a `PdfTemplate`. Fields that are set will be updated."""
input PdfTemplatePatch {
  id: BigInt
  createdAt: Datetime
  name: String
  assignedTo: String
  type: String
  active: String
  pageSize: String
  orientation: String
  content: String
  header: String
  footer: String
  marginLeft: String
  marginRight: String
  marginTop: String
  marginBottom: String
  marginHeader: String
  marginFooter: String
}

"""All input for the `updatePdfTemplateById` mutation."""
input UpdatePdfTemplateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `PdfTemplate` being updated."""
  pdfTemplatePatch: PdfTemplatePatch!
  id: BigInt!
}

"""The output of our update `Permission` mutation."""
type UpdatePermissionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Permission` that was updated by this mutation."""
  permission: Permission
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Permission`. May be used by Relay 1."""
  permissionEdge(
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PermissionsEdge
}

"""All input for the `updatePermission` mutation."""
input UpdatePermissionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Permission` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Permission` being updated."""
  permissionPatch: PermissionPatch!
}

"""Represents an update to a `Permission`. Fields that are set will be updated."""
input PermissionPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  role: String
  create: String
  read: String
  update: String
  delete: String
  users: String
}

"""All input for the `updatePermissionById` mutation."""
input UpdatePermissionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Permission` being updated."""
  permissionPatch: PermissionPatch!
  id: BigInt!
}

"""The output of our update `Plugin` mutation."""
type UpdatePluginPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Plugin` that was updated by this mutation."""
  plugin: Plugin
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Plugin`. May be used by Relay 1."""
  pluginEdge(
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PluginsEdge
}

"""All input for the `updatePlugin` mutation."""
input UpdatePluginInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Plugin` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Plugin` being updated."""
  pluginPatch: PluginPatch!
}

"""Represents an update to a `Plugin`. Fields that are set will be updated."""
input PluginPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  githubLink: String
  description: String
  logo: String
  screenshots: String
  lastUpdated: Datetime
  publisherName: String
  agreeTerms: Boolean
  publisherEmail: String
}

"""All input for the `updatePluginById` mutation."""
input UpdatePluginByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Plugin` being updated."""
  pluginPatch: PluginPatch!
  id: BigInt!
}

"""The output of our update `ProductAttribute` mutation."""
type UpdateProductAttributePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ProductAttribute` that was updated by this mutation."""
  productAttribute: ProductAttribute
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `ProductAttribute`."""
  productByProdId: Product
  """An edge for our `ProductAttribute`. May be used by Relay 1."""
  productAttributeEdge(
    """The method to use when ordering `ProductAttribute`."""
    orderBy: [ProductAttributesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductAttributesEdge
}

"""All input for the `updateProductAttribute` mutation."""
input UpdateProductAttributeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ProductAttribute` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `ProductAttribute` being updated."""
  productAttributePatch: ProductAttributePatch!
}

"""Represents an update to a `ProductAttribute`. Fields that are set will be updated."""
input ProductAttributePatch {
  id: BigInt
  defaultLabel: String
  attributeCode: String
  filterOptions: String
  useSearch: String
  layeredNavigation: Boolean
  searchResultsLayeredNavigation: Boolean
  position: String
  promoRuleConditions: Boolean
  allowHtmlTagsStorefront: Boolean
  visibleCatalogPagesStorefront: Boolean
  usedProductListing: Boolean
  usedSortingProductListing: Boolean
  prodId: BigInt
  attributeClass: String
  attributeValue: String
  columnOptions: String
  facetedNavigation: Boolean
  isPublic: String
  metaDescription: String
  metaName: Boolean
  metaUrl: String
}

"""All input for the `updateProductAttributeById` mutation."""
input UpdateProductAttributeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `ProductAttribute` being updated."""
  productAttributePatch: ProductAttributePatch!
  id: BigInt!
}

"""The output of our update `ProductType` mutation."""
type UpdateProductTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ProductType` that was updated by this mutation."""
  productType: ProductType
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `ProductType`."""
  productByProdId: Product
  """An edge for our `ProductType`. May be used by Relay 1."""
  productTypeEdge(
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductTypesEdge
}

"""All input for the `updateProductType` mutation."""
input UpdateProductTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ProductType` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `ProductType` being updated."""
  productTypePatch: ProductTypePatch!
}

"""Represents an update to a `ProductType`. Fields that are set will be updated."""
input ProductTypePatch {
  id: BigInt
  typeName: String
  taxes: String
  isShippable: String
  metaUrl: String
  metaDescription: String
  filterOptions: String
  productType: String
  prodId: BigInt
}

"""All input for the `updateProductTypeById` mutation."""
input UpdateProductTypeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `ProductType` being updated."""
  productTypePatch: ProductTypePatch!
  id: BigInt!
}

"""The output of our update `Product` mutation."""
type UpdateProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Product` that was updated by this mutation."""
  product: Product
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Product`."""
  productByRelatedProduct: Product
  """An edge for our `Product`. May be used by Relay 1."""
  productEdge(
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge
}

"""All input for the `updateProduct` mutation."""
input UpdateProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Product` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Product` being updated."""
  productPatch: ProductPatch!
}

"""Represents an update to a `Product`. Fields that are set will be updated."""
input ProductPatch {
  id: BigInt
  sku: BigInt
  thumbnail: String
  name: String
  types: String
  attributes: String
  price: String
  quantityPerSource: String
  salableQuantity: String
  visibility: String
  status: Boolean
  websites: String
  product: String
  taxClass: String
  stockStatus: String
  weight: String
  categories: String
  createdAt: Datetime
  country: String
  size: String
  format: String
  height: String
  content: String
  shortDescription: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  file: String
  manufacture: String
  partNumber: String
  contract: String
  costString: String
  manufacturerPartNumber: String
  relatedProduct: BigInt
  tags: String
  brand: String
  occassions: String
  customerType: String
  family: String
  zone: String
  variants: String
}

"""All input for the `updateProductById` mutation."""
input UpdateProductByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Product` being updated."""
  productPatch: ProductPatch!
  id: BigInt!
}

"""The output of our update `ProjectTemplate` mutation."""
type UpdateProjectTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ProjectTemplate` that was updated by this mutation."""
  projectTemplate: ProjectTemplate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `ProjectTemplate`. May be used by Relay 1."""
  projectTemplateEdge(
    """The method to use when ordering `ProjectTemplate`."""
    orderBy: [ProjectTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectTemplatesEdge
}

"""All input for the `updateProjectTemplate` mutation."""
input UpdateProjectTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ProjectTemplate` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `ProjectTemplate` being updated."""
  projectTemplatePatch: ProjectTemplatePatch!
}

"""Represents an update to a `ProjectTemplate`. Fields that are set will be updated."""
input ProjectTemplatePatch {
  id: BigInt
  name: String
  status: String
  considerWorkingDays: String
  priority: String
  projectManager: String
  resource: String
  content: String
}

"""All input for the `updateProjectTemplateById` mutation."""
input UpdateProjectTemplateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `ProjectTemplate` being updated."""
  projectTemplatePatch: ProjectTemplatePatch!
  id: BigInt!
}

"""The output of our update `Project` mutation."""
type UpdateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Project` that was updated by this mutation."""
  project: Project
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Project`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Project`."""
  userByStaffId: User
  """Reads a single `TodoList` that is related to this `Project`."""
  todoListByTaskId: TodoList
  """Reads a single `Ticketing` that is related to this `Project`."""
  ticketingByTicketId: Ticketing
  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""All input for the `updateProject` mutation."""
input UpdateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Project` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Project` being updated."""
  projectPatch: ProjectPatch!
}

"""Represents an update to a `Project`. Fields that are set will be updated."""
input ProjectPatch {
  id: BigInt
  name: String
  projectManager: String
  startDate: String
  endDate: String
  resource: String
  considerworkingdays: String
  projectTemplate: String
  status: String
  createdAt: Datetime
  priority: String
  assignee: String
  doing: String
  done: String
  sectionRule: String
  goalName: String
  goalTimeperiod: String
  goalPrivacy: String
  goalCollaborators: String
  goalUpdatemethod: String
  goalProgressSource: String
  goalMeasurement: String
  custId: Int
  staffId: Int
  taskId: BigInt
  ticketId: BigInt
}

"""All input for the `updateProjectById` mutation."""
input UpdateProjectByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Project` being updated."""
  projectPatch: ProjectPatch!
  id: BigInt!
}

"""The output of our update `Provider` mutation."""
type UpdateProviderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Provider` that was updated by this mutation."""
  provider: Provider
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Provider`. May be used by Relay 1."""
  providerEdge(
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProvidersEdge
}

"""All input for the `updateProvider` mutation."""
input UpdateProviderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Provider` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Provider` being updated."""
  providerPatch: ProviderPatch!
}

"""Represents an update to a `Provider`. Fields that are set will be updated."""
input ProviderPatch {
  id: BigInt
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String
  active: String
}

"""All input for the `updateProviderById` mutation."""
input UpdateProviderByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Provider` being updated."""
  providerPatch: ProviderPatch!
  id: BigInt!
}

"""The output of our update `Quote` mutation."""
type UpdateQuotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Quote` that was updated by this mutation."""
  quote: Quote
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Quote`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `Quote`."""
  productByProdId: Product
  """Reads a single `Order` that is related to this `Quote`."""
  orderByOrderId: Order
  """An edge for our `Quote`. May be used by Relay 1."""
  quoteEdge(
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): QuotesEdge
}

"""All input for the `updateQuote` mutation."""
input UpdateQuoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Quote` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Quote` being updated."""
  quotePatch: QuotePatch!
}

"""Represents an update to a `Quote`. Fields that are set will be updated."""
input QuotePatch {
  id: BigInt
  name: String
  grandTotal: String
  createdAt: Datetime
  categories: String
  validUntil: String
  quoteStage: String
  customers: String
  custId: Int
  prodId: BigInt
  orderId: Int
  account: String
  approvalIssues: String
  approvalStatus: String
  assignedTo: String
  billingCity: String
  billingCountry: String
  billingPostal: String
  billingState: String
  billingStreet: String
  contact: String
  currency: String
  discount: String
  invoiceStatus: String
  lineItemDiscount: String
  lineItemGroupTotal: String
  lineItemName: String
  lineItemSubtotal: String
  lineItemTax: String
  lineItemTotal: String
  paymentTerms: String
  shipping: String
  shippingCity: String
  shippingCountry: String
  shippingPostal: String
  shippingState: String
  shippingStreet: String
  shippingTax: String
  subtotal: String
  tax: String
  total: String
}

"""All input for the `updateQuoteById` mutation."""
input UpdateQuoteByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Quote` being updated."""
  quotePatch: QuotePatch!
  id: BigInt!
}

"""The output of our update `Rating` mutation."""
type UpdateRatingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Rating` that was updated by this mutation."""
  rating: Rating
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Rating`."""
  productByProdId: Product
  """An edge for our `Rating`. May be used by Relay 1."""
  ratingEdge(
    """The method to use when ordering `Rating`."""
    orderBy: [RatingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RatingsEdge
}

"""All input for the `updateRating` mutation."""
input UpdateRatingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Rating` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Rating` being updated."""
  ratingPatch: RatingPatch!
}

"""Represents an update to a `Rating`. Fields that are set will be updated."""
input RatingPatch {
  id: BigInt
  defaultValue: String
  defaultStoreView: String
  ratingVisibility: String
  active: Boolean
  sortOrder: BigFloat
  prodId: BigInt
}

"""All input for the `updateRatingById` mutation."""
input UpdateRatingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Rating` being updated."""
  ratingPatch: RatingPatch!
  id: BigInt!
}

"""The output of our update `Report` mutation."""
type UpdateReportPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Report` that was updated by this mutation."""
  report: Report
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Report`. May be used by Relay 1."""
  reportEdge(
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReportsEdge
}

"""All input for the `updateReport` mutation."""
input UpdateReportInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Report` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Report` being updated."""
  reportPatch: ReportPatch!
}

"""Represents an update to a `Report`. Fields that are set will be updated."""
input ReportPatch {
  id: BigInt
  customer: String
  email: String
  products: String
  quantity: BigFloat
  subtotal: String
  appliedCoupon: String
  created: Datetime
  updated: Datetime
  ipAddress: String
}

"""All input for the `updateReportById` mutation."""
input UpdateReportByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Report` being updated."""
  reportPatch: ReportPatch!
  id: BigInt!
}

"""The output of our update `Return` mutation."""
type UpdateReturnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Return` that was updated by this mutation."""
  return: Return
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Return`."""
  productByProdId: Product
  """Reads a single `Customer` that is related to this `Return`."""
  customerByCustId: Customer
  """An edge for our `Return`. May be used by Relay 1."""
  returnEdge(
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReturnsEdge
}

"""All input for the `updateReturn` mutation."""
input UpdateReturnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Return` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Return` being updated."""
  returnPatch: ReturnPatch!
}

"""Represents an update to a `Return`. Fields that are set will be updated."""
input ReturnPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  validity: String
  returnPrefix: String
  prodId: BigInt
  custId: Int
}

"""All input for the `updateReturnById` mutation."""
input UpdateReturnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Return` being updated."""
  returnPatch: ReturnPatch!
  id: BigInt!
}

"""The output of our update `Review` mutation."""
type UpdateReviewPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Review` that was updated by this mutation."""
  review: Review
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Review`. May be used by Relay 1."""
  reviewEdge(
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReviewsEdge
}

"""All input for the `updateReview` mutation."""
input UpdateReviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Review` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Review` being updated."""
  reviewPatch: ReviewPatch!
}

"""Represents an update to a `Review`. Fields that are set will be updated."""
input ReviewPatch {
  id: BigInt
  firstName: String
  lastName: String
  content: String
  websites: String
  createdAt: Datetime
  shopId: Int
  commentId: Int
}

"""All input for the `updateReviewById` mutation."""
input UpdateReviewByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Review` being updated."""
  reviewPatch: ReviewPatch!
  id: BigInt!
}

"""The output of our update `Reward` mutation."""
type UpdateRewardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Reward` that was updated by this mutation."""
  reward: Reward
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Reward`. May be used by Relay 1."""
  rewardEdge(
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RewardsEdge
}

"""All input for the `updateReward` mutation."""
input UpdateRewardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Reward` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Reward` being updated."""
  rewardPatch: RewardPatch!
}

"""Represents an update to a `Reward`. Fields that are set will be updated."""
input RewardPatch {
  id: BigInt
  name: String
  slug: String
  level: String
  createdAt: Datetime
  coupons: String
  expiration: Date
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""All input for the `updateRewardById` mutation."""
input UpdateRewardByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Reward` being updated."""
  rewardPatch: RewardPatch!
  id: BigInt!
}

"""The output of our update `Scheduler` mutation."""
type UpdateSchedulerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Scheduler` that was updated by this mutation."""
  scheduler: Scheduler
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Scheduler`. May be used by Relay 1."""
  schedulerEdge(
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SchedulersEdge
}

"""All input for the `updateScheduler` mutation."""
input UpdateSchedulerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Scheduler` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Scheduler` being updated."""
  schedulerPatch: SchedulerPatch!
}

"""Represents an update to a `Scheduler`. Fields that are set will be updated."""
input SchedulerPatch {
  id: BigInt
  createdAt: Datetime
  endDate: String
  level: String
  login: String
  notes: String
  startDate: String
  whid: String
}

"""All input for the `updateSchedulerById` mutation."""
input UpdateSchedulerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Scheduler` being updated."""
  schedulerPatch: SchedulerPatch!
  id: BigInt!
}

"""The output of our update `Segment` mutation."""
type UpdateSegmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Segment` that was updated by this mutation."""
  segment: Segment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Segment`. May be used by Relay 1."""
  segmentEdge(
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SegmentsEdge
}

"""All input for the `updateSegment` mutation."""
input UpdateSegmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Segment` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Segment` being updated."""
  segmentPatch: SegmentPatch!
}

"""Represents an update to a `Segment`. Fields that are set will be updated."""
input SegmentPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  website: String
  status: String
  applyTo: String
  customers: String
}

"""All input for the `updateSegmentById` mutation."""
input UpdateSegmentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Segment` being updated."""
  segmentPatch: SegmentPatch!
  id: BigInt!
}

"""The output of our update `Settingscustomer` mutation."""
type UpdateSettingscustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingscustomer` that was updated by this mutation."""
  settingscustomer: Settingscustomer
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingscustomer`. May be used by Relay 1."""
  settingscustomerEdge(
    """The method to use when ordering `Settingscustomer`."""
    orderBy: [SettingscustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingscustomersEdge
}

"""All input for the `updateSettingscustomer` mutation."""
input UpdateSettingscustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingscustomer` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Settingscustomer` being updated."""
  settingscustomerPatch: SettingscustomerPatch!
}

"""Represents an update to a `Settingscustomer`. Fields that are set will be updated."""
input SettingscustomerPatch {
  id: BigInt
  createdAt: Datetime
  loginAsCustomer: String
  shareCustomerAccounts: String
  onlineMinutesInterval: String
  customerDataLifetime: String
  emailAfterRegistration: String
}

"""All input for the `updateSettingscustomerById` mutation."""
input UpdateSettingscustomerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Settingscustomer` being updated."""
  settingscustomerPatch: SettingscustomerPatch!
  id: BigInt!
}

"""The output of our update `Settingsgeneral` mutation."""
type UpdateSettingsgeneralPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingsgeneral` that was updated by this mutation."""
  settingsgeneral: Settingsgeneral
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingsgeneral`. May be used by Relay 1."""
  settingsgeneralEdge(
    """The method to use when ordering `Settingsgeneral`."""
    orderBy: [SettingsgeneralsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsgeneralsEdge
}

"""All input for the `updateSettingsgeneral` mutation."""
input UpdateSettingsgeneralInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingsgeneral` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Settingsgeneral` being updated."""
  settingsgeneralPatch: SettingsgeneralPatch!
}

"""Represents an update to a `Settingsgeneral`. Fields that are set will be updated."""
input SettingsgeneralPatch {
  id: BigInt
  createdAt: Datetime
  siteTitle: String
  siteTagline: String
  siteWebsite: String
  email: String
  awsS3: String
  googleDrive: String
}

"""All input for the `updateSettingsgeneralById` mutation."""
input UpdateSettingsgeneralByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Settingsgeneral` being updated."""
  settingsgeneralPatch: SettingsgeneralPatch!
  id: BigInt!
}

"""The output of our update `Settingshop` mutation."""
type UpdateSettingshopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingshop` that was updated by this mutation."""
  settingshop: Settingshop
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingshop`. May be used by Relay 1."""
  settingshopEdge(
    """The method to use when ordering `Settingshop`."""
    orderBy: [SettingshopsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingshopsEdge
}

"""All input for the `updateSettingshop` mutation."""
input UpdateSettingshopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingshop` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Settingshop` being updated."""
  settingshopPatch: SettingshopPatch!
}

"""Represents an update to a `Settingshop`. Fields that are set will be updated."""
input SettingshopPatch {
  id: BigInt
  enableProductAssignment: String
  productVideos: String
  sellerPayouts: String
  adminApproval: String
  enableReviewSystem: String
  customerRateVendor: String
  multishipping: String
  vendorTransactionId: String
  enableVendorProductAttribute: String
}

"""All input for the `updateSettingshopById` mutation."""
input UpdateSettingshopByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Settingshop` being updated."""
  settingshopPatch: SettingshopPatch!
  id: BigInt!
}

"""The output of our update `Settingsmarketing` mutation."""
type UpdateSettingsmarketingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingsmarketing` that was updated by this mutation."""
  settingsmarketing: Settingsmarketing
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingsmarketing`. May be used by Relay 1."""
  settingsmarketingEdge(
    """The method to use when ordering `Settingsmarketing`."""
    orderBy: [SettingsmarketingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsmarketingsEdge
}

"""All input for the `updateSettingsmarketing` mutation."""
input UpdateSettingsmarketingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingsmarketing` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Settingsmarketing` being updated."""
  settingsmarketingPatch: SettingsmarketingPatch!
}

"""Represents an update to a `Settingsmarketing`. Fields that are set will be updated."""
input SettingsmarketingPatch {
  id: BigInt
  mailPort: String
  recaptchaApi: String
  adsenseApi: String
  sitemapUrl: String
  customerDataLifetime: String
  mailServer: String
}

"""All input for the `updateSettingsmarketingById` mutation."""
input UpdateSettingsmarketingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Settingsmarketing` being updated."""
  settingsmarketingPatch: SettingsmarketingPatch!
  id: BigInt!
}

"""The output of our update `Settingssale` mutation."""
type UpdateSettingssalePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingssale` that was updated by this mutation."""
  settingssale: Settingssale
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingssale`. May be used by Relay 1."""
  settingssaleEdge(
    """The method to use when ordering `Settingssale`."""
    orderBy: [SettingssalesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingssalesEdge
}

"""All input for the `updateSettingssale` mutation."""
input UpdateSettingssaleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingssale` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Settingssale` being updated."""
  settingssalePatch: SettingssalePatch!
}

"""Represents an update to a `Settingssale`. Fields that are set will be updated."""
input SettingssalePatch {
  id: BigInt
  createdAt: Datetime
  analyticsAccountType: String
  analyticsAccountNumber: String
  analyticsAnonymizeip: String
  analyticsContentExperiments: String
  adwordsConversionid: String
  adwordsConversionlanguage: String
  adwordsConversionformat: String
  adwordsConversioncolor: String
  adwordsConversionlabel: String
  adwordsConversionvalueType: String
  adwordsSendorder: String
  tagManagerAnonymizeip: String
  tagManagerContentexperiments: String
  tagManagerContainerid: String
}

"""All input for the `updateSettingssaleById` mutation."""
input UpdateSettingssaleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Settingssale` being updated."""
  settingssalePatch: SettingssalePatch!
  id: BigInt!
}

"""The output of our update `Shipment` mutation."""
type UpdateShipmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Shipment` that was updated by this mutation."""
  shipment: Shipment
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Shipment`. May be used by Relay 1."""
  shipmentEdge(
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShipmentsEdge
}

"""All input for the `updateShipment` mutation."""
input UpdateShipmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Shipment` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Shipment` being updated."""
  shipmentPatch: ShipmentPatch!
}

"""Represents an update to a `Shipment`. Fields that are set will be updated."""
input ShipmentPatch {
  product: String
  speedGrade: String
  shipDate: Datetime
  carrierName: String
  transitTime: String
  trackingUrl: String
  image: String
  id: BigInt
  clientId: String
  clientSecret: String
  country: String
  website: String
}

"""All input for the `updateShipmentById` mutation."""
input UpdateShipmentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Shipment` being updated."""
  shipmentPatch: ShipmentPatch!
  id: BigInt!
}

"""The output of our update `ShopSetting` mutation."""
type UpdateShopSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ShopSetting` that was updated by this mutation."""
  shopSetting: ShopSetting
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `ShopSetting`. May be used by Relay 1."""
  shopSettingEdge(
    """The method to use when ordering `ShopSetting`."""
    orderBy: [ShopSettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShopSettingsEdge
}

"""All input for the `updateShopSetting` mutation."""
input UpdateShopSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ShopSetting` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `ShopSetting` being updated."""
  shopSettingPatch: ShopSettingPatch!
}

"""Represents an update to a `ShopSetting`. Fields that are set will be updated."""
input ShopSettingPatch {
  id: BigInt
  createdAt: Datetime
  storeName: String
  storePhone: String
  storeHours: String
  country: String
  region: String
  zipcode: String
  city: String
  address: String
  addressTwo: String
  vatNumber: String
  allowState: String
  stateRequiredFor: String
  allowCountries: String
  defaultCountry: String
  optionalZip: String
  europeanUnionCountries: String
  topDestinations: String
  baseCurrency: String
  defaultCurrency: String
  allowedCurrency: String
}

"""All input for the `updateShopSettingById` mutation."""
input UpdateShopSettingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `ShopSetting` being updated."""
  shopSettingPatch: ShopSettingPatch!
  id: BigInt!
}

"""The output of our update `Shop` mutation."""
type UpdateShopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Shop` that was updated by this mutation."""
  shop: Shop
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Shop`. May be used by Relay 1."""
  shopEdge(
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShopsEdge
}

"""All input for the `updateShop` mutation."""
input UpdateShopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Shop` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Shop` being updated."""
  shopPatch: ShopPatch!
}

"""Represents an update to a `Shop`. Fields that are set will be updated."""
input ShopPatch {
  id: BigInt
  name: String
  description: String
  image: String
  website: String
  products: String
  articles: String
  customers: String
  comments: String
  coupons: String
  categories: String
  polls: String
  quotes: String
  reviews: String
  giftCertificates: String
  rating: String
  tags: String
  users: String
  invoices: String
  reports: String
  rewardPoints: String
  specialDiscounts: String
  statistics: String
  stocks: String
  country: String
  physicalStore: String
  type: String
}

"""All input for the `updateShopById` mutation."""
input UpdateShopByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Shop` being updated."""
  shopPatch: ShopPatch!
  id: BigInt!
}

"""The output of our update `SpecialDiscount` mutation."""
type UpdateSpecialDiscountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `SpecialDiscount` that was updated by this mutation."""
  specialDiscount: SpecialDiscount
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `SpecialDiscount`. May be used by Relay 1."""
  specialDiscountEdge(
    """The method to use when ordering `SpecialDiscount`."""
    orderBy: [SpecialDiscountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SpecialDiscountsEdge
}

"""All input for the `updateSpecialDiscount` mutation."""
input UpdateSpecialDiscountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `SpecialDiscount` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `SpecialDiscount` being updated."""
  specialDiscountPatch: SpecialDiscountPatch!
}

"""Represents an update to a `SpecialDiscount`. Fields that are set will be updated."""
input SpecialDiscountPatch {
  id: BigInt
  name: String
  excerpt: String
  image: String
  published: Datetime
  rewards: String
  coupons: String
  expiration: Date
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  discount: String
}

"""All input for the `updateSpecialDiscountById` mutation."""
input UpdateSpecialDiscountByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `SpecialDiscount` being updated."""
  specialDiscountPatch: SpecialDiscountPatch!
  id: BigInt!
}

"""The output of our update `State` mutation."""
type UpdateStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `State` that was updated by this mutation."""
  state: State
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `State`. May be used by Relay 1."""
  stateEdge(
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatesEdge
}

"""All input for the `updateState` mutation."""
input UpdateStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `State` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `State` being updated."""
  statePatch: StatePatch!
}

"""Represents an update to a `State`. Fields that are set will be updated."""
input StatePatch {
  id: BigInt
  name: String
  description: String
  country: String
  image: String
}

"""All input for the `updateStateById` mutation."""
input UpdateStateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `State` being updated."""
  statePatch: StatePatch!
  id: BigInt!
}

"""The output of our update `Statistic` mutation."""
type UpdateStatisticPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Statistic` that was updated by this mutation."""
  statistic: Statistic
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Statistic`. May be used by Relay 1."""
  statisticEdge(
    """The method to use when ordering `Statistic`."""
    orderBy: [StatisticsOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatisticsEdge
}

"""All input for the `updateStatistic` mutation."""
input UpdateStatisticInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Statistic` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Statistic` being updated."""
  statisticPatch: StatisticPatch!
}

"""Represents an update to a `Statistic`. Fields that are set will be updated."""
input StatisticPatch {
  id: BigInt
  name: String
  excerpt: String
  description: String
  image: String
  published: Datetime
  specialOffers: String
  reports: String
  rewards: String
  coupons: String
  expiration: Date
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""All input for the `updateStatisticById` mutation."""
input UpdateStatisticByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Statistic` being updated."""
  statisticPatch: StatisticPatch!
  id: BigInt!
}

"""The output of our update `Stock` mutation."""
type UpdateStockPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Stock` that was updated by this mutation."""
  stock: Stock
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Stock`. May be used by Relay 1."""
  stockEdge(
    """The method to use when ordering `Stock`."""
    orderBy: [StocksOrderBy!] = [PRIMARY_KEY_ASC]
  ): StocksEdge
}

"""All input for the `updateStock` mutation."""
input UpdateStockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Stock` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Stock` being updated."""
  stockPatch: StockPatch!
}

"""Represents an update to a `Stock`. Fields that are set will be updated."""
input StockPatch {
  id: BigInt
  name: String
  enabled: Boolean
  description: String
  website: String
  sources: String
}

"""All input for the `updateStockById` mutation."""
input UpdateStockByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Stock` being updated."""
  stockPatch: StockPatch!
  id: BigInt!
}

"""The output of our update `Survey` mutation."""
type UpdateSurveyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Survey` that was updated by this mutation."""
  survey: Survey
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Survey`. May be used by Relay 1."""
  surveyEdge(
    """The method to use when ordering `Survey`."""
    orderBy: [SurveysOrderBy!] = [PRIMARY_KEY_ASC]
  ): SurveysEdge
}

"""All input for the `updateSurvey` mutation."""
input UpdateSurveyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Survey` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Survey` being updated."""
  surveyPatch: SurveyPatch!
}

"""Represents an update to a `Survey`. Fields that are set will be updated."""
input SurveyPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  assignedTo: String
  status: String
  description: String
  question: String
  answer: String
  submitText: String
  satisfiedText: String
  neitherText: String
  dissatisfiedText: String
}

"""All input for the `updateSurveyById` mutation."""
input UpdateSurveyByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Survey` being updated."""
  surveyPatch: SurveyPatch!
  id: BigInt!
}

"""The output of our update `Tag` mutation."""
type UpdateTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Tag` that was updated by this mutation."""
  tag: Tag
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsEdge
}

"""All input for the `updateTag` mutation."""
input UpdateTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Tag` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Tag` being updated."""
  tagPatch: TagPatch!
}

"""Represents an update to a `Tag`. Fields that are set will be updated."""
input TagPatch {
  id: BigInt
  name: String
  excerpt: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""All input for the `updateTagById` mutation."""
input UpdateTagByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Tag` being updated."""
  tagPatch: TagPatch!
  id: BigInt!
}

"""The output of our update `Target` mutation."""
type UpdateTargetPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Target` that was updated by this mutation."""
  target: Target
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Target`. May be used by Relay 1."""
  targetEdge(
    """The method to use when ordering `Target`."""
    orderBy: [TargetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TargetsEdge
}

"""All input for the `updateTarget` mutation."""
input UpdateTargetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Target` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Target` being updated."""
  targetPatch: TargetPatch!
}

"""Represents an update to a `Target`. Fields that are set will be updated."""
input TargetPatch {
  id: BigInt
  createdAt: Datetime
  prefix: String
  firstName: String
  lastName: String
  department: String
  accountName: String
  address: String
  postalcode: String
  city: String
  state: String
  country: String
  email: String
  description: String
  fax: String
  website: String
  mobile: String
  jobTitle: String
  altAddress: String
  altPostalcode: String
  altCity: String
  altState: String
  altCountry: String
  officePhone: String
  customerName: String
  emailOptOut: String
  donotcall: String
}

"""All input for the `updateTargetById` mutation."""
input UpdateTargetByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Target` being updated."""
  targetPatch: TargetPatch!
  id: BigInt!
}

"""The output of our update `TaxCategory` mutation."""
type UpdateTaxCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TaxCategory` that was updated by this mutation."""
  taxCategory: TaxCategory
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `TaxCategory`. May be used by Relay 1."""
  taxCategoryEdge(
    """The method to use when ordering `TaxCategory`."""
    orderBy: [TaxCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxCategoriesEdge
}

"""All input for the `updateTaxCategory` mutation."""
input UpdateTaxCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `TaxCategory` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `TaxCategory` being updated."""
  taxCategoryPatch: TaxCategoryPatch!
}

"""Represents an update to a `TaxCategory`. Fields that are set will be updated."""
input TaxCategoryPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  default: String
}

"""All input for the `updateTaxCategoryById` mutation."""
input UpdateTaxCategoryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `TaxCategory` being updated."""
  taxCategoryPatch: TaxCategoryPatch!
  id: BigInt!
}

"""The output of our update `TaxRate` mutation."""
type UpdateTaxRatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TaxRate` that was updated by this mutation."""
  taxRate: TaxRate
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `TaxRate`."""
  productByProdId: Product
  """An edge for our `TaxRate`. May be used by Relay 1."""
  taxRateEdge(
    """The method to use when ordering `TaxRate`."""
    orderBy: [TaxRatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxRatesEdge
}

"""All input for the `updateTaxRate` mutation."""
input UpdateTaxRateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `TaxRate` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `TaxRate` being updated."""
  taxRatePatch: TaxRatePatch!
}

"""Represents an update to a `TaxRate`. Fields that are set will be updated."""
input TaxRatePatch {
  id: BigInt
  taxIdentifier: String
  zipPostIsRange: Boolean
  postcode: String
  state: String
  country: String
  ratePercent: String
  defaultStoreView: String
  prodId: BigInt
}

"""All input for the `updateTaxRateById` mutation."""
input UpdateTaxRateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `TaxRate` being updated."""
  taxRatePatch: TaxRatePatch!
  id: BigInt!
}

"""The output of our update `TaxRule` mutation."""
type UpdateTaxRulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TaxRule` that was updated by this mutation."""
  taxRule: TaxRule
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `TaxRule`."""
  productByProdId: Product
  """An edge for our `TaxRule`. May be used by Relay 1."""
  taxRuleEdge(
    """The method to use when ordering `TaxRule`."""
    orderBy: [TaxRulesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxRulesEdge
}

"""All input for the `updateTaxRule` mutation."""
input UpdateTaxRuleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `TaxRule` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `TaxRule` being updated."""
  taxRulePatch: TaxRulePatch!
}

"""Represents an update to a `TaxRule`. Fields that are set will be updated."""
input TaxRulePatch {
  id: BigInt
  name: String
  taxRate: String
  prodId: BigInt
}

"""All input for the `updateTaxRuleById` mutation."""
input UpdateTaxRuleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `TaxRule` being updated."""
  taxRulePatch: TaxRulePatch!
  id: BigInt!
}

"""The output of our update `Theme` mutation."""
type UpdateThemePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Theme` that was updated by this mutation."""
  theme: Theme
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Website` that is related to this `Theme`."""
  websiteByWebsiteId: Website
  """An edge for our `Theme`. May be used by Relay 1."""
  themeEdge(
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ThemesEdge
}

"""All input for the `updateTheme` mutation."""
input UpdateThemeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Theme` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Theme` being updated."""
  themePatch: ThemePatch!
}

"""Represents an update to a `Theme`. Fields that are set will be updated."""
input ThemePatch {
  id: BigInt
  title: String
  parentTheme: String
  themePath: String
  action: String
  websiteId: BigInt
}

"""All input for the `updateThemeById` mutation."""
input UpdateThemeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Theme` being updated."""
  themePatch: ThemePatch!
  id: BigInt!
}

"""The output of our update `Ticketing` mutation."""
type UpdateTicketingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Ticketing` that was updated by this mutation."""
  ticketing: Ticketing
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Ticketing`. May be used by Relay 1."""
  ticketingEdge(
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TicketingsEdge
}

"""All input for the `updateTicketing` mutation."""
input UpdateTicketingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Ticketing` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Ticketing` being updated."""
  ticketingPatch: TicketingPatch!
}

"""Represents an update to a `Ticketing`. Fields that are set will be updated."""
input TicketingPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  location: String
  date: String
  severity: String
  team: String
  requester: String
  requesterEmail: String
  content: String
  department: String
  media: String
  projects: String
  ticketType: String
  comment: String
  products: String
  priority: String
  status: String
  resolution: String
  assignedTo: String
  dateModified: Datetime
  accountName: String
  level: String
}

"""All input for the `updateTicketingById` mutation."""
input UpdateTicketingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Ticketing` being updated."""
  ticketingPatch: TicketingPatch!
  id: BigInt!
}

"""The output of our update `TodoList` mutation."""
type UpdateTodoListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TodoList` that was updated by this mutation."""
  todoList: TodoList
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `TodoList`. May be used by Relay 1."""
  todoListEdge(
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TodoListsEdge
}

"""All input for the `updateTodoList` mutation."""
input UpdateTodoListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `TodoList` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `TodoList` being updated."""
  todoListPatch: TodoListPatch!
}

"""Represents an update to a `TodoList`. Fields that are set will be updated."""
input TodoListPatch {
  id: BigInt
  createdAt: Datetime
  subject: String
  startDate: String
  dueDate: String
  priority: String
  description: String
  status: String
  relatedTo: String
  contact: String
  assignedTo: String
  dateModified: Datetime
  task: String
  checklists: String
  visits: String
  projects: String
  tickets: String
  cases: String
  surveys: String
  articles: String
  endofshift: String
  name: String
}

"""All input for the `updateTodoListById` mutation."""
input UpdateTodoListByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `TodoList` being updated."""
  todoListPatch: TodoListPatch!
  id: BigInt!
}

"""The output of our update `Training` mutation."""
type UpdateTrainingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Training` that was updated by this mutation."""
  training: Training
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Comment` that is related to this `Training`."""
  commentByComment: Comment
  """Reads a single `Country` that is related to this `Training`."""
  countryByCountry: Country
  """Reads a single `State` that is related to this `Training`."""
  stateByState: State
  """Reads a single `Product` that is related to this `Training`."""
  productByProducts: Product
  """Reads a single `Checklist` that is related to this `Training`."""
  checklistByChecklists: Checklist
  """An edge for our `Training`. May be used by Relay 1."""
  trainingEdge(
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TrainingsEdge
}

"""All input for the `updateTraining` mutation."""
input UpdateTrainingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Training` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Training` being updated."""
  trainingPatch: TrainingPatch!
}

"""Represents an update to a `Training`. Fields that are set will be updated."""
input TrainingPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  subject: String
  content: String
  media: String
  link: String
  steps: String
  updated: Datetime
  analytics: String
  competency: String
  course: String
  grade: String
  school: String
  comment: Int
  address: String
  country: Int
  state: Int
  postal: String
  teacher: String
  student: String
  anncouncement: String
  resource: String
  badges: String
  isPublic: String
  isCompleted: String
  speakers: String
  fieldTrips: String
  assignments: String
  assignmentsDueDate: String
  origanlityReport: String
  products: BigInt
  faqs: String
  languages: String
  checklists: BigInt
  city: String
  meetups: String
  lab: String
  digiboards: String
}

"""All input for the `updateTrainingById` mutation."""
input UpdateTrainingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Training` being updated."""
  trainingPatch: TrainingPatch!
  id: BigInt!
}

"""The output of our update `Transaction` mutation."""
type UpdateTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Transaction` that was updated by this mutation."""
  transaction: Transaction
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Order` that is related to this `Transaction`."""
  orderByOrderId: Order
  """Reads a single `CustomerPayment` that is related to this `Transaction`."""
  customerPaymentByPaymentMethod: CustomerPayment
  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""All input for the `updateTransaction` mutation."""
input UpdateTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Transaction` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Transaction` being updated."""
  transactionPatch: TransactionPatch!
}

"""Represents an update to a `Transaction`. Fields that are set will be updated."""
input TransactionPatch {
  id: BigInt
  orderId: Int
  transactionId: Int
  parentTransactionId: Int
  created: Datetime
  paymentMethod: BigInt
  closed: String
}

"""All input for the `updateTransactionById` mutation."""
input UpdateTransactionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Transaction` being updated."""
  transactionPatch: TransactionPatch!
  id: BigInt!
}

"""The output of our update `UrlRewrite` mutation."""
type UpdateUrlRewritePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `UrlRewrite` that was updated by this mutation."""
  urlRewrite: UrlRewrite
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `UrlRewrite`. May be used by Relay 1."""
  urlRewriteEdge(
    """The method to use when ordering `UrlRewrite`."""
    orderBy: [UrlRewritesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UrlRewritesEdge
}

"""All input for the `updateUrlRewrite` mutation."""
input UpdateUrlRewriteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `UrlRewrite` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `UrlRewrite` being updated."""
  urlRewritePatch: UrlRewritePatch!
}

"""Represents an update to a `UrlRewrite`. Fields that are set will be updated."""
input UrlRewritePatch {
  id: BigInt
  requestPath: String
  description: String
  redirectType: Boolean
  targetPath: String
  store: String
}

"""All input for the `updateUrlRewriteById` mutation."""
input UpdateUrlRewriteByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `UrlRewrite` being updated."""
  urlRewritePatch: UrlRewritePatch!
  id: BigInt!
}

"""The output of our update `UserRole` mutation."""
type UpdateUserRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `UserRole` that was updated by this mutation."""
  userRole: UserRole
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `UserRole`. May be used by Relay 1."""
  userRoleEdge(
    """The method to use when ordering `UserRole`."""
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserRolesEdge
}

"""All input for the `updateUserRole` mutation."""
input UpdateUserRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `UserRole` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `UserRole` being updated."""
  userRolePatch: UserRolePatch!
}

"""Represents an update to a `UserRole`. Fields that are set will be updated."""
input UserRolePatch {
  id: BigInt
  roleName: String
  content: String
  createdAt: Datetime
}

"""All input for the `updateUserRoleById` mutation."""
input UpdateUserRoleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `UserRole` being updated."""
  userRolePatch: UserRolePatch!
  id: BigInt!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `User` that was updated by this mutation."""
  user: User
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `User` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `User` being updated."""
  userPatch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  id: BigInt
  username: String
  firstName: String
  lastName: String
  email: String
  password: String
  interfaceLocale: String
  value: String
  permissions: String
  createdAt: Datetime
}

"""All input for the `updateUserById` mutation."""
input UpdateUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `User` being updated."""
  userPatch: UserPatch!
  id: BigInt!
}

"""The output of our update `Visit` mutation."""
type UpdateVisitPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Visit` that was updated by this mutation."""
  visit: Visit
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Visit`. May be used by Relay 1."""
  visitEdge(
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VisitsEdge
}

"""All input for the `updateVisit` mutation."""
input UpdateVisitInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Visit` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Visit` being updated."""
  visitPatch: VisitPatch!
}

"""Represents an update to a `Visit`. Fields that are set will be updated."""
input VisitPatch {
  id: BigInt
  createdAt: Datetime
  location: String
  username: String
  reason: String
  content: String
  emergency: String
  startDate: String
  endDate: String
  task: String
  meeting: String
}

"""All input for the `updateVisitById` mutation."""
input UpdateVisitByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Visit` being updated."""
  visitPatch: VisitPatch!
  id: BigInt!
}

"""The output of our update `Warehouse` mutation."""
type UpdateWarehousePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Warehouse` that was updated by this mutation."""
  warehouse: Warehouse
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Warehouse`. May be used by Relay 1."""
  warehouseEdge(
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WarehousesEdge
}

"""All input for the `updateWarehouse` mutation."""
input UpdateWarehouseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Warehouse` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Warehouse` being updated."""
  warehousePatch: WarehousePatch!
}

"""Represents an update to a `Warehouse`. Fields that are set will be updated."""
input WarehousePatch {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  city: String
  state: String
  country: String
  postal: String
  status: String
  image: String
  products: String
  category: String
  isPublic: String
}

"""All input for the `updateWarehouseById` mutation."""
input UpdateWarehouseByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Warehouse` being updated."""
  warehousePatch: WarehousePatch!
  id: BigInt!
}

"""The output of our update `Webhook` mutation."""
type UpdateWebhookPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Webhook` that was updated by this mutation."""
  webhook: Webhook
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Webhook`. May be used by Relay 1."""
  webhookEdge(
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhooksEdge
}

"""All input for the `updateWebhook` mutation."""
input UpdateWebhookInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Webhook` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Webhook` being updated."""
  webhookPatch: WebhookPatch!
}

"""Represents an update to a `Webhook`. Fields that are set will be updated."""
input WebhookPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  headers: String
  create: String
  retrieve: String
  update: String
  delete: String
  publish: String
  unpublish: String
}

"""All input for the `updateWebhookById` mutation."""
input UpdateWebhookByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Webhook` being updated."""
  webhookPatch: WebhookPatch!
  id: BigInt!
}

"""The output of our update `Website` mutation."""
type UpdateWebsitePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Website` that was updated by this mutation."""
  website: Website
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Website`. May be used by Relay 1."""
  websiteEdge(
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebsitesEdge
}

"""All input for the `updateWebsite` mutation."""
input UpdateWebsiteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Website` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Website` being updated."""
  websitePatch: WebsitePatch!
}

"""Represents an update to a `Website`. Fields that are set will be updated."""
input WebsitePatch {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  shop: String
  store: String
  image: String
  category: String
}

"""All input for the `updateWebsiteById` mutation."""
input UpdateWebsiteByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Website` being updated."""
  websitePatch: WebsitePatch!
  id: BigInt!
}

"""The output of our update `Wishlist` mutation."""
type UpdateWishlistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Wishlist` that was updated by this mutation."""
  wishlist: Wishlist
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Wishlist`. May be used by Relay 1."""
  wishlistEdge(
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): WishlistsEdge
}

"""All input for the `updateWishlist` mutation."""
input UpdateWishlistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Wishlist` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Wishlist` being updated."""
  wishlistPatch: WishlistPatch!
}

"""Represents an update to a `Wishlist`. Fields that are set will be updated."""
input WishlistPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  customers: String
  visibility: String
  products: String
  quantity: String
}

"""All input for the `updateWishlistById` mutation."""
input UpdateWishlistByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Wishlist` being updated."""
  wishlistPatch: WishlistPatch!
  id: BigInt!
}

"""The output of our update `Workspace` mutation."""
type UpdateWorkspacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Workspace` that was updated by this mutation."""
  workspace: Workspace
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Workspace`."""
  customerByCustomers: Customer
  """Reads a single `User` that is related to this `Workspace`."""
  userByUsers: User
  """Reads a single `Product` that is related to this `Workspace`."""
  productByProducts: Product
  """Reads a single `TodoList` that is related to this `Workspace`."""
  todoListByTasks: TodoList
  """Reads a single `Brand` that is related to this `Workspace`."""
  brandByBrands: Brand
  """Reads a single `Shop` that is related to this `Workspace`."""
  shopByShops: Shop
  """Reads a single `Category` that is related to this `Workspace`."""
  categoryByCategory: Category
  """Reads a single `Project` that is related to this `Workspace`."""
  projectByProjects: Project
  """An edge for our `Workspace`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspacesEdge
}

"""All input for the `updateWorkspace` mutation."""
input UpdateWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Workspace` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Workspace` being updated."""
  workspacePatch: WorkspacePatch!
}

"""Represents an update to a `Workspace`. Fields that are set will be updated."""
input WorkspacePatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  description: String
  customers: Int
  users: Int
  products: BigInt
  tasks: BigInt
  brands: BigInt
  shops: Int
  category: Int
  isPublic: Boolean
  projects: BigInt
  author: String
  media: String
}

"""All input for the `updateWorkspaceById` mutation."""
input UpdateWorkspaceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Workspace` being updated."""
  workspacePatch: WorkspacePatch!
  id: BigInt!
}

"""The output of our update `Zone` mutation."""
type UpdateZonePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Zone` that was updated by this mutation."""
  zone: Zone
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Zone`. May be used by Relay 1."""
  zoneEdge(
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ZonesEdge
}

"""All input for the `updateZone` mutation."""
input UpdateZoneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Zone` to be updated."""
  nodeId: ID!
  """An object where the defined keys will be set on the `Zone` being updated."""
  zonePatch: ZonePatch!
}

"""Represents an update to a `Zone`. Fields that are set will be updated."""
input ZonePatch {
  id: BigInt
  createdAt: Datetime
  name: String
  updatedAt: Datetime
  scope: String
  type: String
  country: String
  code: String
}

"""All input for the `updateZoneById` mutation."""
input UpdateZoneByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """An object where the defined keys will be set on the `Zone` being updated."""
  zonePatch: ZonePatch!
  id: BigInt!
}

"""The output of our delete `Endofshift` mutation."""
type DeleteEndofshiftPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Endofshift` that was deleted by this mutation."""
  endofshift: Endofshift
  deletedEndofshiftId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Endofshift`. May be used by Relay 1."""
  endofshiftEdge(
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EndofshiftsEdge
}

"""All input for the `deleteEndofshift` mutation."""
input DeleteEndofshiftInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Endofshift` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteEndofshiftById` mutation."""
input DeleteEndofshiftByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `_Schema` mutation."""
type DeleteSchemaPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `_Schema` that was deleted by this mutation."""
  _schema: _Schema
  deletedSchemaId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `_Schema`. May be used by Relay 1."""
  _schemaEdge(
    """The method to use when ordering `_Schema`."""
    orderBy: [_SchemasOrderBy!] = [PRIMARY_KEY_ASC]
  ): _SchemasEdge
}

"""All input for the `deleteSchema` mutation."""
input DeleteSchemaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `_Schema` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSchemaByClassName` mutation."""
input DeleteSchemaByClassNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  className: String!
}

"""The output of our delete `_PrismaMigration` mutation."""
type DeletePrismaMigrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `_PrismaMigration` that was deleted by this mutation."""
  _prismaMigration: _PrismaMigration
  deletedPrismaMigrationId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `_PrismaMigration`. May be used by Relay 1."""
  _prismaMigrationEdge(
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): _PrismaMigrationsEdge
}

"""All input for the `deletePrismaMigration` mutation."""
input DeletePrismaMigrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `_PrismaMigration` to be deleted."""
  nodeId: ID!
}

"""All input for the `deletePrismaMigrationById` mutation."""
input DeletePrismaMigrationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Account` mutation."""
type DeleteAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Account` that was deleted by this mutation."""
  account: Account
  deletedAccountId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Account`. May be used by Relay 1."""
  accountEdge(
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge
}

"""All input for the `deleteAccount` mutation."""
input DeleteAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Account` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteAccountById` mutation."""
input DeleteAccountByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Agreement` mutation."""
type DeleteAgreementPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Agreement` that was deleted by this mutation."""
  agreement: Agreement
  deletedAgreementId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Agreement`. May be used by Relay 1."""
  agreementEdge(
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgreementsEdge
}

"""All input for the `deleteAgreement` mutation."""
input DeleteAgreementInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Agreement` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteAgreementById` mutation."""
input DeleteAgreementByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Analytic` mutation."""
type DeleteAnalyticPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Analytic` that was deleted by this mutation."""
  analytic: Analytic
  deletedAnalyticId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Analytic`. May be used by Relay 1."""
  analyticEdge(
    """The method to use when ordering `Analytic`."""
    orderBy: [AnalyticsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AnalyticsEdge
}

"""All input for the `deleteAnalytic` mutation."""
input DeleteAnalyticInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Analytic` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteAnalyticById` mutation."""
input DeleteAnalyticByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Apitoken` mutation."""
type DeleteApitokenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Apitoken` that was deleted by this mutation."""
  apitoken: Apitoken
  deletedApitokenId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Apitoken`. May be used by Relay 1."""
  apitokenEdge(
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): ApitokensEdge
}

"""All input for the `deleteApitoken` mutation."""
input DeleteApitokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Apitoken` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteApitokenById` mutation."""
input DeleteApitokenByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Article` mutation."""
type DeleteArticlePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Article` that was deleted by this mutation."""
  article: Article
  deletedArticleId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Article`. May be used by Relay 1."""
  articleEdge(
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArticlesEdge
}

"""All input for the `deleteArticle` mutation."""
input DeleteArticleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Article` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteArticleById` mutation."""
input DeleteArticleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Brand` mutation."""
type DeleteBrandPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Brand` that was deleted by this mutation."""
  brand: Brand
  deletedBrandId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Brand`."""
  productByProduct: Product
  """An edge for our `Brand`. May be used by Relay 1."""
  brandEdge(
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BrandsEdge
}

"""All input for the `deleteBrand` mutation."""
input DeleteBrandInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Brand` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteBrandById` mutation."""
input DeleteBrandByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `CartPriceRule` mutation."""
type DeleteCartPriceRulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CartPriceRule` that was deleted by this mutation."""
  cartPriceRule: CartPriceRule
  deletedCartPriceRuleId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CartPriceRule`. May be used by Relay 1."""
  cartPriceRuleEdge(
    """The method to use when ordering `CartPriceRule`."""
    orderBy: [CartPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CartPriceRulesEdge
}

"""All input for the `deleteCartPriceRule` mutation."""
input DeleteCartPriceRuleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CartPriceRule` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCartPriceRuleById` mutation."""
input DeleteCartPriceRuleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Case` mutation."""
type DeleteCasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Case` that was deleted by this mutation."""
  case: Case
  deletedCaseId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Case`. May be used by Relay 1."""
  caseEdge(
    """The method to use when ordering `Case`."""
    orderBy: [CasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CasesEdge
}

"""All input for the `deleteCase` mutation."""
input DeleteCaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Case` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCaseById` mutation."""
input DeleteCaseByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `CatalogPriceRule` mutation."""
type DeleteCatalogPriceRulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CatalogPriceRule` that was deleted by this mutation."""
  catalogPriceRule: CatalogPriceRule
  deletedCatalogPriceRuleId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CatalogPriceRule`. May be used by Relay 1."""
  catalogPriceRuleEdge(
    """The method to use when ordering `CatalogPriceRule`."""
    orderBy: [CatalogPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CatalogPriceRulesEdge
}

"""All input for the `deleteCatalogPriceRule` mutation."""
input DeleteCatalogPriceRuleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CatalogPriceRule` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCatalogPriceRuleById` mutation."""
input DeleteCatalogPriceRuleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Category` mutation."""
type DeleteCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Category` that was deleted by this mutation."""
  category: Category
  deletedCategoryId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""All input for the `deleteCategory` mutation."""
input DeleteCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Category` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCategoryById` mutation."""
input DeleteCategoryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Channel` mutation."""
type DeleteChannelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Channel` that was deleted by this mutation."""
  channel: Channel
  deletedChannelId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Channel`. May be used by Relay 1."""
  channelEdge(
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChannelsEdge
}

"""All input for the `deleteChannel` mutation."""
input DeleteChannelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Channel` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteChannelById` mutation."""
input DeleteChannelByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Checklist` mutation."""
type DeleteChecklistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Checklist` that was deleted by this mutation."""
  checklist: Checklist
  deletedChecklistId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Checklist`. May be used by Relay 1."""
  checklistEdge(
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChecklistsEdge
}

"""All input for the `deleteChecklist` mutation."""
input DeleteChecklistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Checklist` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteChecklistById` mutation."""
input DeleteChecklistByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `City` mutation."""
type DeleteCityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `City` that was deleted by this mutation."""
  city: City
  deletedCityId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `City`. May be used by Relay 1."""
  cityEdge(
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge
}

"""All input for the `deleteCity` mutation."""
input DeleteCityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `City` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCityById` mutation."""
input DeleteCityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Collection` mutation."""
type DeleteCollectionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Collection` that was deleted by this mutation."""
  collection: Collection
  deletedCollectionId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Collection`. May be used by Relay 1."""
  collectionEdge(
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CollectionsEdge
}

"""All input for the `deleteCollection` mutation."""
input DeleteCollectionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Collection` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCollectionById` mutation."""
input DeleteCollectionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Comment` mutation."""
type DeleteCommentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Comment` that was deleted by this mutation."""
  comment: Comment
  deletedCommentId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Comment`."""
  customerByCustId: Customer
  """An edge for our `Comment`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentsEdge
}

"""All input for the `deleteComment` mutation."""
input DeleteCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Comment` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCommentById` mutation."""
input DeleteCommentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `ContentType` mutation."""
type DeleteContentTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ContentType` that was deleted by this mutation."""
  contentType: ContentType
  deletedContentTypeId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `ContentType`. May be used by Relay 1."""
  contentTypeEdge(
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContentTypesEdge
}

"""All input for the `deleteContentType` mutation."""
input DeleteContentTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ContentType` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteContentTypeById` mutation."""
input DeleteContentTypeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Contract` mutation."""
type DeleteContractPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Contract` that was deleted by this mutation."""
  contract: Contract
  deletedContractId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Contract`. May be used by Relay 1."""
  contractEdge(
    """The method to use when ordering `Contract`."""
    orderBy: [ContractsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContractsEdge
}

"""All input for the `deleteContract` mutation."""
input DeleteContractInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Contract` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteContractById` mutation."""
input DeleteContractByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Country` mutation."""
type DeleteCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Country` that was deleted by this mutation."""
  country: Country
  deletedCountryId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Country`. May be used by Relay 1."""
  countryEdge(
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge
}

"""All input for the `deleteCountry` mutation."""
input DeleteCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Country` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCountryById` mutation."""
input DeleteCountryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Coupon` mutation."""
type DeleteCouponPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Coupon` that was deleted by this mutation."""
  coupon: Coupon
  deletedCouponId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Coupon`."""
  productByProdId: Product
  """An edge for our `Coupon`. May be used by Relay 1."""
  couponEdge(
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CouponsEdge
}

"""All input for the `deleteCoupon` mutation."""
input DeleteCouponInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Coupon` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCouponById` mutation."""
input DeleteCouponByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `CreditMemo` mutation."""
type DeleteCreditMemoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CreditMemo` that was deleted by this mutation."""
  creditMemo: CreditMemo
  deletedCreditMemoId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `CreditMemo`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `CreditMemo`."""
  productByProdId: Product
  """An edge for our `CreditMemo`. May be used by Relay 1."""
  creditMemoEdge(
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!] = [PRIMARY_KEY_ASC]
  ): CreditMemosEdge
}

"""All input for the `deleteCreditMemo` mutation."""
input DeleteCreditMemoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CreditMemo` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCreditMemoByCreditMemoAndId` mutation."""
input DeleteCreditMemoByCreditMemoAndIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  creditMemo: String!
  id: BigInt!
}

"""The output of our delete `Currency` mutation."""
type DeleteCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Currency` that was deleted by this mutation."""
  currency: Currency
  deletedCurrencyId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
}

"""All input for the `deleteCurrency` mutation."""
input DeleteCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Currency` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCurrencyById` mutation."""
input DeleteCurrencyByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `CurrencyRate` mutation."""
type DeleteCurrencyRatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CurrencyRate` that was deleted by this mutation."""
  currencyRate: CurrencyRate
  deletedCurrencyRateId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CurrencyRate`. May be used by Relay 1."""
  currencyRateEdge(
    """The method to use when ordering `CurrencyRate`."""
    orderBy: [CurrencyRatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencyRatesEdge
}

"""All input for the `deleteCurrencyRate` mutation."""
input DeleteCurrencyRateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CurrencyRate` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCurrencyRateByImportService` mutation."""
input DeleteCurrencyRateByImportServiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  importService: String!
}

"""All input for the `deleteCurrencyRateById` mutation."""
input DeleteCurrencyRateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `CurrencySymbol` mutation."""
type DeleteCurrencySymbolPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CurrencySymbol` that was deleted by this mutation."""
  currencySymbol: CurrencySymbol
  deletedCurrencySymbolId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `CurrencySymbol`. May be used by Relay 1."""
  currencySymbolEdge(
    """The method to use when ordering `CurrencySymbol`."""
    orderBy: [CurrencySymbolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencySymbolsEdge
}

"""All input for the `deleteCurrencySymbol` mutation."""
input DeleteCurrencySymbolInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CurrencySymbol` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCurrencySymbolBySymbol` mutation."""
input DeleteCurrencySymbolBySymbolInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  symbol: String!
}

"""All input for the `deleteCurrencySymbolById` mutation."""
input DeleteCurrencySymbolByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `CustomerGroup` mutation."""
type DeleteCustomerGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CustomerGroup` that was deleted by this mutation."""
  customerGroup: CustomerGroup
  deletedCustomerGroupId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `CustomerGroup`."""
  customerByCustId: Customer
  """An edge for our `CustomerGroup`. May be used by Relay 1."""
  customerGroupEdge(
    """The method to use when ordering `CustomerGroup`."""
    orderBy: [CustomerGroupsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomerGroupsEdge
}

"""All input for the `deleteCustomerGroup` mutation."""
input DeleteCustomerGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CustomerGroup` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCustomerGroupById` mutation."""
input DeleteCustomerGroupByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `CustomerPayment` mutation."""
type DeleteCustomerPaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `CustomerPayment` that was deleted by this mutation."""
  customerPayment: CustomerPayment
  deletedCustomerPaymentId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `CustomerPayment`."""
  customerByCustId: Customer
  """An edge for our `CustomerPayment`. May be used by Relay 1."""
  customerPaymentEdge(
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomerPaymentsEdge
}

"""All input for the `deleteCustomerPayment` mutation."""
input DeleteCustomerPaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `CustomerPayment` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCustomerPaymentById` mutation."""
input DeleteCustomerPaymentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Customer` mutation."""
type DeleteCustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Customer` that was deleted by this mutation."""
  customer: Customer
  deletedCustomerId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Customer`. May be used by Relay 1."""
  customerEdge(
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersEdge
}

"""All input for the `deleteCustomer` mutation."""
input DeleteCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Customer` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCustomerById` mutation."""
input DeleteCustomerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Customization` mutation."""
type DeleteCustomizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Customization` that was deleted by this mutation."""
  customization: Customization
  deletedCustomizationId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Customization`. May be used by Relay 1."""
  customizationEdge(
    """The method to use when ordering `Customization`."""
    orderBy: [CustomizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomizationsEdge
}

"""All input for the `deleteCustomization` mutation."""
input DeleteCustomizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Customization` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteCustomizationById` mutation."""
input DeleteCustomizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Dashboard` mutation."""
type DeleteDashboardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Dashboard` that was deleted by this mutation."""
  dashboard: Dashboard
  deletedDashboardId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Dashboard`. May be used by Relay 1."""
  dashboardEdge(
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DashboardsEdge
}

"""All input for the `deleteDashboard` mutation."""
input DeleteDashboardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Dashboard` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteDashboardById` mutation."""
input DeleteDashboardByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Deepdive` mutation."""
type DeleteDeepdivePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Deepdive` that was deleted by this mutation."""
  deepdive: Deepdive
  deletedDeepdiveId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Deepdive`. May be used by Relay 1."""
  deepdiveEdge(
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DeepdivesEdge
}

"""All input for the `deleteDeepdive` mutation."""
input DeleteDeepdiveInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Deepdive` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteDeepdiveById` mutation."""
input DeleteDeepdiveByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `EmailTemplate` mutation."""
type DeleteEmailTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `EmailTemplate` that was deleted by this mutation."""
  emailTemplate: EmailTemplate
  deletedEmailTemplateId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `EmailTemplate`. May be used by Relay 1."""
  emailTemplateEdge(
    """The method to use when ordering `EmailTemplate`."""
    orderBy: [EmailTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmailTemplatesEdge
}

"""All input for the `deleteEmailTemplate` mutation."""
input DeleteEmailTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `EmailTemplate` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteEmailTemplateById` mutation."""
input DeleteEmailTemplateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Email` mutation."""
type DeleteEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Email` that was deleted by this mutation."""
  email: Email
  deletedEmailId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Email`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Email`."""
  userByStaffId: User
  """An edge for our `Email`. May be used by Relay 1."""
  emailEdge(
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmailsEdge
}

"""All input for the `deleteEmail` mutation."""
input DeleteEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Email` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteEmailById` mutation."""
input DeleteEmailByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Event` mutation."""
type DeleteEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Event` that was deleted by this mutation."""
  event: Event
  deletedEventId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the `deleteEvent` mutation."""
input DeleteEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Event` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteEventById` mutation."""
input DeleteEventByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Fullfillment` mutation."""
type DeleteFullfillmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Fullfillment` that was deleted by this mutation."""
  fullfillment: Fullfillment
  deletedFullfillmentId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Fullfillment`. May be used by Relay 1."""
  fullfillmentEdge(
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FullfillmentsEdge
}

"""All input for the `deleteFullfillment` mutation."""
input DeleteFullfillmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Fullfillment` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteFullfillmentById` mutation."""
input DeleteFullfillmentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `GeneralSetting` mutation."""
type DeleteGeneralSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `GeneralSetting` that was deleted by this mutation."""
  generalSetting: GeneralSetting
  deletedGeneralSettingId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `GeneralSetting`. May be used by Relay 1."""
  generalSettingEdge(
    """The method to use when ordering `GeneralSetting`."""
    orderBy: [GeneralSettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GeneralSettingsEdge
}

"""All input for the `deleteGeneralSetting` mutation."""
input DeleteGeneralSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `GeneralSetting` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteGeneralSettingById` mutation."""
input DeleteGeneralSettingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `GiftCertificate` mutation."""
type DeleteGiftCertificatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `GiftCertificate` that was deleted by this mutation."""
  giftCertificate: GiftCertificate
  deletedGiftCertificateId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `GiftCertificate`. May be used by Relay 1."""
  giftCertificateEdge(
    """The method to use when ordering `GiftCertificate`."""
    orderBy: [GiftCertificatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GiftCertificatesEdge
}

"""All input for the `deleteGiftCertificate` mutation."""
input DeleteGiftCertificateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `GiftCertificate` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteGiftCertificateById` mutation."""
input DeleteGiftCertificateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Glossary` mutation."""
type DeleteGlossaryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Glossary` that was deleted by this mutation."""
  glossary: Glossary
  deletedGlossaryId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Glossary`. May be used by Relay 1."""
  glossaryEdge(
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GlossariesEdge
}

"""All input for the `deleteGlossary` mutation."""
input DeleteGlossaryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Glossary` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteGlossaryById` mutation."""
input DeleteGlossaryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Importm` mutation."""
type DeleteImportmPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Importm` that was deleted by this mutation."""
  importm: Importm
  deletedImportmId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Importm`. May be used by Relay 1."""
  importmEdge(
    """The method to use when ordering `Importm`."""
    orderBy: [ImportmsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ImportmsEdge
}

"""All input for the `deleteImportm` mutation."""
input DeleteImportmInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Importm` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteImportmById` mutation."""
input DeleteImportmByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Integration` mutation."""
type DeleteIntegrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Integration` that was deleted by this mutation."""
  integration: Integration
  deletedIntegrationId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Integration`. May be used by Relay 1."""
  integrationEdge(
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): IntegrationsEdge
}

"""All input for the `deleteIntegration` mutation."""
input DeleteIntegrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Integration` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteIntegrationById` mutation."""
input DeleteIntegrationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Internalization` mutation."""
type DeleteInternalizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Internalization` that was deleted by this mutation."""
  internalization: Internalization
  deletedInternalizationId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Internalization`. May be used by Relay 1."""
  internalizationEdge(
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InternalizationsEdge
}

"""All input for the `deleteInternalization` mutation."""
input DeleteInternalizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Internalization` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteInternalizationById` mutation."""
input DeleteInternalizationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Invitation` mutation."""
type DeleteInvitationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Invitation` that was deleted by this mutation."""
  invitation: Invitation
  deletedInvitationId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Invitation`. May be used by Relay 1."""
  invitationEdge(
    """The method to use when ordering `Invitation`."""
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvitationsEdge
}

"""All input for the `deleteInvitation` mutation."""
input DeleteInvitationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Invitation` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteInvitationById` mutation."""
input DeleteInvitationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Invoice` mutation."""
type DeleteInvoicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Invoice` that was deleted by this mutation."""
  invoice: Invoice
  deletedInvoiceId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Invoice`. May be used by Relay 1."""
  invoiceEdge(
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvoicesEdge
}

"""All input for the `deleteInvoice` mutation."""
input DeleteInvoiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Invoice` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteInvoiceById` mutation."""
input DeleteInvoiceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Knowledgebase` mutation."""
type DeleteKnowledgebasePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Knowledgebase` that was deleted by this mutation."""
  knowledgebase: Knowledgebase
  deletedKnowledgebaseId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Knowledgebase`. May be used by Relay 1."""
  knowledgebaseEdge(
    """The method to use when ordering `Knowledgebase`."""
    orderBy: [KnowledgebasesOrderBy!] = [PRIMARY_KEY_ASC]
  ): KnowledgebasesEdge
}

"""All input for the `deleteKnowledgebase` mutation."""
input DeleteKnowledgebaseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Knowledgebase` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteKnowledgebaseById` mutation."""
input DeleteKnowledgebaseByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Lead` mutation."""
type DeleteLeadPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Lead` that was deleted by this mutation."""
  lead: Lead
  deletedLeadId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Lead`. May be used by Relay 1."""
  leadEdge(
    """The method to use when ordering `Lead`."""
    orderBy: [LeadsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LeadsEdge
}

"""All input for the `deleteLead` mutation."""
input DeleteLeadInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Lead` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteLeadById` mutation."""
input DeleteLeadByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Manufacturer` mutation."""
type DeleteManufacturerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Manufacturer` that was deleted by this mutation."""
  manufacturer: Manufacturer
  deletedManufacturerId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Manufacturer`."""
  productByProduct: Product
  """An edge for our `Manufacturer`. May be used by Relay 1."""
  manufacturerEdge(
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ManufacturersEdge
}

"""All input for the `deleteManufacturer` mutation."""
input DeleteManufacturerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Manufacturer` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteManufacturerById` mutation."""
input DeleteManufacturerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Mediamanager` mutation."""
type DeleteMediamanagerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Mediamanager` that was deleted by this mutation."""
  mediamanager: Mediamanager
  deletedMediamanagerId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Brand` that is related to this `Mediamanager`."""
  brandByBrands: Brand
  """Reads a single `Customer` that is related to this `Mediamanager`."""
  customerByAuthor: Customer
  """Reads a single `Agreement` that is related to this `Mediamanager`."""
  agreementByAgreements: Agreement
  """Reads a single `Comment` that is related to this `Mediamanager`."""
  commentByComment: Comment
  """Reads a single `TodoList` that is related to this `Mediamanager`."""
  todoListByTaskName: TodoList
  """Reads a single `User` that is related to this `Mediamanager`."""
  userByMembers: User
  """Reads a single `Product` that is related to this `Mediamanager`."""
  productByProducts: Product
  """An edge for our `Mediamanager`. May be used by Relay 1."""
  mediamanagerEdge(
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
  ): MediamanagersEdge
}

"""All input for the `deleteMediamanager` mutation."""
input DeleteMediamanagerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Mediamanager` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteMediamanagerById` mutation."""
input DeleteMediamanagerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Meeting` mutation."""
type DeleteMeetingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Meeting` that was deleted by this mutation."""
  meeting: Meeting
  deletedMeetingId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Meeting`. May be used by Relay 1."""
  meetingEdge(
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MeetingsEdge
}

"""All input for the `deleteMeeting` mutation."""
input DeleteMeetingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Meeting` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteMeetingById` mutation."""
input DeleteMeetingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Message` mutation."""
type DeleteMessagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Message` that was deleted by this mutation."""
  message: Message
  deletedMessageId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Message`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Message`."""
  userByStaffId: User
  """An edge for our `Message`. May be used by Relay 1."""
  messageEdge(
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessagesEdge
}

"""All input for the `deleteMessage` mutation."""
input DeleteMessageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Message` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteMessageById` mutation."""
input DeleteMessageByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `NewsletterSubscriber` mutation."""
type DeleteNewsletterSubscriberPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `NewsletterSubscriber` that was deleted by this mutation."""
  newsletterSubscriber: NewsletterSubscriber
  deletedNewsletterSubscriberId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `NewsletterSubscriber`."""
  customerByCustId: Customer
  """An edge for our `NewsletterSubscriber`. May be used by Relay 1."""
  newsletterSubscriberEdge(
    """The method to use when ordering `NewsletterSubscriber`."""
    orderBy: [NewsletterSubscribersOrderBy!] = [PRIMARY_KEY_ASC]
  ): NewsletterSubscribersEdge
}

"""All input for the `deleteNewsletterSubscriber` mutation."""
input DeleteNewsletterSubscriberInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `NewsletterSubscriber` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteNewsletterSubscriberById` mutation."""
input DeleteNewsletterSubscriberByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Occassion` mutation."""
type DeleteOccassionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Occassion` that was deleted by this mutation."""
  occassion: Occassion
  deletedOccassionId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Occassion`."""
  productByProducts: Product
  """Reads a single `Wishlist` that is related to this `Occassion`."""
  wishlistByWishlists: Wishlist
  """An edge for our `Occassion`. May be used by Relay 1."""
  occassionEdge(
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OccassionsEdge
}

"""All input for the `deleteOccassion` mutation."""
input DeleteOccassionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Occassion` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteOccassionById` mutation."""
input DeleteOccassionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Ooto` mutation."""
type DeleteOotoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Ooto` that was deleted by this mutation."""
  ooto: Ooto
  deletedOotoId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Ooto`. May be used by Relay 1."""
  ootoEdge(
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!] = [PRIMARY_KEY_ASC]
  ): OotosEdge
}

"""All input for the `deleteOoto` mutation."""
input DeleteOotoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Ooto` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteOotoById` mutation."""
input DeleteOotoByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Opportunity` mutation."""
type DeleteOpportunityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Opportunity` that was deleted by this mutation."""
  opportunity: Opportunity
  deletedOpportunityId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Opportunity`. May be used by Relay 1."""
  opportunityEdge(
    """The method to use when ordering `Opportunity`."""
    orderBy: [OpportunitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OpportunitiesEdge
}

"""All input for the `deleteOpportunity` mutation."""
input DeleteOpportunityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Opportunity` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteOpportunityById` mutation."""
input DeleteOpportunityByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Order` mutation."""
type DeleteOrderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Order` that was deleted by this mutation."""
  order: Order
  deletedOrderId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Order`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `Order`."""
  productByProdId: Product
  """An edge for our `Order`. May be used by Relay 1."""
  orderEdge(
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrdersEdge
}

"""All input for the `deleteOrder` mutation."""
input DeleteOrderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Order` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteOrderById` mutation."""
input DeleteOrderByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Page` mutation."""
type DeletePagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Page` that was deleted by this mutation."""
  page: Page
  deletedPageId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Page`. May be used by Relay 1."""
  pageEdge(
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PagesEdge
}

"""All input for the `deletePage` mutation."""
input DeletePageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Page` to be deleted."""
  nodeId: ID!
}

"""All input for the `deletePageById` mutation."""
input DeletePageByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Partner` mutation."""
type DeletePartnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Partner` that was deleted by this mutation."""
  partner: Partner
  deletedPartnerId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Partner`. May be used by Relay 1."""
  partnerEdge(
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnersEdge
}

"""All input for the `deletePartner` mutation."""
input DeletePartnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Partner` to be deleted."""
  nodeId: ID!
}

"""All input for the `deletePartnerById` mutation."""
input DeletePartnerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Payment` mutation."""
type DeletePaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Payment` that was deleted by this mutation."""
  payment: Payment
  deletedPaymentId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Payment`. May be used by Relay 1."""
  paymentEdge(
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsEdge
}

"""All input for the `deletePayment` mutation."""
input DeletePaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Payment` to be deleted."""
  nodeId: ID!
}

"""All input for the `deletePaymentById` mutation."""
input DeletePaymentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `PdfTemplate` mutation."""
type DeletePdfTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `PdfTemplate` that was deleted by this mutation."""
  pdfTemplate: PdfTemplate
  deletedPdfTemplateId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `PdfTemplate`. May be used by Relay 1."""
  pdfTemplateEdge(
    """The method to use when ordering `PdfTemplate`."""
    orderBy: [PdfTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PdfTemplatesEdge
}

"""All input for the `deletePdfTemplate` mutation."""
input DeletePdfTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `PdfTemplate` to be deleted."""
  nodeId: ID!
}

"""All input for the `deletePdfTemplateById` mutation."""
input DeletePdfTemplateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Permission` mutation."""
type DeletePermissionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Permission` that was deleted by this mutation."""
  permission: Permission
  deletedPermissionId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Permission`. May be used by Relay 1."""
  permissionEdge(
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PermissionsEdge
}

"""All input for the `deletePermission` mutation."""
input DeletePermissionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Permission` to be deleted."""
  nodeId: ID!
}

"""All input for the `deletePermissionById` mutation."""
input DeletePermissionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Plugin` mutation."""
type DeletePluginPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Plugin` that was deleted by this mutation."""
  plugin: Plugin
  deletedPluginId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Plugin`. May be used by Relay 1."""
  pluginEdge(
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PluginsEdge
}

"""All input for the `deletePlugin` mutation."""
input DeletePluginInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Plugin` to be deleted."""
  nodeId: ID!
}

"""All input for the `deletePluginById` mutation."""
input DeletePluginByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ProductAttribute` mutation."""
type DeleteProductAttributePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ProductAttribute` that was deleted by this mutation."""
  productAttribute: ProductAttribute
  deletedProductAttributeId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `ProductAttribute`."""
  productByProdId: Product
  """An edge for our `ProductAttribute`. May be used by Relay 1."""
  productAttributeEdge(
    """The method to use when ordering `ProductAttribute`."""
    orderBy: [ProductAttributesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductAttributesEdge
}

"""All input for the `deleteProductAttribute` mutation."""
input DeleteProductAttributeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ProductAttribute` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteProductAttributeById` mutation."""
input DeleteProductAttributeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ProductType` mutation."""
type DeleteProductTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ProductType` that was deleted by this mutation."""
  productType: ProductType
  deletedProductTypeId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `ProductType`."""
  productByProdId: Product
  """An edge for our `ProductType`. May be used by Relay 1."""
  productTypeEdge(
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductTypesEdge
}

"""All input for the `deleteProductType` mutation."""
input DeleteProductTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ProductType` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteProductTypeById` mutation."""
input DeleteProductTypeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Product` mutation."""
type DeleteProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Product` that was deleted by this mutation."""
  product: Product
  deletedProductId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Product`."""
  productByRelatedProduct: Product
  """An edge for our `Product`. May be used by Relay 1."""
  productEdge(
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge
}

"""All input for the `deleteProduct` mutation."""
input DeleteProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Product` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteProductById` mutation."""
input DeleteProductByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ProjectTemplate` mutation."""
type DeleteProjectTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ProjectTemplate` that was deleted by this mutation."""
  projectTemplate: ProjectTemplate
  deletedProjectTemplateId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `ProjectTemplate`. May be used by Relay 1."""
  projectTemplateEdge(
    """The method to use when ordering `ProjectTemplate`."""
    orderBy: [ProjectTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectTemplatesEdge
}

"""All input for the `deleteProjectTemplate` mutation."""
input DeleteProjectTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ProjectTemplate` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteProjectTemplateById` mutation."""
input DeleteProjectTemplateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Project` mutation."""
type DeleteProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Project` that was deleted by this mutation."""
  project: Project
  deletedProjectId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Project`."""
  customerByCustId: Customer
  """Reads a single `User` that is related to this `Project`."""
  userByStaffId: User
  """Reads a single `TodoList` that is related to this `Project`."""
  todoListByTaskId: TodoList
  """Reads a single `Ticketing` that is related to this `Project`."""
  ticketingByTicketId: Ticketing
  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""All input for the `deleteProject` mutation."""
input DeleteProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Project` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteProjectById` mutation."""
input DeleteProjectByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Provider` mutation."""
type DeleteProviderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Provider` that was deleted by this mutation."""
  provider: Provider
  deletedProviderId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Provider`. May be used by Relay 1."""
  providerEdge(
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProvidersEdge
}

"""All input for the `deleteProvider` mutation."""
input DeleteProviderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Provider` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteProviderById` mutation."""
input DeleteProviderByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Quote` mutation."""
type DeleteQuotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Quote` that was deleted by this mutation."""
  quote: Quote
  deletedQuoteId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Quote`."""
  customerByCustId: Customer
  """Reads a single `Product` that is related to this `Quote`."""
  productByProdId: Product
  """Reads a single `Order` that is related to this `Quote`."""
  orderByOrderId: Order
  """An edge for our `Quote`. May be used by Relay 1."""
  quoteEdge(
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): QuotesEdge
}

"""All input for the `deleteQuote` mutation."""
input DeleteQuoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Quote` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteQuoteById` mutation."""
input DeleteQuoteByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Rating` mutation."""
type DeleteRatingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Rating` that was deleted by this mutation."""
  rating: Rating
  deletedRatingId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Rating`."""
  productByProdId: Product
  """An edge for our `Rating`. May be used by Relay 1."""
  ratingEdge(
    """The method to use when ordering `Rating`."""
    orderBy: [RatingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RatingsEdge
}

"""All input for the `deleteRating` mutation."""
input DeleteRatingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Rating` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteRatingById` mutation."""
input DeleteRatingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Report` mutation."""
type DeleteReportPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Report` that was deleted by this mutation."""
  report: Report
  deletedReportId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Report`. May be used by Relay 1."""
  reportEdge(
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReportsEdge
}

"""All input for the `deleteReport` mutation."""
input DeleteReportInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Report` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteReportById` mutation."""
input DeleteReportByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Return` mutation."""
type DeleteReturnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Return` that was deleted by this mutation."""
  return: Return
  deletedReturnId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `Return`."""
  productByProdId: Product
  """Reads a single `Customer` that is related to this `Return`."""
  customerByCustId: Customer
  """An edge for our `Return`. May be used by Relay 1."""
  returnEdge(
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReturnsEdge
}

"""All input for the `deleteReturn` mutation."""
input DeleteReturnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Return` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteReturnById` mutation."""
input DeleteReturnByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Review` mutation."""
type DeleteReviewPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Review` that was deleted by this mutation."""
  review: Review
  deletedReviewId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Review`. May be used by Relay 1."""
  reviewEdge(
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReviewsEdge
}

"""All input for the `deleteReview` mutation."""
input DeleteReviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Review` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteReviewById` mutation."""
input DeleteReviewByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Reward` mutation."""
type DeleteRewardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Reward` that was deleted by this mutation."""
  reward: Reward
  deletedRewardId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Reward`. May be used by Relay 1."""
  rewardEdge(
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RewardsEdge
}

"""All input for the `deleteReward` mutation."""
input DeleteRewardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Reward` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteRewardById` mutation."""
input DeleteRewardByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Scheduler` mutation."""
type DeleteSchedulerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Scheduler` that was deleted by this mutation."""
  scheduler: Scheduler
  deletedSchedulerId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Scheduler`. May be used by Relay 1."""
  schedulerEdge(
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SchedulersEdge
}

"""All input for the `deleteScheduler` mutation."""
input DeleteSchedulerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Scheduler` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSchedulerById` mutation."""
input DeleteSchedulerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Segment` mutation."""
type DeleteSegmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Segment` that was deleted by this mutation."""
  segment: Segment
  deletedSegmentId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Segment`. May be used by Relay 1."""
  segmentEdge(
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SegmentsEdge
}

"""All input for the `deleteSegment` mutation."""
input DeleteSegmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Segment` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSegmentById` mutation."""
input DeleteSegmentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Settingscustomer` mutation."""
type DeleteSettingscustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingscustomer` that was deleted by this mutation."""
  settingscustomer: Settingscustomer
  deletedSettingscustomerId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingscustomer`. May be used by Relay 1."""
  settingscustomerEdge(
    """The method to use when ordering `Settingscustomer`."""
    orderBy: [SettingscustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingscustomersEdge
}

"""All input for the `deleteSettingscustomer` mutation."""
input DeleteSettingscustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingscustomer` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSettingscustomerById` mutation."""
input DeleteSettingscustomerByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Settingsgeneral` mutation."""
type DeleteSettingsgeneralPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingsgeneral` that was deleted by this mutation."""
  settingsgeneral: Settingsgeneral
  deletedSettingsgeneralId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingsgeneral`. May be used by Relay 1."""
  settingsgeneralEdge(
    """The method to use when ordering `Settingsgeneral`."""
    orderBy: [SettingsgeneralsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsgeneralsEdge
}

"""All input for the `deleteSettingsgeneral` mutation."""
input DeleteSettingsgeneralInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingsgeneral` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSettingsgeneralById` mutation."""
input DeleteSettingsgeneralByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Settingshop` mutation."""
type DeleteSettingshopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingshop` that was deleted by this mutation."""
  settingshop: Settingshop
  deletedSettingshopId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingshop`. May be used by Relay 1."""
  settingshopEdge(
    """The method to use when ordering `Settingshop`."""
    orderBy: [SettingshopsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingshopsEdge
}

"""All input for the `deleteSettingshop` mutation."""
input DeleteSettingshopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingshop` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSettingshopById` mutation."""
input DeleteSettingshopByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Settingsmarketing` mutation."""
type DeleteSettingsmarketingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingsmarketing` that was deleted by this mutation."""
  settingsmarketing: Settingsmarketing
  deletedSettingsmarketingId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingsmarketing`. May be used by Relay 1."""
  settingsmarketingEdge(
    """The method to use when ordering `Settingsmarketing`."""
    orderBy: [SettingsmarketingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsmarketingsEdge
}

"""All input for the `deleteSettingsmarketing` mutation."""
input DeleteSettingsmarketingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingsmarketing` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSettingsmarketingById` mutation."""
input DeleteSettingsmarketingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Settingssale` mutation."""
type DeleteSettingssalePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Settingssale` that was deleted by this mutation."""
  settingssale: Settingssale
  deletedSettingssaleId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Settingssale`. May be used by Relay 1."""
  settingssaleEdge(
    """The method to use when ordering `Settingssale`."""
    orderBy: [SettingssalesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingssalesEdge
}

"""All input for the `deleteSettingssale` mutation."""
input DeleteSettingssaleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Settingssale` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSettingssaleById` mutation."""
input DeleteSettingssaleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Shipment` mutation."""
type DeleteShipmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Shipment` that was deleted by this mutation."""
  shipment: Shipment
  deletedShipmentId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Shipment`. May be used by Relay 1."""
  shipmentEdge(
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShipmentsEdge
}

"""All input for the `deleteShipment` mutation."""
input DeleteShipmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Shipment` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteShipmentById` mutation."""
input DeleteShipmentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ShopSetting` mutation."""
type DeleteShopSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `ShopSetting` that was deleted by this mutation."""
  shopSetting: ShopSetting
  deletedShopSettingId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `ShopSetting`. May be used by Relay 1."""
  shopSettingEdge(
    """The method to use when ordering `ShopSetting`."""
    orderBy: [ShopSettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShopSettingsEdge
}

"""All input for the `deleteShopSetting` mutation."""
input DeleteShopSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `ShopSetting` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteShopSettingById` mutation."""
input DeleteShopSettingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Shop` mutation."""
type DeleteShopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Shop` that was deleted by this mutation."""
  shop: Shop
  deletedShopId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Shop`. May be used by Relay 1."""
  shopEdge(
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShopsEdge
}

"""All input for the `deleteShop` mutation."""
input DeleteShopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Shop` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteShopById` mutation."""
input DeleteShopByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `SpecialDiscount` mutation."""
type DeleteSpecialDiscountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `SpecialDiscount` that was deleted by this mutation."""
  specialDiscount: SpecialDiscount
  deletedSpecialDiscountId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `SpecialDiscount`. May be used by Relay 1."""
  specialDiscountEdge(
    """The method to use when ordering `SpecialDiscount`."""
    orderBy: [SpecialDiscountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SpecialDiscountsEdge
}

"""All input for the `deleteSpecialDiscount` mutation."""
input DeleteSpecialDiscountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `SpecialDiscount` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSpecialDiscountById` mutation."""
input DeleteSpecialDiscountByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `State` mutation."""
type DeleteStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `State` that was deleted by this mutation."""
  state: State
  deletedStateId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `State`. May be used by Relay 1."""
  stateEdge(
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatesEdge
}

"""All input for the `deleteState` mutation."""
input DeleteStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `State` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteStateById` mutation."""
input DeleteStateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Statistic` mutation."""
type DeleteStatisticPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Statistic` that was deleted by this mutation."""
  statistic: Statistic
  deletedStatisticId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Statistic`. May be used by Relay 1."""
  statisticEdge(
    """The method to use when ordering `Statistic`."""
    orderBy: [StatisticsOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatisticsEdge
}

"""All input for the `deleteStatistic` mutation."""
input DeleteStatisticInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Statistic` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteStatisticById` mutation."""
input DeleteStatisticByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Stock` mutation."""
type DeleteStockPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Stock` that was deleted by this mutation."""
  stock: Stock
  deletedStockId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Stock`. May be used by Relay 1."""
  stockEdge(
    """The method to use when ordering `Stock`."""
    orderBy: [StocksOrderBy!] = [PRIMARY_KEY_ASC]
  ): StocksEdge
}

"""All input for the `deleteStock` mutation."""
input DeleteStockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Stock` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteStockById` mutation."""
input DeleteStockByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Survey` mutation."""
type DeleteSurveyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Survey` that was deleted by this mutation."""
  survey: Survey
  deletedSurveyId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Survey`. May be used by Relay 1."""
  surveyEdge(
    """The method to use when ordering `Survey`."""
    orderBy: [SurveysOrderBy!] = [PRIMARY_KEY_ASC]
  ): SurveysEdge
}

"""All input for the `deleteSurvey` mutation."""
input DeleteSurveyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Survey` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteSurveyById` mutation."""
input DeleteSurveyByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Tag` mutation."""
type DeleteTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Tag` that was deleted by this mutation."""
  tag: Tag
  deletedTagId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsEdge
}

"""All input for the `deleteTag` mutation."""
input DeleteTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Tag` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteTagById` mutation."""
input DeleteTagByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Target` mutation."""
type DeleteTargetPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Target` that was deleted by this mutation."""
  target: Target
  deletedTargetId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Target`. May be used by Relay 1."""
  targetEdge(
    """The method to use when ordering `Target`."""
    orderBy: [TargetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TargetsEdge
}

"""All input for the `deleteTarget` mutation."""
input DeleteTargetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Target` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteTargetById` mutation."""
input DeleteTargetByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `TaxCategory` mutation."""
type DeleteTaxCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TaxCategory` that was deleted by this mutation."""
  taxCategory: TaxCategory
  deletedTaxCategoryId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `TaxCategory`. May be used by Relay 1."""
  taxCategoryEdge(
    """The method to use when ordering `TaxCategory`."""
    orderBy: [TaxCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxCategoriesEdge
}

"""All input for the `deleteTaxCategory` mutation."""
input DeleteTaxCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `TaxCategory` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteTaxCategoryById` mutation."""
input DeleteTaxCategoryByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `TaxRate` mutation."""
type DeleteTaxRatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TaxRate` that was deleted by this mutation."""
  taxRate: TaxRate
  deletedTaxRateId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `TaxRate`."""
  productByProdId: Product
  """An edge for our `TaxRate`. May be used by Relay 1."""
  taxRateEdge(
    """The method to use when ordering `TaxRate`."""
    orderBy: [TaxRatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxRatesEdge
}

"""All input for the `deleteTaxRate` mutation."""
input DeleteTaxRateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `TaxRate` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteTaxRateById` mutation."""
input DeleteTaxRateByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `TaxRule` mutation."""
type DeleteTaxRulePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TaxRule` that was deleted by this mutation."""
  taxRule: TaxRule
  deletedTaxRuleId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Product` that is related to this `TaxRule`."""
  productByProdId: Product
  """An edge for our `TaxRule`. May be used by Relay 1."""
  taxRuleEdge(
    """The method to use when ordering `TaxRule`."""
    orderBy: [TaxRulesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxRulesEdge
}

"""All input for the `deleteTaxRule` mutation."""
input DeleteTaxRuleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `TaxRule` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteTaxRuleById` mutation."""
input DeleteTaxRuleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Theme` mutation."""
type DeleteThemePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Theme` that was deleted by this mutation."""
  theme: Theme
  deletedThemeId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Website` that is related to this `Theme`."""
  websiteByWebsiteId: Website
  """An edge for our `Theme`. May be used by Relay 1."""
  themeEdge(
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ThemesEdge
}

"""All input for the `deleteTheme` mutation."""
input DeleteThemeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Theme` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteThemeById` mutation."""
input DeleteThemeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Ticketing` mutation."""
type DeleteTicketingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Ticketing` that was deleted by this mutation."""
  ticketing: Ticketing
  deletedTicketingId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Ticketing`. May be used by Relay 1."""
  ticketingEdge(
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TicketingsEdge
}

"""All input for the `deleteTicketing` mutation."""
input DeleteTicketingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Ticketing` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteTicketingById` mutation."""
input DeleteTicketingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `TodoList` mutation."""
type DeleteTodoListPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `TodoList` that was deleted by this mutation."""
  todoList: TodoList
  deletedTodoListId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `TodoList`. May be used by Relay 1."""
  todoListEdge(
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TodoListsEdge
}

"""All input for the `deleteTodoList` mutation."""
input DeleteTodoListInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `TodoList` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteTodoListById` mutation."""
input DeleteTodoListByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Training` mutation."""
type DeleteTrainingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Training` that was deleted by this mutation."""
  training: Training
  deletedTrainingId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Comment` that is related to this `Training`."""
  commentByComment: Comment
  """Reads a single `Country` that is related to this `Training`."""
  countryByCountry: Country
  """Reads a single `State` that is related to this `Training`."""
  stateByState: State
  """Reads a single `Product` that is related to this `Training`."""
  productByProducts: Product
  """Reads a single `Checklist` that is related to this `Training`."""
  checklistByChecklists: Checklist
  """An edge for our `Training`. May be used by Relay 1."""
  trainingEdge(
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TrainingsEdge
}

"""All input for the `deleteTraining` mutation."""
input DeleteTrainingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Training` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteTrainingById` mutation."""
input DeleteTrainingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Transaction` mutation."""
type DeleteTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Transaction` that was deleted by this mutation."""
  transaction: Transaction
  deletedTransactionId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Order` that is related to this `Transaction`."""
  orderByOrderId: Order
  """Reads a single `CustomerPayment` that is related to this `Transaction`."""
  customerPaymentByPaymentMethod: CustomerPayment
  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""All input for the `deleteTransaction` mutation."""
input DeleteTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Transaction` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteTransactionById` mutation."""
input DeleteTransactionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `UrlRewrite` mutation."""
type DeleteUrlRewritePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `UrlRewrite` that was deleted by this mutation."""
  urlRewrite: UrlRewrite
  deletedUrlRewriteId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `UrlRewrite`. May be used by Relay 1."""
  urlRewriteEdge(
    """The method to use when ordering `UrlRewrite`."""
    orderBy: [UrlRewritesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UrlRewritesEdge
}

"""All input for the `deleteUrlRewrite` mutation."""
input DeleteUrlRewriteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `UrlRewrite` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteUrlRewriteById` mutation."""
input DeleteUrlRewriteByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `UserRole` mutation."""
type DeleteUserRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `UserRole` that was deleted by this mutation."""
  userRole: UserRole
  deletedUserRoleId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `UserRole`. May be used by Relay 1."""
  userRoleEdge(
    """The method to use when ordering `UserRole`."""
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserRolesEdge
}

"""All input for the `deleteUserRole` mutation."""
input DeleteUserRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `UserRole` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteUserRoleById` mutation."""
input DeleteUserRoleByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `User` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteUserById` mutation."""
input DeleteUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Visit` mutation."""
type DeleteVisitPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Visit` that was deleted by this mutation."""
  visit: Visit
  deletedVisitId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Visit`. May be used by Relay 1."""
  visitEdge(
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VisitsEdge
}

"""All input for the `deleteVisit` mutation."""
input DeleteVisitInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Visit` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteVisitById` mutation."""
input DeleteVisitByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Warehouse` mutation."""
type DeleteWarehousePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Warehouse` that was deleted by this mutation."""
  warehouse: Warehouse
  deletedWarehouseId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Warehouse`. May be used by Relay 1."""
  warehouseEdge(
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WarehousesEdge
}

"""All input for the `deleteWarehouse` mutation."""
input DeleteWarehouseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Warehouse` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteWarehouseById` mutation."""
input DeleteWarehouseByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Webhook` mutation."""
type DeleteWebhookPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Webhook` that was deleted by this mutation."""
  webhook: Webhook
  deletedWebhookId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Webhook`. May be used by Relay 1."""
  webhookEdge(
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhooksEdge
}

"""All input for the `deleteWebhook` mutation."""
input DeleteWebhookInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Webhook` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteWebhookById` mutation."""
input DeleteWebhookByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Website` mutation."""
type DeleteWebsitePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Website` that was deleted by this mutation."""
  website: Website
  deletedWebsiteId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Website`. May be used by Relay 1."""
  websiteEdge(
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebsitesEdge
}

"""All input for the `deleteWebsite` mutation."""
input DeleteWebsiteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Website` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteWebsiteById` mutation."""
input DeleteWebsiteByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Wishlist` mutation."""
type DeleteWishlistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Wishlist` that was deleted by this mutation."""
  wishlist: Wishlist
  deletedWishlistId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Wishlist`. May be used by Relay 1."""
  wishlistEdge(
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): WishlistsEdge
}

"""All input for the `deleteWishlist` mutation."""
input DeleteWishlistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Wishlist` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteWishlistById` mutation."""
input DeleteWishlistByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Workspace` mutation."""
type DeleteWorkspacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Workspace` that was deleted by this mutation."""
  workspace: Workspace
  deletedWorkspaceId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """Reads a single `Customer` that is related to this `Workspace`."""
  customerByCustomers: Customer
  """Reads a single `User` that is related to this `Workspace`."""
  userByUsers: User
  """Reads a single `Product` that is related to this `Workspace`."""
  productByProducts: Product
  """Reads a single `TodoList` that is related to this `Workspace`."""
  todoListByTasks: TodoList
  """Reads a single `Brand` that is related to this `Workspace`."""
  brandByBrands: Brand
  """Reads a single `Shop` that is related to this `Workspace`."""
  shopByShops: Shop
  """Reads a single `Category` that is related to this `Workspace`."""
  categoryByCategory: Category
  """Reads a single `Project` that is related to this `Workspace`."""
  projectByProjects: Project
  """An edge for our `Workspace`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspacesEdge
}

"""All input for the `deleteWorkspace` mutation."""
input DeleteWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Workspace` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteWorkspaceById` mutation."""
input DeleteWorkspaceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Zone` mutation."""
type DeleteZonePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """The `Zone` that was deleted by this mutation."""
  zone: Zone
  deletedZoneId: ID
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
  """An edge for our `Zone`. May be used by Relay 1."""
  zoneEdge(
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ZonesEdge
}

"""All input for the `deleteZone` mutation."""
input DeleteZoneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  """The globally unique `ID` which will identify a single `Zone` to be deleted."""
  nodeId: ID!
}

"""All input for the `deleteZoneById` mutation."""
input DeleteZoneByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our `idempotencyDeleteExpiredRecords` mutation."""
type IdempotencyDeleteExpiredRecordsPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  """Our root query field type. Allows us to run any query from our mutation payload."""
  query: Query
}

"""All input for the `idempotencyDeleteExpiredRecords` mutation."""
input IdempotencyDeleteExpiredRecordsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The root subscription type: contains events and live queries you can subscribe to with the `subscription` operation.

#### Live Queries

Live query fields are differentiated by containing `(live)` at the end of their
description, they are added for each field in the `Query` type. When you
subscribe to a live query field, the selection set will be evaluated and sent to
the client, and then most things\* that would cause the output of the selection
set to change will trigger the selection set to be re-evaluated and the results
to be re-sent to the client.

_(\* Not everything: typically only changes to persisted data referenced by the query are detected, not computed fields.)_

Live queries can be very expensive, so try and keep them small and focussed.

#### Events

Event fields will run their selection set when, and only when, the specified
server-side event occurs. This makes them a lot more efficient than Live
Queries, but it is still recommended that you keep payloads fairly small.
"""
type Subscription {
  """Reads and enables pagination through a set of `Endofshift`. (live)"""
  allEndofshifts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EndofshiftCondition
  ): EndofshiftsConnection
  """Reads a set of `Endofshift`. (live)"""
  allEndofshiftsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EndofshiftCondition
  ): [Endofshift!]
  """Reads and enables pagination through a set of `_Schema`. (live)"""
  allSchemas(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `_Schema`."""
    orderBy: [_SchemasOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: _SchemaCondition
  ): _SchemasConnection
  """Reads a set of `_Schema`. (live)"""
  allSchemasList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `_Schema`."""
    orderBy: [_SchemasOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: _SchemaCondition
  ): [_Schema!]
  """Reads and enables pagination through a set of `_PrismaMigration`. (live)"""
  allPrismaMigrations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: _PrismaMigrationCondition
  ): _PrismaMigrationsConnection
  """Reads a set of `_PrismaMigration`. (live)"""
  allPrismaMigrationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: _PrismaMigrationCondition
  ): [_PrismaMigration!]
  """Reads and enables pagination through a set of `Account`. (live)"""
  allAccounts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AccountCondition
  ): AccountsConnection
  """Reads a set of `Account`. (live)"""
  allAccountsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AccountCondition
  ): [Account!]
  """Reads and enables pagination through a set of `Agreement`. (live)"""
  allAgreements(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): AgreementsConnection
  """Reads a set of `Agreement`. (live)"""
  allAgreementsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AgreementCondition
  ): [Agreement!]
  """Reads and enables pagination through a set of `Analytic`. (live)"""
  allAnalytics(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Analytic`."""
    orderBy: [AnalyticsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AnalyticCondition
  ): AnalyticsConnection
  """Reads a set of `Analytic`. (live)"""
  allAnalyticsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Analytic`."""
    orderBy: [AnalyticsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: AnalyticCondition
  ): [Analytic!]
  """Reads and enables pagination through a set of `Apitoken`. (live)"""
  allApitokens(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ApitokenCondition
  ): ApitokensConnection
  """Reads a set of `Apitoken`. (live)"""
  allApitokensList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ApitokenCondition
  ): [Apitoken!]
  """Reads and enables pagination through a set of `Article`. (live)"""
  allArticles(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ArticleCondition
  ): ArticlesConnection
  """Reads a set of `Article`. (live)"""
  allArticlesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ArticleCondition
  ): [Article!]
  """Reads and enables pagination through a set of `Brand`. (live)"""
  allBrands(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): BrandsConnection
  """Reads a set of `Brand`. (live)"""
  allBrandsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: BrandCondition
  ): [Brand!]
  """Reads and enables pagination through a set of `CartPriceRule`. (live)"""
  allCartPriceRules(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CartPriceRule`."""
    orderBy: [CartPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CartPriceRuleCondition
  ): CartPriceRulesConnection
  """Reads a set of `CartPriceRule`. (live)"""
  allCartPriceRulesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CartPriceRule`."""
    orderBy: [CartPriceRulesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CartPriceRuleCondition
  ): [CartPriceRule!]
  """Reads and enables pagination through a set of `Case`. (live)"""
  allCases(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Case`."""
    orderBy: [CasesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CaseCondition
  ): CasesConnection
  """Reads a set of `Case`. (live)"""
  allCasesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Case`."""
    orderBy: [CasesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CaseCondition
  ): [Case!]
  """Reads and enables pagination through a set of `CatalogPriceRule`. (live)"""
  allCatalogPriceRules(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CatalogPriceRule`."""
    orderBy: [CatalogPriceRulesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CatalogPriceRuleCondition
  ): CatalogPriceRulesConnection
  """Reads a set of `CatalogPriceRule`. (live)"""
  allCatalogPriceRulesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CatalogPriceRule`."""
    orderBy: [CatalogPriceRulesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CatalogPriceRuleCondition
  ): [CatalogPriceRule!]
  """Reads and enables pagination through a set of `Category`. (live)"""
  allCategories(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): CategoriesConnection
  """Reads a set of `Category`. (live)"""
  allCategoriesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CategoryCondition
  ): [Category!]
  """Reads and enables pagination through a set of `Channel`. (live)"""
  allChannels(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChannelCondition
  ): ChannelsConnection
  """Reads a set of `Channel`. (live)"""
  allChannelsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChannelCondition
  ): [Channel!]
  """Reads and enables pagination through a set of `Checklist`. (live)"""
  allChecklists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): ChecklistsConnection
  """Reads a set of `Checklist`. (live)"""
  allChecklistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ChecklistCondition
  ): [Checklist!]
  """Reads and enables pagination through a set of `City`. (live)"""
  allCities(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CityCondition
  ): CitiesConnection
  """Reads a set of `City`. (live)"""
  allCitiesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CityCondition
  ): [City!]
  """Reads and enables pagination through a set of `Collection`. (live)"""
  allCollections(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CollectionCondition
  ): CollectionsConnection
  """Reads a set of `Collection`. (live)"""
  allCollectionsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CollectionCondition
  ): [Collection!]
  """Reads and enables pagination through a set of `Comment`. (live)"""
  allComments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): CommentsConnection
  """Reads a set of `Comment`. (live)"""
  allCommentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CommentCondition
  ): [Comment!]
  """Reads and enables pagination through a set of `ContentType`. (live)"""
  allContentTypes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ContentTypeCondition
  ): ContentTypesConnection
  """Reads a set of `ContentType`. (live)"""
  allContentTypesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ContentTypeCondition
  ): [ContentType!]
  """Reads and enables pagination through a set of `Contract`. (live)"""
  allContracts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Contract`."""
    orderBy: [ContractsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ContractCondition
  ): ContractsConnection
  """Reads a set of `Contract`. (live)"""
  allContractsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Contract`."""
    orderBy: [ContractsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ContractCondition
  ): [Contract!]
  """Reads and enables pagination through a set of `Country`. (live)"""
  allCountries(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): CountriesConnection
  """Reads a set of `Country`. (live)"""
  allCountriesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CountryCondition
  ): [Country!]
  """Reads and enables pagination through a set of `Coupon`. (live)"""
  allCoupons(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CouponCondition
  ): CouponsConnection
  """Reads a set of `Coupon`. (live)"""
  allCouponsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Coupon`."""
    orderBy: [CouponsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CouponCondition
  ): [Coupon!]
  """Reads and enables pagination through a set of `CreditMemo`. (live)"""
  allCreditMemos(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): CreditMemosConnection
  """Reads a set of `CreditMemo`. (live)"""
  allCreditMemosList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CreditMemo`."""
    orderBy: [CreditMemosOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CreditMemoCondition
  ): [CreditMemo!]
  """Reads and enables pagination through a set of `Currency`. (live)"""
  allCurrencies(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencyCondition
  ): CurrenciesConnection
  """Reads a set of `Currency`. (live)"""
  allCurrenciesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencyCondition
  ): [Currency!]
  """Reads and enables pagination through a set of `CurrencyRate`. (live)"""
  allCurrencyRates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CurrencyRate`."""
    orderBy: [CurrencyRatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencyRateCondition
  ): CurrencyRatesConnection
  """Reads a set of `CurrencyRate`. (live)"""
  allCurrencyRatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CurrencyRate`."""
    orderBy: [CurrencyRatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencyRateCondition
  ): [CurrencyRate!]
  """Reads and enables pagination through a set of `CurrencySymbol`. (live)"""
  allCurrencySymbols(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CurrencySymbol`."""
    orderBy: [CurrencySymbolsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencySymbolCondition
  ): CurrencySymbolsConnection
  """Reads a set of `CurrencySymbol`. (live)"""
  allCurrencySymbolsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CurrencySymbol`."""
    orderBy: [CurrencySymbolsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CurrencySymbolCondition
  ): [CurrencySymbol!]
  """Reads and enables pagination through a set of `CustomerGroup`. (live)"""
  allCustomerGroups(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CustomerGroup`."""
    orderBy: [CustomerGroupsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerGroupCondition
  ): CustomerGroupsConnection
  """Reads a set of `CustomerGroup`. (live)"""
  allCustomerGroupsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CustomerGroup`."""
    orderBy: [CustomerGroupsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerGroupCondition
  ): [CustomerGroup!]
  """Reads and enables pagination through a set of `CustomerPayment`. (live)"""
  allCustomerPayments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerPaymentCondition
  ): CustomerPaymentsConnection
  """Reads a set of `CustomerPayment`. (live)"""
  allCustomerPaymentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `CustomerPayment`."""
    orderBy: [CustomerPaymentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerPaymentCondition
  ): [CustomerPayment!]
  """Reads and enables pagination through a set of `Customer`. (live)"""
  allCustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): CustomersConnection
  """Reads a set of `Customer`. (live)"""
  allCustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomerCondition
  ): [Customer!]
  """Reads and enables pagination through a set of `Customization`. (live)"""
  allCustomizations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Customization`."""
    orderBy: [CustomizationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomizationCondition
  ): CustomizationsConnection
  """Reads a set of `Customization`. (live)"""
  allCustomizationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Customization`."""
    orderBy: [CustomizationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: CustomizationCondition
  ): [Customization!]
  """Reads and enables pagination through a set of `Dashboard`. (live)"""
  allDashboards(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: DashboardCondition
  ): DashboardsConnection
  """Reads a set of `Dashboard`. (live)"""
  allDashboardsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: DashboardCondition
  ): [Dashboard!]
  """Reads and enables pagination through a set of `Deepdive`. (live)"""
  allDeepdives(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: DeepdiveCondition
  ): DeepdivesConnection
  """Reads a set of `Deepdive`. (live)"""
  allDeepdivesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: DeepdiveCondition
  ): [Deepdive!]
  """Reads and enables pagination through a set of `EmailTemplate`. (live)"""
  allEmailTemplates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `EmailTemplate`."""
    orderBy: [EmailTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailTemplateCondition
  ): EmailTemplatesConnection
  """Reads a set of `EmailTemplate`. (live)"""
  allEmailTemplatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `EmailTemplate`."""
    orderBy: [EmailTemplatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailTemplateCondition
  ): [EmailTemplate!]
  """Reads and enables pagination through a set of `Email`. (live)"""
  allEmails(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): EmailsConnection
  """Reads a set of `Email`. (live)"""
  allEmailsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EmailCondition
  ): [Email!]
  """Reads and enables pagination through a set of `Event`. (live)"""
  allEvents(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EventCondition
  ): EventsConnection
  """Reads a set of `Event`. (live)"""
  allEventsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: EventCondition
  ): [Event!]
  """Reads and enables pagination through a set of `Fullfillment`. (live)"""
  allFullfillments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: FullfillmentCondition
  ): FullfillmentsConnection
  """Reads a set of `Fullfillment`. (live)"""
  allFullfillmentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: FullfillmentCondition
  ): [Fullfillment!]
  """Reads and enables pagination through a set of `GeneralSetting`. (live)"""
  allGeneralSettings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `GeneralSetting`."""
    orderBy: [GeneralSettingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GeneralSettingCondition
  ): GeneralSettingsConnection
  """Reads a set of `GeneralSetting`. (live)"""
  allGeneralSettingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `GeneralSetting`."""
    orderBy: [GeneralSettingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GeneralSettingCondition
  ): [GeneralSetting!]
  """Reads and enables pagination through a set of `GiftCertificate`. (live)"""
  allGiftCertificates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `GiftCertificate`."""
    orderBy: [GiftCertificatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GiftCertificateCondition
  ): GiftCertificatesConnection
  """Reads a set of `GiftCertificate`. (live)"""
  allGiftCertificatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `GiftCertificate`."""
    orderBy: [GiftCertificatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GiftCertificateCondition
  ): [GiftCertificate!]
  """Reads and enables pagination through a set of `Glossary`. (live)"""
  allGlossaries(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GlossaryCondition
  ): GlossariesConnection
  """Reads a set of `Glossary`. (live)"""
  allGlossariesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: GlossaryCondition
  ): [Glossary!]
  """Reads and enables pagination through a set of `Importm`. (live)"""
  allImportms(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Importm`."""
    orderBy: [ImportmsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ImportmCondition
  ): ImportmsConnection
  """Reads a set of `Importm`. (live)"""
  allImportmsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Importm`."""
    orderBy: [ImportmsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ImportmCondition
  ): [Importm!]
  """Reads and enables pagination through a set of `Integration`. (live)"""
  allIntegrations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: IntegrationCondition
  ): IntegrationsConnection
  """Reads a set of `Integration`. (live)"""
  allIntegrationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: IntegrationCondition
  ): [Integration!]
  """Reads and enables pagination through a set of `Internalization`. (live)"""
  allInternalizations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InternalizationCondition
  ): InternalizationsConnection
  """Reads a set of `Internalization`. (live)"""
  allInternalizationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InternalizationCondition
  ): [Internalization!]
  """Reads and enables pagination through a set of `Invitation`. (live)"""
  allInvitations(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Invitation`."""
    orderBy: [InvitationsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InvitationCondition
  ): InvitationsConnection
  """Reads a set of `Invitation`. (live)"""
  allInvitationsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Invitation`."""
    orderBy: [InvitationsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InvitationCondition
  ): [Invitation!]
  """Reads and enables pagination through a set of `Invoice`. (live)"""
  allInvoices(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InvoiceCondition
  ): InvoicesConnection
  """Reads a set of `Invoice`. (live)"""
  allInvoicesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: InvoiceCondition
  ): [Invoice!]
  """Reads and enables pagination through a set of `Knowledgebase`. (live)"""
  allKnowledgebases(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Knowledgebase`."""
    orderBy: [KnowledgebasesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: KnowledgebaseCondition
  ): KnowledgebasesConnection
  """Reads a set of `Knowledgebase`. (live)"""
  allKnowledgebasesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Knowledgebase`."""
    orderBy: [KnowledgebasesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: KnowledgebaseCondition
  ): [Knowledgebase!]
  """Reads and enables pagination through a set of `Lead`. (live)"""
  allLeads(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Lead`."""
    orderBy: [LeadsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: LeadCondition
  ): LeadsConnection
  """Reads a set of `Lead`. (live)"""
  allLeadsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Lead`."""
    orderBy: [LeadsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: LeadCondition
  ): [Lead!]
  """Reads and enables pagination through a set of `Manufacturer`. (live)"""
  allManufacturers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ManufacturerCondition
  ): ManufacturersConnection
  """Reads a set of `Manufacturer`. (live)"""
  allManufacturersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ManufacturerCondition
  ): [Manufacturer!]
  """Reads and enables pagination through a set of `Mediamanager`. (live)"""
  allMediamanagers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): MediamanagersConnection
  """Reads a set of `Mediamanager`. (live)"""
  allMediamanagersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MediamanagerCondition
  ): [Mediamanager!]
  """Reads and enables pagination through a set of `Meeting`. (live)"""
  allMeetings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MeetingCondition
  ): MeetingsConnection
  """Reads a set of `Meeting`. (live)"""
  allMeetingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Meeting`."""
    orderBy: [MeetingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MeetingCondition
  ): [Meeting!]
  """Reads and enables pagination through a set of `Message`. (live)"""
  allMessages(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): MessagesConnection
  """Reads a set of `Message`. (live)"""
  allMessagesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: MessageCondition
  ): [Message!]
  """Reads and enables pagination through a set of `NewsletterSubscriber`. (live)"""
  allNewsletterSubscribers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `NewsletterSubscriber`."""
    orderBy: [NewsletterSubscribersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: NewsletterSubscriberCondition
  ): NewsletterSubscribersConnection
  """Reads a set of `NewsletterSubscriber`. (live)"""
  allNewsletterSubscribersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `NewsletterSubscriber`."""
    orderBy: [NewsletterSubscribersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: NewsletterSubscriberCondition
  ): [NewsletterSubscriber!]
  """Reads and enables pagination through a set of `Occassion`. (live)"""
  allOccassions(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): OccassionsConnection
  """Reads a set of `Occassion`. (live)"""
  allOccassionsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Occassion`."""
    orderBy: [OccassionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OccassionCondition
  ): [Occassion!]
  """Reads and enables pagination through a set of `Ooto`. (live)"""
  allOotos(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OotoCondition
  ): OotosConnection
  """Reads a set of `Ooto`. (live)"""
  allOotosList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OotoCondition
  ): [Ooto!]
  """Reads and enables pagination through a set of `Opportunity`. (live)"""
  allOpportunities(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Opportunity`."""
    orderBy: [OpportunitiesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OpportunityCondition
  ): OpportunitiesConnection
  """Reads a set of `Opportunity`. (live)"""
  allOpportunitiesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Opportunity`."""
    orderBy: [OpportunitiesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OpportunityCondition
  ): [Opportunity!]
  """Reads and enables pagination through a set of `Order`. (live)"""
  allOrders(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): OrdersConnection
  """Reads a set of `Order`. (live)"""
  allOrdersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: OrderCondition
  ): [Order!]
  """Reads and enables pagination through a set of `Page`. (live)"""
  allPages(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PageCondition
  ): PagesConnection
  """Reads a set of `Page`. (live)"""
  allPagesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PageCondition
  ): [Page!]
  """Reads and enables pagination through a set of `Partner`. (live)"""
  allPartners(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PartnerCondition
  ): PartnersConnection
  """Reads a set of `Partner`. (live)"""
  allPartnersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PartnerCondition
  ): [Partner!]
  """Reads and enables pagination through a set of `Payment`. (live)"""
  allPayments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PaymentCondition
  ): PaymentsConnection
  """Reads a set of `Payment`. (live)"""
  allPaymentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PaymentCondition
  ): [Payment!]
  """Reads and enables pagination through a set of `PdfTemplate`. (live)"""
  allPdfTemplates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `PdfTemplate`."""
    orderBy: [PdfTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PdfTemplateCondition
  ): PdfTemplatesConnection
  """Reads a set of `PdfTemplate`. (live)"""
  allPdfTemplatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `PdfTemplate`."""
    orderBy: [PdfTemplatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PdfTemplateCondition
  ): [PdfTemplate!]
  """Reads and enables pagination through a set of `Permission`. (live)"""
  allPermissions(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PermissionCondition
  ): PermissionsConnection
  """Reads a set of `Permission`. (live)"""
  allPermissionsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PermissionCondition
  ): [Permission!]
  """Reads and enables pagination through a set of `Plugin`. (live)"""
  allPlugins(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PluginCondition
  ): PluginsConnection
  """Reads a set of `Plugin`. (live)"""
  allPluginsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: PluginCondition
  ): [Plugin!]
  """Reads and enables pagination through a set of `ProductAttribute`. (live)"""
  allProductAttributes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ProductAttribute`."""
    orderBy: [ProductAttributesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductAttributeCondition
  ): ProductAttributesConnection
  """Reads a set of `ProductAttribute`. (live)"""
  allProductAttributesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ProductAttribute`."""
    orderBy: [ProductAttributesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductAttributeCondition
  ): [ProductAttribute!]
  """Reads and enables pagination through a set of `ProductType`. (live)"""
  allProductTypes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductTypeCondition
  ): ProductTypesConnection
  """Reads a set of `ProductType`. (live)"""
  allProductTypesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductTypeCondition
  ): [ProductType!]
  """Reads and enables pagination through a set of `Product`. (live)"""
  allProducts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): ProductsConnection
  """Reads a set of `Product`. (live)"""
  allProductsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProductCondition
  ): [Product!]
  """Reads and enables pagination through a set of `ProjectTemplate`. (live)"""
  allProjectTemplates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ProjectTemplate`."""
    orderBy: [ProjectTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectTemplateCondition
  ): ProjectTemplatesConnection
  """Reads a set of `ProjectTemplate`. (live)"""
  allProjectTemplatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ProjectTemplate`."""
    orderBy: [ProjectTemplatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectTemplateCondition
  ): [ProjectTemplate!]
  """Reads and enables pagination through a set of `Project`. (live)"""
  allProjects(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): ProjectsConnection
  """Reads a set of `Project`. (live)"""
  allProjectsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProjectCondition
  ): [Project!]
  """Reads and enables pagination through a set of `Provider`. (live)"""
  allProviders(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProviderCondition
  ): ProvidersConnection
  """Reads a set of `Provider`. (live)"""
  allProvidersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ProviderCondition
  ): [Provider!]
  """Reads and enables pagination through a set of `Quote`. (live)"""
  allQuotes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): QuotesConnection
  """Reads a set of `Quote`. (live)"""
  allQuotesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: QuoteCondition
  ): [Quote!]
  """Reads and enables pagination through a set of `Rating`. (live)"""
  allRatings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Rating`."""
    orderBy: [RatingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RatingCondition
  ): RatingsConnection
  """Reads a set of `Rating`. (live)"""
  allRatingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Rating`."""
    orderBy: [RatingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RatingCondition
  ): [Rating!]
  """Reads and enables pagination through a set of `Report`. (live)"""
  allReports(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReportCondition
  ): ReportsConnection
  """Reads a set of `Report`. (live)"""
  allReportsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Report`."""
    orderBy: [ReportsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReportCondition
  ): [Report!]
  """Reads and enables pagination through a set of `Return`. (live)"""
  allReturns(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): ReturnsConnection
  """Reads a set of `Return`. (live)"""
  allReturnsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReturnCondition
  ): [Return!]
  """Reads and enables pagination through a set of `Review`. (live)"""
  allReviews(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReviewCondition
  ): ReviewsConnection
  """Reads a set of `Review`. (live)"""
  allReviewsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ReviewCondition
  ): [Review!]
  """Reads and enables pagination through a set of `Reward`. (live)"""
  allRewards(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RewardCondition
  ): RewardsConnection
  """Reads a set of `Reward`. (live)"""
  allRewardsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: RewardCondition
  ): [Reward!]
  """Reads and enables pagination through a set of `Scheduler`. (live)"""
  allSchedulers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SchedulerCondition
  ): SchedulersConnection
  """Reads a set of `Scheduler`. (live)"""
  allSchedulersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SchedulerCondition
  ): [Scheduler!]
  """Reads and enables pagination through a set of `Segment`. (live)"""
  allSegments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SegmentCondition
  ): SegmentsConnection
  """Reads a set of `Segment`. (live)"""
  allSegmentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SegmentCondition
  ): [Segment!]
  """Reads and enables pagination through a set of `Settingscustomer`. (live)"""
  allSettingscustomers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingscustomer`."""
    orderBy: [SettingscustomersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingscustomerCondition
  ): SettingscustomersConnection
  """Reads a set of `Settingscustomer`. (live)"""
  allSettingscustomersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingscustomer`."""
    orderBy: [SettingscustomersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingscustomerCondition
  ): [Settingscustomer!]
  """Reads and enables pagination through a set of `Settingsgeneral`. (live)"""
  allSettingsgenerals(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingsgeneral`."""
    orderBy: [SettingsgeneralsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingsgeneralCondition
  ): SettingsgeneralsConnection
  """Reads a set of `Settingsgeneral`. (live)"""
  allSettingsgeneralsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingsgeneral`."""
    orderBy: [SettingsgeneralsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingsgeneralCondition
  ): [Settingsgeneral!]
  """Reads and enables pagination through a set of `Settingshop`. (live)"""
  allSettingshops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingshop`."""
    orderBy: [SettingshopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingshopCondition
  ): SettingshopsConnection
  """Reads a set of `Settingshop`. (live)"""
  allSettingshopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingshop`."""
    orderBy: [SettingshopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingshopCondition
  ): [Settingshop!]
  """Reads and enables pagination through a set of `Settingsmarketing`. (live)"""
  allSettingsmarketings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingsmarketing`."""
    orderBy: [SettingsmarketingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingsmarketingCondition
  ): SettingsmarketingsConnection
  """Reads a set of `Settingsmarketing`. (live)"""
  allSettingsmarketingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingsmarketing`."""
    orderBy: [SettingsmarketingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingsmarketingCondition
  ): [Settingsmarketing!]
  """Reads and enables pagination through a set of `Settingssale`. (live)"""
  allSettingssales(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Settingssale`."""
    orderBy: [SettingssalesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingssaleCondition
  ): SettingssalesConnection
  """Reads a set of `Settingssale`. (live)"""
  allSettingssalesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Settingssale`."""
    orderBy: [SettingssalesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SettingssaleCondition
  ): [Settingssale!]
  """Reads and enables pagination through a set of `Shipment`. (live)"""
  allShipments(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShipmentCondition
  ): ShipmentsConnection
  """Reads a set of `Shipment`. (live)"""
  allShipmentsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShipmentCondition
  ): [Shipment!]
  """Reads and enables pagination through a set of `ShopSetting`. (live)"""
  allShopSettings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `ShopSetting`."""
    orderBy: [ShopSettingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopSettingCondition
  ): ShopSettingsConnection
  """Reads a set of `ShopSetting`. (live)"""
  allShopSettingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `ShopSetting`."""
    orderBy: [ShopSettingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopSettingCondition
  ): [ShopSetting!]
  """Reads and enables pagination through a set of `Shop`. (live)"""
  allShops(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): ShopsConnection
  """Reads a set of `Shop`. (live)"""
  allShopsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Shop`."""
    orderBy: [ShopsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ShopCondition
  ): [Shop!]
  """Reads and enables pagination through a set of `SpecialDiscount`. (live)"""
  allSpecialDiscounts(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `SpecialDiscount`."""
    orderBy: [SpecialDiscountsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SpecialDiscountCondition
  ): SpecialDiscountsConnection
  """Reads a set of `SpecialDiscount`. (live)"""
  allSpecialDiscountsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `SpecialDiscount`."""
    orderBy: [SpecialDiscountsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SpecialDiscountCondition
  ): [SpecialDiscount!]
  """Reads and enables pagination through a set of `State`. (live)"""
  allStates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): StatesConnection
  """Reads a set of `State`. (live)"""
  allStatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StateCondition
  ): [State!]
  """Reads and enables pagination through a set of `Statistic`. (live)"""
  allStatistics(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Statistic`."""
    orderBy: [StatisticsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StatisticCondition
  ): StatisticsConnection
  """Reads a set of `Statistic`. (live)"""
  allStatisticsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Statistic`."""
    orderBy: [StatisticsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StatisticCondition
  ): [Statistic!]
  """Reads and enables pagination through a set of `Stock`. (live)"""
  allStocks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Stock`."""
    orderBy: [StocksOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StockCondition
  ): StocksConnection
  """Reads a set of `Stock`. (live)"""
  allStocksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Stock`."""
    orderBy: [StocksOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: StockCondition
  ): [Stock!]
  """Reads and enables pagination through a set of `Survey`. (live)"""
  allSurveys(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Survey`."""
    orderBy: [SurveysOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SurveyCondition
  ): SurveysConnection
  """Reads a set of `Survey`. (live)"""
  allSurveysList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Survey`."""
    orderBy: [SurveysOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: SurveyCondition
  ): [Survey!]
  """Reads and enables pagination through a set of `Tag`. (live)"""
  allTags(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TagCondition
  ): TagsConnection
  """Reads a set of `Tag`. (live)"""
  allTagsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TagCondition
  ): [Tag!]
  """Reads and enables pagination through a set of `Target`. (live)"""
  allTargets(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Target`."""
    orderBy: [TargetsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TargetCondition
  ): TargetsConnection
  """Reads a set of `Target`. (live)"""
  allTargetsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Target`."""
    orderBy: [TargetsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TargetCondition
  ): [Target!]
  """Reads and enables pagination through a set of `TaxCategory`. (live)"""
  allTaxCategories(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TaxCategory`."""
    orderBy: [TaxCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxCategoryCondition
  ): TaxCategoriesConnection
  """Reads a set of `TaxCategory`. (live)"""
  allTaxCategoriesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TaxCategory`."""
    orderBy: [TaxCategoriesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxCategoryCondition
  ): [TaxCategory!]
  """Reads and enables pagination through a set of `TaxRate`. (live)"""
  allTaxRates(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TaxRate`."""
    orderBy: [TaxRatesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRateCondition
  ): TaxRatesConnection
  """Reads a set of `TaxRate`. (live)"""
  allTaxRatesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TaxRate`."""
    orderBy: [TaxRatesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRateCondition
  ): [TaxRate!]
  """Reads and enables pagination through a set of `TaxRule`. (live)"""
  allTaxRules(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TaxRule`."""
    orderBy: [TaxRulesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRuleCondition
  ): TaxRulesConnection
  """Reads a set of `TaxRule`. (live)"""
  allTaxRulesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TaxRule`."""
    orderBy: [TaxRulesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TaxRuleCondition
  ): [TaxRule!]
  """Reads and enables pagination through a set of `Theme`. (live)"""
  allThemes(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ThemeCondition
  ): ThemesConnection
  """Reads a set of `Theme`. (live)"""
  allThemesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ThemeCondition
  ): [Theme!]
  """Reads and enables pagination through a set of `Ticketing`. (live)"""
  allTicketings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): TicketingsConnection
  """Reads a set of `Ticketing`. (live)"""
  allTicketingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TicketingCondition
  ): [Ticketing!]
  """Reads and enables pagination through a set of `TodoList`. (live)"""
  allTodoLists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): TodoListsConnection
  """Reads a set of `TodoList`. (live)"""
  allTodoListsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `TodoList`."""
    orderBy: [TodoListsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TodoListCondition
  ): [TodoList!]
  """Reads and enables pagination through a set of `Training`. (live)"""
  allTrainings(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): TrainingsConnection
  """Reads a set of `Training`. (live)"""
  allTrainingsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Training`."""
    orderBy: [TrainingsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TrainingCondition
  ): [Training!]
  """Reads and enables pagination through a set of `Transaction`. (live)"""
  allTransactions(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): TransactionsConnection
  """Reads a set of `Transaction`. (live)"""
  allTransactionsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: TransactionCondition
  ): [Transaction!]
  """Reads and enables pagination through a set of `UrlRewrite`. (live)"""
  allUrlRewrites(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `UrlRewrite`."""
    orderBy: [UrlRewritesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UrlRewriteCondition
  ): UrlRewritesConnection
  """Reads a set of `UrlRewrite`. (live)"""
  allUrlRewritesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `UrlRewrite`."""
    orderBy: [UrlRewritesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UrlRewriteCondition
  ): [UrlRewrite!]
  """Reads and enables pagination through a set of `UserRole`. (live)"""
  allUserRoles(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `UserRole`."""
    orderBy: [UserRolesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserRoleCondition
  ): UserRolesConnection
  """Reads a set of `UserRole`. (live)"""
  allUserRolesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `UserRole`."""
    orderBy: [UserRolesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserRoleCondition
  ): [UserRole!]
  """Reads and enables pagination through a set of `User`. (live)"""
  allUsers(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): UsersConnection
  """Reads a set of `User`. (live)"""
  allUsersList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: UserCondition
  ): [User!]
  """Reads and enables pagination through a set of `Visit`. (live)"""
  allVisits(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: VisitCondition
  ): VisitsConnection
  """Reads a set of `Visit`. (live)"""
  allVisitsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: VisitCondition
  ): [Visit!]
  """Reads and enables pagination through a set of `Warehouse`. (live)"""
  allWarehouses(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WarehouseCondition
  ): WarehousesConnection
  """Reads a set of `Warehouse`. (live)"""
  allWarehousesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WarehouseCondition
  ): [Warehouse!]
  """Reads and enables pagination through a set of `Webhook`. (live)"""
  allWebhooks(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WebhookCondition
  ): WebhooksConnection
  """Reads a set of `Webhook`. (live)"""
  allWebhooksList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WebhookCondition
  ): [Webhook!]
  """Reads and enables pagination through a set of `Website`. (live)"""
  allWebsites(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WebsiteCondition
  ): WebsitesConnection
  """Reads a set of `Website`. (live)"""
  allWebsitesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WebsiteCondition
  ): [Website!]
  """Reads and enables pagination through a set of `Wishlist`. (live)"""
  allWishlists(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WishlistCondition
  ): WishlistsConnection
  """Reads a set of `Wishlist`. (live)"""
  allWishlistsList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WishlistCondition
  ): [Wishlist!]
  """Reads and enables pagination through a set of `Workspace`. (live)"""
  allWorkspaces(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): WorkspacesConnection
  """Reads a set of `Workspace`. (live)"""
  allWorkspacesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: WorkspaceCondition
  ): [Workspace!]
  """Reads and enables pagination through a set of `Zone`. (live)"""
  allZones(
    """Only read the first `n` values of the set."""
    first: Int
    """Only read the last `n` values of the set."""
    last: Int
    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    """Read all values in the set before (above) this cursor."""
    before: Cursor
    """Read all values in the set after (below) this cursor."""
    after: Cursor
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!] = [PRIMARY_KEY_ASC]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ZoneCondition
  ): ZonesConnection
  """Reads a set of `Zone`. (live)"""
  allZonesList(
    """Only read the first `n` values of the set."""
    first: Int
    """Skip the first `n` values."""
    offset: Int
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!]
    """A condition to be used in determining which values should be returned by the collection."""
    condition: ZoneCondition
  ): [Zone!]
  """ (live)"""
  endofshiftById(id: BigInt!): Endofshift
  """ (live)"""
  _schemaByClassName(className: String!): _Schema
  """ (live)"""
  _prismaMigrationById(id: String!): _PrismaMigration
  """ (live)"""
  accountById(id: BigInt!): Account
  """ (live)"""
  agreementById(id: BigInt!): Agreement
  """ (live)"""
  analyticById(id: BigInt!): Analytic
  """ (live)"""
  apitokenById(id: BigInt!): Apitoken
  """ (live)"""
  articleById(id: Int!): Article
  """ (live)"""
  brandById(id: BigInt!): Brand
  """ (live)"""
  cartPriceRuleById(id: Int!): CartPriceRule
  """ (live)"""
  caseById(id: BigInt!): Case
  """ (live)"""
  catalogPriceRuleById(id: Int!): CatalogPriceRule
  """ (live)"""
  categoryById(id: Int!): Category
  """ (live)"""
  channelById(id: BigInt!): Channel
  """ (live)"""
  checklistById(id: BigInt!): Checklist
  """ (live)"""
  cityById(id: Int!): City
  """ (live)"""
  collectionById(id: BigInt!): Collection
  """ (live)"""
  commentById(id: Int!): Comment
  """ (live)"""
  contentTypeById(id: BigInt!): ContentType
  """ (live)"""
  contractById(id: BigInt!): Contract
  """ (live)"""
  countryById(id: Int!): Country
  """ (live)"""
  couponById(id: BigInt!): Coupon
  """ (live)"""
  creditMemoByCreditMemoAndId(creditMemo: String!, id: BigInt!): CreditMemo
  """ (live)"""
  currencyById(id: BigInt!): Currency
  """ (live)"""
  currencyRateByImportService(importService: String!): CurrencyRate
  """ (live)"""
  currencyRateById(id: BigInt!): CurrencyRate
  """ (live)"""
  currencySymbolBySymbol(symbol: String!): CurrencySymbol
  """ (live)"""
  currencySymbolById(id: BigInt!): CurrencySymbol
  """ (live)"""
  customerGroupById(id: BigInt!): CustomerGroup
  """ (live)"""
  customerPaymentById(id: BigInt!): CustomerPayment
  """ (live)"""
  customerById(id: Int!): Customer
  """ (live)"""
  customizationById(id: Int!): Customization
  """ (live)"""
  dashboardById(id: BigInt!): Dashboard
  """ (live)"""
  deepdiveById(id: BigInt!): Deepdive
  """ (live)"""
  emailTemplateById(id: BigInt!): EmailTemplate
  """ (live)"""
  emailById(id: Int!): Email
  """ (live)"""
  eventById(id: BigInt!): Event
  """ (live)"""
  fullfillmentById(id: BigInt!): Fullfillment
  """ (live)"""
  generalSettingById(id: BigInt!): GeneralSetting
  """ (live)"""
  giftCertificateById(id: BigInt!): GiftCertificate
  """ (live)"""
  glossaryById(id: Int!): Glossary
  """ (live)"""
  importmById(id: BigInt!): Importm
  """ (live)"""
  integrationById(id: BigInt!): Integration
  """ (live)"""
  internalizationById(id: BigInt!): Internalization
  """ (live)"""
  invitationById(id: BigInt!): Invitation
  """ (live)"""
  invoiceById(id: BigInt!): Invoice
  """ (live)"""
  knowledgebaseById(id: BigInt!): Knowledgebase
  """ (live)"""
  leadById(id: BigInt!): Lead
  """ (live)"""
  manufacturerById(id: BigInt!): Manufacturer
  """ (live)"""
  mediamanagerById(id: Int!): Mediamanager
  """ (live)"""
  meetingById(id: BigInt!): Meeting
  """ (live)"""
  messageById(id: Int!): Message
  """ (live)"""
  newsletterSubscriberById(id: Int!): NewsletterSubscriber
  """ (live)"""
  occassionById(id: BigInt!): Occassion
  """ (live)"""
  ootoById(id: BigInt!): Ooto
  """ (live)"""
  opportunityById(id: BigInt!): Opportunity
  """ (live)"""
  orderById(id: Int!): Order
  """ (live)"""
  pageById(id: BigInt!): Page
  """ (live)"""
  partnerById(id: BigInt!): Partner
  """ (live)"""
  paymentById(id: BigInt!): Payment
  """ (live)"""
  pdfTemplateById(id: BigInt!): PdfTemplate
  """ (live)"""
  permissionById(id: BigInt!): Permission
  """ (live)"""
  pluginById(id: BigInt!): Plugin
  """ (live)"""
  productAttributeById(id: BigInt!): ProductAttribute
  """ (live)"""
  productTypeById(id: BigInt!): ProductType
  """ (live)"""
  productById(id: BigInt!): Product
  """ (live)"""
  projectTemplateById(id: BigInt!): ProjectTemplate
  """ (live)"""
  projectById(id: BigInt!): Project
  """ (live)"""
  providerById(id: BigInt!): Provider
  """ (live)"""
  quoteById(id: BigInt!): Quote
  """ (live)"""
  ratingById(id: BigInt!): Rating
  """ (live)"""
  reportById(id: BigInt!): Report
  """ (live)"""
  returnById(id: BigInt!): Return
  """ (live)"""
  reviewById(id: BigInt!): Review
  """ (live)"""
  rewardById(id: BigInt!): Reward
  """ (live)"""
  schedulerById(id: BigInt!): Scheduler
  """ (live)"""
  segmentById(id: BigInt!): Segment
  """ (live)"""
  settingscustomerById(id: BigInt!): Settingscustomer
  """ (live)"""
  settingsgeneralById(id: BigInt!): Settingsgeneral
  """ (live)"""
  settingshopById(id: BigInt!): Settingshop
  """ (live)"""
  settingsmarketingById(id: BigInt!): Settingsmarketing
  """ (live)"""
  settingssaleById(id: BigInt!): Settingssale
  """ (live)"""
  shipmentById(id: BigInt!): Shipment
  """ (live)"""
  shopSettingById(id: BigInt!): ShopSetting
  """ (live)"""
  shopById(id: BigInt!): Shop
  """ (live)"""
  specialDiscountById(id: BigInt!): SpecialDiscount
  """ (live)"""
  stateById(id: BigInt!): State
  """ (live)"""
  statisticById(id: BigInt!): Statistic
  """ (live)"""
  stockById(id: BigInt!): Stock
  """ (live)"""
  surveyById(id: BigInt!): Survey
  """ (live)"""
  tagById(id: BigInt!): Tag
  """ (live)"""
  targetById(id: BigInt!): Target
  """ (live)"""
  taxCategoryById(id: BigInt!): TaxCategory
  """ (live)"""
  taxRateById(id: BigInt!): TaxRate
  """ (live)"""
  taxRuleById(id: BigInt!): TaxRule
  """ (live)"""
  themeById(id: BigInt!): Theme
  """ (live)"""
  ticketingById(id: BigInt!): Ticketing
  """ (live)"""
  todoListById(id: BigInt!): TodoList
  """ (live)"""
  trainingById(id: BigInt!): Training
  """ (live)"""
  transactionById(id: BigInt!): Transaction
  """ (live)"""
  urlRewriteById(id: BigInt!): UrlRewrite
  """ (live)"""
  userRoleById(id: BigInt!): UserRole
  """ (live)"""
  userById(id: BigInt!): User
  """ (live)"""
  visitById(id: BigInt!): Visit
  """ (live)"""
  warehouseById(id: BigInt!): Warehouse
  """ (live)"""
  webhookById(id: BigInt!): Webhook
  """ (live)"""
  websiteById(id: BigInt!): Website
  """ (live)"""
  wishlistById(id: BigInt!): Wishlist
  """ (live)"""
  workspaceById(id: BigInt!): Workspace
  """ (live)"""
  zoneById(id: BigInt!): Zone
  """ (live)"""
  arrayAdd(array: JSON!, values: JSON!): JSON
  """ (live)"""
  arrayAddUnique(array: JSON!, values: JSON!): JSON
  """ (live)"""
  arrayContains(array: JSON!, values: JSON!): Boolean
  """ (live)"""
  arrayContainsAll(array: JSON!, values: JSON!): Boolean
  """ (live)"""
  arrayContainsAllRegex(array: JSON!, values: JSON!): Boolean
  """ (live)"""
  arrayRemove(array: JSON!, values: JSON!): JSON
  """ (live)"""
  jsonObjectSetKey(json: JSON!, keyToSet: String!, valueToSet: String!): JSON
  """Reads a single `Endofshift` using its globally unique `ID`. (live)"""
  endofshift(
    """The globally unique `ID` to be used in selecting a single `Endofshift`."""
    nodeId: ID!
  ): Endofshift
  """Reads a single `_Schema` using its globally unique `ID`. (live)"""
  _schema(
    """The globally unique `ID` to be used in selecting a single `_Schema`."""
    nodeId: ID!
  ): _Schema
  """Reads a single `_PrismaMigration` using its globally unique `ID`. (live)"""
  _prismaMigration(
    """The globally unique `ID` to be used in selecting a single `_PrismaMigration`."""
    nodeId: ID!
  ): _PrismaMigration
  """Reads a single `Account` using its globally unique `ID`. (live)"""
  account(
    """The globally unique `ID` to be used in selecting a single `Account`."""
    nodeId: ID!
  ): Account
  """Reads a single `Agreement` using its globally unique `ID`. (live)"""
  agreement(
    """The globally unique `ID` to be used in selecting a single `Agreement`."""
    nodeId: ID!
  ): Agreement
  """Reads a single `Analytic` using its globally unique `ID`. (live)"""
  analytic(
    """The globally unique `ID` to be used in selecting a single `Analytic`."""
    nodeId: ID!
  ): Analytic
  """Reads a single `Apitoken` using its globally unique `ID`. (live)"""
  apitoken(
    """The globally unique `ID` to be used in selecting a single `Apitoken`."""
    nodeId: ID!
  ): Apitoken
  """Reads a single `Article` using its globally unique `ID`. (live)"""
  article(
    """The globally unique `ID` to be used in selecting a single `Article`."""
    nodeId: ID!
  ): Article
  """Reads a single `Brand` using its globally unique `ID`. (live)"""
  brand(
    """The globally unique `ID` to be used in selecting a single `Brand`."""
    nodeId: ID!
  ): Brand
  """Reads a single `CartPriceRule` using its globally unique `ID`. (live)"""
  cartPriceRule(
    """The globally unique `ID` to be used in selecting a single `CartPriceRule`."""
    nodeId: ID!
  ): CartPriceRule
  """Reads a single `Case` using its globally unique `ID`. (live)"""
  case(
    """The globally unique `ID` to be used in selecting a single `Case`."""
    nodeId: ID!
  ): Case
  """Reads a single `CatalogPriceRule` using its globally unique `ID`. (live)"""
  catalogPriceRule(
    """The globally unique `ID` to be used in selecting a single `CatalogPriceRule`."""
    nodeId: ID!
  ): CatalogPriceRule
  """Reads a single `Category` using its globally unique `ID`. (live)"""
  category(
    """The globally unique `ID` to be used in selecting a single `Category`."""
    nodeId: ID!
  ): Category
  """Reads a single `Channel` using its globally unique `ID`. (live)"""
  channel(
    """The globally unique `ID` to be used in selecting a single `Channel`."""
    nodeId: ID!
  ): Channel
  """Reads a single `Checklist` using its globally unique `ID`. (live)"""
  checklist(
    """The globally unique `ID` to be used in selecting a single `Checklist`."""
    nodeId: ID!
  ): Checklist
  """Reads a single `City` using its globally unique `ID`. (live)"""
  city(
    """The globally unique `ID` to be used in selecting a single `City`."""
    nodeId: ID!
  ): City
  """Reads a single `Collection` using its globally unique `ID`. (live)"""
  collection(
    """The globally unique `ID` to be used in selecting a single `Collection`."""
    nodeId: ID!
  ): Collection
  """Reads a single `Comment` using its globally unique `ID`. (live)"""
  comment(
    """The globally unique `ID` to be used in selecting a single `Comment`."""
    nodeId: ID!
  ): Comment
  """Reads a single `ContentType` using its globally unique `ID`. (live)"""
  contentType(
    """The globally unique `ID` to be used in selecting a single `ContentType`."""
    nodeId: ID!
  ): ContentType
  """Reads a single `Contract` using its globally unique `ID`. (live)"""
  contract(
    """The globally unique `ID` to be used in selecting a single `Contract`."""
    nodeId: ID!
  ): Contract
  """Reads a single `Country` using its globally unique `ID`. (live)"""
  country(
    """The globally unique `ID` to be used in selecting a single `Country`."""
    nodeId: ID!
  ): Country
  """Reads a single `Coupon` using its globally unique `ID`. (live)"""
  coupon(
    """The globally unique `ID` to be used in selecting a single `Coupon`."""
    nodeId: ID!
  ): Coupon
  """Reads a single `CreditMemo` using its globally unique `ID`. (live)"""
  creditMemo(
    """The globally unique `ID` to be used in selecting a single `CreditMemo`."""
    nodeId: ID!
  ): CreditMemo
  """Reads a single `Currency` using its globally unique `ID`. (live)"""
  currency(
    """The globally unique `ID` to be used in selecting a single `Currency`."""
    nodeId: ID!
  ): Currency
  """Reads a single `CurrencyRate` using its globally unique `ID`. (live)"""
  currencyRate(
    """The globally unique `ID` to be used in selecting a single `CurrencyRate`."""
    nodeId: ID!
  ): CurrencyRate
  """Reads a single `CurrencySymbol` using its globally unique `ID`. (live)"""
  currencySymbol(
    """The globally unique `ID` to be used in selecting a single `CurrencySymbol`."""
    nodeId: ID!
  ): CurrencySymbol
  """Reads a single `CustomerGroup` using its globally unique `ID`. (live)"""
  customerGroup(
    """The globally unique `ID` to be used in selecting a single `CustomerGroup`."""
    nodeId: ID!
  ): CustomerGroup
  """Reads a single `CustomerPayment` using its globally unique `ID`. (live)"""
  customerPayment(
    """The globally unique `ID` to be used in selecting a single `CustomerPayment`."""
    nodeId: ID!
  ): CustomerPayment
  """Reads a single `Customer` using its globally unique `ID`. (live)"""
  customer(
    """The globally unique `ID` to be used in selecting a single `Customer`."""
    nodeId: ID!
  ): Customer
  """Reads a single `Customization` using its globally unique `ID`. (live)"""
  customization(
    """The globally unique `ID` to be used in selecting a single `Customization`."""
    nodeId: ID!
  ): Customization
  """Reads a single `Dashboard` using its globally unique `ID`. (live)"""
  dashboard(
    """The globally unique `ID` to be used in selecting a single `Dashboard`."""
    nodeId: ID!
  ): Dashboard
  """Reads a single `Deepdive` using its globally unique `ID`. (live)"""
  deepdive(
    """The globally unique `ID` to be used in selecting a single `Deepdive`."""
    nodeId: ID!
  ): Deepdive
  """Reads a single `EmailTemplate` using its globally unique `ID`. (live)"""
  emailTemplate(
    """The globally unique `ID` to be used in selecting a single `EmailTemplate`."""
    nodeId: ID!
  ): EmailTemplate
  """Reads a single `Email` using its globally unique `ID`. (live)"""
  email(
    """The globally unique `ID` to be used in selecting a single `Email`."""
    nodeId: ID!
  ): Email
  """Reads a single `Event` using its globally unique `ID`. (live)"""
  event(
    """The globally unique `ID` to be used in selecting a single `Event`."""
    nodeId: ID!
  ): Event
  """Reads a single `Fullfillment` using its globally unique `ID`. (live)"""
  fullfillment(
    """The globally unique `ID` to be used in selecting a single `Fullfillment`."""
    nodeId: ID!
  ): Fullfillment
  """Reads a single `GeneralSetting` using its globally unique `ID`. (live)"""
  generalSetting(
    """The globally unique `ID` to be used in selecting a single `GeneralSetting`."""
    nodeId: ID!
  ): GeneralSetting
  """Reads a single `GiftCertificate` using its globally unique `ID`. (live)"""
  giftCertificate(
    """The globally unique `ID` to be used in selecting a single `GiftCertificate`."""
    nodeId: ID!
  ): GiftCertificate
  """Reads a single `Glossary` using its globally unique `ID`. (live)"""
  glossary(
    """The globally unique `ID` to be used in selecting a single `Glossary`."""
    nodeId: ID!
  ): Glossary
  """Reads a single `Importm` using its globally unique `ID`. (live)"""
  importm(
    """The globally unique `ID` to be used in selecting a single `Importm`."""
    nodeId: ID!
  ): Importm
  """Reads a single `Integration` using its globally unique `ID`. (live)"""
  integration(
    """The globally unique `ID` to be used in selecting a single `Integration`."""
    nodeId: ID!
  ): Integration
  """Reads a single `Internalization` using its globally unique `ID`. (live)"""
  internalization(
    """The globally unique `ID` to be used in selecting a single `Internalization`."""
    nodeId: ID!
  ): Internalization
  """Reads a single `Invitation` using its globally unique `ID`. (live)"""
  invitation(
    """The globally unique `ID` to be used in selecting a single `Invitation`."""
    nodeId: ID!
  ): Invitation
  """Reads a single `Invoice` using its globally unique `ID`. (live)"""
  invoice(
    """The globally unique `ID` to be used in selecting a single `Invoice`."""
    nodeId: ID!
  ): Invoice
  """Reads a single `Knowledgebase` using its globally unique `ID`. (live)"""
  knowledgebase(
    """The globally unique `ID` to be used in selecting a single `Knowledgebase`."""
    nodeId: ID!
  ): Knowledgebase
  """Reads a single `Lead` using its globally unique `ID`. (live)"""
  lead(
    """The globally unique `ID` to be used in selecting a single `Lead`."""
    nodeId: ID!
  ): Lead
  """Reads a single `Manufacturer` using its globally unique `ID`. (live)"""
  manufacturer(
    """The globally unique `ID` to be used in selecting a single `Manufacturer`."""
    nodeId: ID!
  ): Manufacturer
  """Reads a single `Mediamanager` using its globally unique `ID`. (live)"""
  mediamanager(
    """The globally unique `ID` to be used in selecting a single `Mediamanager`."""
    nodeId: ID!
  ): Mediamanager
  """Reads a single `Meeting` using its globally unique `ID`. (live)"""
  meeting(
    """The globally unique `ID` to be used in selecting a single `Meeting`."""
    nodeId: ID!
  ): Meeting
  """Reads a single `Message` using its globally unique `ID`. (live)"""
  message(
    """The globally unique `ID` to be used in selecting a single `Message`."""
    nodeId: ID!
  ): Message
  """Reads a single `NewsletterSubscriber` using its globally unique `ID`. (live)"""
  newsletterSubscriber(
    """The globally unique `ID` to be used in selecting a single `NewsletterSubscriber`."""
    nodeId: ID!
  ): NewsletterSubscriber
  """Reads a single `Occassion` using its globally unique `ID`. (live)"""
  occassion(
    """The globally unique `ID` to be used in selecting a single `Occassion`."""
    nodeId: ID!
  ): Occassion
  """Reads a single `Ooto` using its globally unique `ID`. (live)"""
  ooto(
    """The globally unique `ID` to be used in selecting a single `Ooto`."""
    nodeId: ID!
  ): Ooto
  """Reads a single `Opportunity` using its globally unique `ID`. (live)"""
  opportunity(
    """The globally unique `ID` to be used in selecting a single `Opportunity`."""
    nodeId: ID!
  ): Opportunity
  """Reads a single `Order` using its globally unique `ID`. (live)"""
  order(
    """The globally unique `ID` to be used in selecting a single `Order`."""
    nodeId: ID!
  ): Order
  """Reads a single `Page` using its globally unique `ID`. (live)"""
  page(
    """The globally unique `ID` to be used in selecting a single `Page`."""
    nodeId: ID!
  ): Page
  """Reads a single `Partner` using its globally unique `ID`. (live)"""
  partner(
    """The globally unique `ID` to be used in selecting a single `Partner`."""
    nodeId: ID!
  ): Partner
  """Reads a single `Payment` using its globally unique `ID`. (live)"""
  payment(
    """The globally unique `ID` to be used in selecting a single `Payment`."""
    nodeId: ID!
  ): Payment
  """Reads a single `PdfTemplate` using its globally unique `ID`. (live)"""
  pdfTemplate(
    """The globally unique `ID` to be used in selecting a single `PdfTemplate`."""
    nodeId: ID!
  ): PdfTemplate
  """Reads a single `Permission` using its globally unique `ID`. (live)"""
  permission(
    """The globally unique `ID` to be used in selecting a single `Permission`."""
    nodeId: ID!
  ): Permission
  """Reads a single `Plugin` using its globally unique `ID`. (live)"""
  plugin(
    """The globally unique `ID` to be used in selecting a single `Plugin`."""
    nodeId: ID!
  ): Plugin
  """Reads a single `ProductAttribute` using its globally unique `ID`. (live)"""
  productAttribute(
    """The globally unique `ID` to be used in selecting a single `ProductAttribute`."""
    nodeId: ID!
  ): ProductAttribute
  """Reads a single `ProductType` using its globally unique `ID`. (live)"""
  productType(
    """The globally unique `ID` to be used in selecting a single `ProductType`."""
    nodeId: ID!
  ): ProductType
  """Reads a single `Product` using its globally unique `ID`. (live)"""
  product(
    """The globally unique `ID` to be used in selecting a single `Product`."""
    nodeId: ID!
  ): Product
  """Reads a single `ProjectTemplate` using its globally unique `ID`. (live)"""
  projectTemplate(
    """The globally unique `ID` to be used in selecting a single `ProjectTemplate`."""
    nodeId: ID!
  ): ProjectTemplate
  """Reads a single `Project` using its globally unique `ID`. (live)"""
  project(
    """The globally unique `ID` to be used in selecting a single `Project`."""
    nodeId: ID!
  ): Project
  """Reads a single `Provider` using its globally unique `ID`. (live)"""
  provider(
    """The globally unique `ID` to be used in selecting a single `Provider`."""
    nodeId: ID!
  ): Provider
  """Reads a single `Quote` using its globally unique `ID`. (live)"""
  quote(
    """The globally unique `ID` to be used in selecting a single `Quote`."""
    nodeId: ID!
  ): Quote
  """Reads a single `Rating` using its globally unique `ID`. (live)"""
  rating(
    """The globally unique `ID` to be used in selecting a single `Rating`."""
    nodeId: ID!
  ): Rating
  """Reads a single `Report` using its globally unique `ID`. (live)"""
  report(
    """The globally unique `ID` to be used in selecting a single `Report`."""
    nodeId: ID!
  ): Report
  """Reads a single `Return` using its globally unique `ID`. (live)"""
  return(
    """The globally unique `ID` to be used in selecting a single `Return`."""
    nodeId: ID!
  ): Return
  """Reads a single `Review` using its globally unique `ID`. (live)"""
  review(
    """The globally unique `ID` to be used in selecting a single `Review`."""
    nodeId: ID!
  ): Review
  """Reads a single `Reward` using its globally unique `ID`. (live)"""
  reward(
    """The globally unique `ID` to be used in selecting a single `Reward`."""
    nodeId: ID!
  ): Reward
  """Reads a single `Scheduler` using its globally unique `ID`. (live)"""
  scheduler(
    """The globally unique `ID` to be used in selecting a single `Scheduler`."""
    nodeId: ID!
  ): Scheduler
  """Reads a single `Segment` using its globally unique `ID`. (live)"""
  segment(
    """The globally unique `ID` to be used in selecting a single `Segment`."""
    nodeId: ID!
  ): Segment
  """Reads a single `Settingscustomer` using its globally unique `ID`. (live)"""
  settingscustomer(
    """The globally unique `ID` to be used in selecting a single `Settingscustomer`."""
    nodeId: ID!
  ): Settingscustomer
  """Reads a single `Settingsgeneral` using its globally unique `ID`. (live)"""
  settingsgeneral(
    """The globally unique `ID` to be used in selecting a single `Settingsgeneral`."""
    nodeId: ID!
  ): Settingsgeneral
  """Reads a single `Settingshop` using its globally unique `ID`. (live)"""
  settingshop(
    """The globally unique `ID` to be used in selecting a single `Settingshop`."""
    nodeId: ID!
  ): Settingshop
  """Reads a single `Settingsmarketing` using its globally unique `ID`. (live)"""
  settingsmarketing(
    """The globally unique `ID` to be used in selecting a single `Settingsmarketing`."""
    nodeId: ID!
  ): Settingsmarketing
  """Reads a single `Settingssale` using its globally unique `ID`. (live)"""
  settingssale(
    """The globally unique `ID` to be used in selecting a single `Settingssale`."""
    nodeId: ID!
  ): Settingssale
  """Reads a single `Shipment` using its globally unique `ID`. (live)"""
  shipment(
    """The globally unique `ID` to be used in selecting a single `Shipment`."""
    nodeId: ID!
  ): Shipment
  """Reads a single `ShopSetting` using its globally unique `ID`. (live)"""
  shopSetting(
    """The globally unique `ID` to be used in selecting a single `ShopSetting`."""
    nodeId: ID!
  ): ShopSetting
  """Reads a single `Shop` using its globally unique `ID`. (live)"""
  shop(
    """The globally unique `ID` to be used in selecting a single `Shop`."""
    nodeId: ID!
  ): Shop
  """Reads a single `SpecialDiscount` using its globally unique `ID`. (live)"""
  specialDiscount(
    """The globally unique `ID` to be used in selecting a single `SpecialDiscount`."""
    nodeId: ID!
  ): SpecialDiscount
  """Reads a single `State` using its globally unique `ID`. (live)"""
  state(
    """The globally unique `ID` to be used in selecting a single `State`."""
    nodeId: ID!
  ): State
  """Reads a single `Statistic` using its globally unique `ID`. (live)"""
  statistic(
    """The globally unique `ID` to be used in selecting a single `Statistic`."""
    nodeId: ID!
  ): Statistic
  """Reads a single `Stock` using its globally unique `ID`. (live)"""
  stock(
    """The globally unique `ID` to be used in selecting a single `Stock`."""
    nodeId: ID!
  ): Stock
  """Reads a single `Survey` using its globally unique `ID`. (live)"""
  survey(
    """The globally unique `ID` to be used in selecting a single `Survey`."""
    nodeId: ID!
  ): Survey
  """Reads a single `Tag` using its globally unique `ID`. (live)"""
  tag(
    """The globally unique `ID` to be used in selecting a single `Tag`."""
    nodeId: ID!
  ): Tag
  """Reads a single `Target` using its globally unique `ID`. (live)"""
  target(
    """The globally unique `ID` to be used in selecting a single `Target`."""
    nodeId: ID!
  ): Target
  """Reads a single `TaxCategory` using its globally unique `ID`. (live)"""
  taxCategory(
    """The globally unique `ID` to be used in selecting a single `TaxCategory`."""
    nodeId: ID!
  ): TaxCategory
  """Reads a single `TaxRate` using its globally unique `ID`. (live)"""
  taxRate(
    """The globally unique `ID` to be used in selecting a single `TaxRate`."""
    nodeId: ID!
  ): TaxRate
  """Reads a single `TaxRule` using its globally unique `ID`. (live)"""
  taxRule(
    """The globally unique `ID` to be used in selecting a single `TaxRule`."""
    nodeId: ID!
  ): TaxRule
  """Reads a single `Theme` using its globally unique `ID`. (live)"""
  theme(
    """The globally unique `ID` to be used in selecting a single `Theme`."""
    nodeId: ID!
  ): Theme
  """Reads a single `Ticketing` using its globally unique `ID`. (live)"""
  ticketing(
    """The globally unique `ID` to be used in selecting a single `Ticketing`."""
    nodeId: ID!
  ): Ticketing
  """Reads a single `TodoList` using its globally unique `ID`. (live)"""
  todoList(
    """The globally unique `ID` to be used in selecting a single `TodoList`."""
    nodeId: ID!
  ): TodoList
  """Reads a single `Training` using its globally unique `ID`. (live)"""
  training(
    """The globally unique `ID` to be used in selecting a single `Training`."""
    nodeId: ID!
  ): Training
  """Reads a single `Transaction` using its globally unique `ID`. (live)"""
  transaction(
    """The globally unique `ID` to be used in selecting a single `Transaction`."""
    nodeId: ID!
  ): Transaction
  """Reads a single `UrlRewrite` using its globally unique `ID`. (live)"""
  urlRewrite(
    """The globally unique `ID` to be used in selecting a single `UrlRewrite`."""
    nodeId: ID!
  ): UrlRewrite
  """Reads a single `UserRole` using its globally unique `ID`. (live)"""
  userRole(
    """The globally unique `ID` to be used in selecting a single `UserRole`."""
    nodeId: ID!
  ): UserRole
  """Reads a single `User` using its globally unique `ID`. (live)"""
  user(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User
  """Reads a single `Visit` using its globally unique `ID`. (live)"""
  visit(
    """The globally unique `ID` to be used in selecting a single `Visit`."""
    nodeId: ID!
  ): Visit
  """Reads a single `Warehouse` using its globally unique `ID`. (live)"""
  warehouse(
    """The globally unique `ID` to be used in selecting a single `Warehouse`."""
    nodeId: ID!
  ): Warehouse
  """Reads a single `Webhook` using its globally unique `ID`. (live)"""
  webhook(
    """The globally unique `ID` to be used in selecting a single `Webhook`."""
    nodeId: ID!
  ): Webhook
  """Reads a single `Website` using its globally unique `ID`. (live)"""
  website(
    """The globally unique `ID` to be used in selecting a single `Website`."""
    nodeId: ID!
  ): Website
  """Reads a single `Wishlist` using its globally unique `ID`. (live)"""
  wishlist(
    """The globally unique `ID` to be used in selecting a single `Wishlist`."""
    nodeId: ID!
  ): Wishlist
  """Reads a single `Workspace` using its globally unique `ID`. (live)"""
  workspace(
    """The globally unique `ID` to be used in selecting a single `Workspace`."""
    nodeId: ID!
  ): Workspace
  """Reads a single `Zone` using its globally unique `ID`. (live)"""
  zone(
    """The globally unique `ID` to be used in selecting a single `Zone`."""
    nodeId: ID!
  ): Zone
  """
  Fetches a list of entities using their representations; used for Apollo
  Federation. (live)
  """
  _entities(representations: [_Any!]!): [_Entity]! @deprecated(reason: "Only Apollo Federation should use this")
  """
  Entrypoint for Apollo Federation to determine more information about
  this service. (live)
  """
  _service: _Service! @deprecated(reason: "Only Apollo Federation should use this")
}

"""
Used to represent a set of fields. Grammatically, a field set is a
selection set minus the braces.
"""
scalar _FieldSet
