"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `_PrismaMigration`."""
  _prismaMigrations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: _PrismaMigrationCondition
  ): _PrismaMigrationsConnection

  """Reads and enables pagination through a set of `Agreement`."""
  agreements(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AgreementCondition
  ): AgreementsConnection

  """Reads and enables pagination through a set of `Apitoken`."""
  apitokens(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ApitokenCondition
  ): ApitokensConnection

  """Reads and enables pagination through a set of `Article`."""
  articles(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ArticleCondition
  ): ArticlesConnection

  """Reads and enables pagination through a set of `Attribute`."""
  attributes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Attribute`."""
    orderBy: [AttributesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AttributeCondition
  ): AttributesConnection

  """Reads and enables pagination through a set of `Brand`."""
  brands(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BrandCondition
  ): BrandsConnection

  """Reads and enables pagination through a set of `Category`."""
  categories(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CategoryCondition
  ): CategoriesConnection

  """Reads and enables pagination through a set of `Channel`."""
  channels(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ChannelCondition
  ): ChannelsConnection

  """Reads and enables pagination through a set of `Checklist`."""
  checklists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ChecklistCondition
  ): ChecklistsConnection

  """Reads and enables pagination through a set of `City`."""
  cities(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CityCondition
  ): CitiesConnection

  """Reads and enables pagination through a set of `Collection`."""
  collections(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CollectionCondition
  ): CollectionsConnection

  """Reads and enables pagination through a set of `ContentType`."""
  contentTypes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContentTypeCondition
  ): ContentTypesConnection

  """Reads and enables pagination through a set of `Country`."""
  countries(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryCondition
  ): CountriesConnection

  """Reads and enables pagination through a set of `Currency`."""
  currencies(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CurrencyCondition
  ): CurrenciesConnection

  """Reads and enables pagination through a set of `Customer`."""
  customers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomerCondition
  ): CustomersConnection

  """Reads and enables pagination through a set of `Dashboard`."""
  dashboards(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DashboardCondition
  ): DashboardsConnection

  """Reads and enables pagination through a set of `Deepdive`."""
  deepdives(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DeepdiveCondition
  ): DeepdivesConnection

  """Reads and enables pagination through a set of `Discount`."""
  discounts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Discount`."""
    orderBy: [DiscountsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DiscountCondition
  ): DiscountsConnection

  """Reads and enables pagination through a set of `Endofshift`."""
  endofshifts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EndofshiftCondition
  ): EndofshiftsConnection

  """Reads and enables pagination through a set of `Event`."""
  events(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EventCondition
  ): EventsConnection

  """Reads and enables pagination through a set of `Fullfillment`."""
  fullfillments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FullfillmentCondition
  ): FullfillmentsConnection

  """Reads and enables pagination through a set of `Glossary`."""
  glossaries(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GlossaryCondition
  ): GlossariesConnection

  """Reads and enables pagination through a set of `Integration`."""
  integrations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: IntegrationCondition
  ): IntegrationsConnection

  """Reads and enables pagination through a set of `Internalization`."""
  internalizations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InternalizationCondition
  ): InternalizationsConnection

  """Reads and enables pagination through a set of `Invoice`."""
  invoices(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvoiceCondition
  ): InvoicesConnection

  """Reads and enables pagination through a set of `LogIn`."""
  logIns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `LogIn`."""
    orderBy: [LogInsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LogInCondition
  ): LogInsConnection

  """Reads and enables pagination through a set of `Manufacturer`."""
  manufacturers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ManufacturerCondition
  ): ManufacturersConnection

  """Reads and enables pagination through a set of `Mediamanager`."""
  mediamanagers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MediamanagerCondition
  ): MediamanagersConnection

  """Reads and enables pagination through a set of `Newsletter`."""
  newsletters(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Newsletter`."""
    orderBy: [NewslettersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NewsletterCondition
  ): NewslettersConnection

  """Reads and enables pagination through a set of `Ooto`."""
  ootos(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OotoCondition
  ): OotosConnection

  """Reads and enables pagination through a set of `Order`."""
  orders(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrderCondition
  ): OrdersConnection

  """Reads and enables pagination through a set of `Page`."""
  pages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PageCondition
  ): PagesConnection

  """Reads and enables pagination through a set of `Partner`."""
  partners(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerCondition
  ): PartnersConnection

  """Reads and enables pagination through a set of `Payment`."""
  payments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentCondition
  ): PaymentsConnection

  """Reads and enables pagination through a set of `Permission`."""
  permissions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PermissionCondition
  ): PermissionsConnection

  """Reads and enables pagination through a set of `Plugin`."""
  plugins(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PluginCondition
  ): PluginsConnection

  """Reads and enables pagination through a set of `ProductType`."""
  productTypes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductTypeCondition
  ): ProductTypesConnection

  """Reads and enables pagination through a set of `Product`."""
  products(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProductCondition
  ): ProductsConnection

  """Reads and enables pagination through a set of `Project`."""
  projects(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition
  ): ProjectsConnection

  """Reads and enables pagination through a set of `Provider`."""
  providers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProviderCondition
  ): ProvidersConnection

  """Reads and enables pagination through a set of `Quote`."""
  quotes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: QuoteCondition
  ): QuotesConnection

  """Reads and enables pagination through a set of `Return`."""
  returns(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReturnCondition
  ): ReturnsConnection

  """Reads and enables pagination through a set of `Review`."""
  reviews(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReviewCondition
  ): ReviewsConnection

  """Reads and enables pagination through a set of `Reward`."""
  rewards(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RewardCondition
  ): RewardsConnection

  """Reads and enables pagination through a set of `Role`."""
  roles(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Role`."""
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RoleCondition
  ): RolesConnection

  """Reads and enables pagination through a set of `Scheduler`."""
  schedulers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SchedulerCondition
  ): SchedulersConnection

  """Reads and enables pagination through a set of `Segment`."""
  segments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SegmentCondition
  ): SegmentsConnection

  """Reads and enables pagination through a set of `Setting`."""
  settings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Setting`."""
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SettingCondition
  ): SettingsConnection

  """Reads and enables pagination through a set of `Shipment`."""
  shipments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ShipmentCondition
  ): ShipmentsConnection

  """Reads and enables pagination through a set of `State`."""
  states(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StateCondition
  ): StatesConnection

  """Reads and enables pagination through a set of `Tag`."""
  tags(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagCondition
  ): TagsConnection

  """Reads and enables pagination through a set of `Tax`."""
  taxes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Tax`."""
    orderBy: [TaxesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaxCondition
  ): TaxesConnection

  """Reads and enables pagination through a set of `Theme`."""
  themes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ThemeCondition
  ): ThemesConnection

  """Reads and enables pagination through a set of `Ticketing`."""
  ticketings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TicketingCondition
  ): TicketingsConnection

  """Reads and enables pagination through a set of `Transaction`."""
  transactions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TransactionCondition
  ): TransactionsConnection

  """Reads and enables pagination through a set of `UploadFile`."""
  uploadFiles(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `UploadFile`."""
    orderBy: [UploadFilesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UploadFileCondition
  ): UploadFilesConnection

  """Reads and enables pagination through a set of `User`."""
  users(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition
  ): UsersConnection

  """Reads and enables pagination through a set of `Vendor`."""
  vendors(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Vendor`."""
    orderBy: [VendorsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VendorCondition
  ): VendorsConnection

  """Reads and enables pagination through a set of `Visit`."""
  visits(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VisitCondition
  ): VisitsConnection

  """Reads and enables pagination through a set of `Warehouse`."""
  warehouses(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WarehouseCondition
  ): WarehousesConnection

  """Reads and enables pagination through a set of `Webhook`."""
  webhooks(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WebhookCondition
  ): WebhooksConnection

  """Reads and enables pagination through a set of `Website`."""
  websites(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WebsiteCondition
  ): WebsitesConnection

  """Reads and enables pagination through a set of `Wishlist`."""
  wishlists(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WishlistCondition
  ): WishlistsConnection

  """Reads and enables pagination through a set of `Workspace`."""
  workspaces(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorkspaceCondition
  ): WorkspacesConnection

  """Reads and enables pagination through a set of `Zone`."""
  zones(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ZoneCondition
  ): ZonesConnection
  _prismaMigration(id: String!): _PrismaMigration
  agreement(id: BigInt!): Agreement
  apitoken(id: BigInt!): Apitoken
  article(id: Int!): Article
  attribute(id: Int!): Attribute
  brand(id: BigInt!): Brand
  category(id: Int!): Category
  channel(id: BigInt!): Channel
  checklist(id: BigInt!): Checklist
  city(id: Int!): City
  collection(id: BigInt!): Collection
  contentType(id: BigInt!): ContentType
  country(id: Int!): Country
  currency(id: BigInt!): Currency
  customer(id: Int!): Customer
  dashboard(id: BigInt!): Dashboard
  dashboardByName(name: String!): Dashboard
  deepdive(id: BigInt!): Deepdive
  discount(id: BigInt!): Discount
  endofshift(id: BigInt!): Endofshift
  event(id: BigInt!): Event
  fullfillment(id: BigInt!): Fullfillment
  glossary(id: Int!): Glossary
  integration(id: BigInt!): Integration
  internalization(id: BigInt!): Internalization
  invoice(id: BigInt!): Invoice
  logIn(id: BigInt!): LogIn
  manufacturer(id: BigInt!): Manufacturer
  mediamanager(id: Int!): Mediamanager
  newsletter(id: Int!): Newsletter
  ooto(id: BigInt!): Ooto
  order(id: Int!): Order
  page(id: Int!): Page
  partner(id: BigInt!): Partner
  payment(id: BigInt!): Payment
  permission(id: BigInt!): Permission
  plugin(id: BigInt!): Plugin
  productType(id: Int!): ProductType
  product(id: BigInt!): Product
  project(id: BigInt!): Project
  provider(id: BigInt!): Provider
  quote(id: Int!): Quote
  return(id: BigInt!): Return
  review(id: Int!): Review
  reward(id: Int!): Reward
  role(id: Int!): Role
  scheduler(id: BigInt!): Scheduler
  segment(id: BigInt!): Segment
  setting(id: BigInt!): Setting
  shipment(id: BigInt!): Shipment
  state(id: Int!): State
  tag(id: Int!): Tag
  tax(id: Int!): Tax
  theme(id: Int!): Theme
  ticketing(id: BigInt!): Ticketing
  transaction(id: Int!): Transaction
  uploadFile(id: Int!): UploadFile
  user(id: BigInt!): User
  vendor(id: Int!): Vendor
  visit(id: BigInt!): Visit
  warehouse(id: BigInt!): Warehouse
  webhook(id: BigInt!): Webhook
  website(id: BigInt!): Website
  wishlist(id: BigInt!): Wishlist
  workspace(id: BigInt!): Workspace
  zone(id: BigInt!): Zone

  """Reads a single `_PrismaMigration` using its globally unique `ID`."""
  _prismaMigrationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `_PrismaMigration`.
    """
    nodeId: ID!
  ): _PrismaMigration

  """Reads a single `Agreement` using its globally unique `ID`."""
  agreementByNodeId(
    """The globally unique `ID` to be used in selecting a single `Agreement`."""
    nodeId: ID!
  ): Agreement

  """Reads a single `Apitoken` using its globally unique `ID`."""
  apitokenByNodeId(
    """The globally unique `ID` to be used in selecting a single `Apitoken`."""
    nodeId: ID!
  ): Apitoken

  """Reads a single `Article` using its globally unique `ID`."""
  articleByNodeId(
    """The globally unique `ID` to be used in selecting a single `Article`."""
    nodeId: ID!
  ): Article

  """Reads a single `Attribute` using its globally unique `ID`."""
  attributeByNodeId(
    """The globally unique `ID` to be used in selecting a single `Attribute`."""
    nodeId: ID!
  ): Attribute

  """Reads a single `Brand` using its globally unique `ID`."""
  brandByNodeId(
    """The globally unique `ID` to be used in selecting a single `Brand`."""
    nodeId: ID!
  ): Brand

  """Reads a single `Category` using its globally unique `ID`."""
  categoryByNodeId(
    """The globally unique `ID` to be used in selecting a single `Category`."""
    nodeId: ID!
  ): Category

  """Reads a single `Channel` using its globally unique `ID`."""
  channelByNodeId(
    """The globally unique `ID` to be used in selecting a single `Channel`."""
    nodeId: ID!
  ): Channel

  """Reads a single `Checklist` using its globally unique `ID`."""
  checklistByNodeId(
    """The globally unique `ID` to be used in selecting a single `Checklist`."""
    nodeId: ID!
  ): Checklist

  """Reads a single `City` using its globally unique `ID`."""
  cityByNodeId(
    """The globally unique `ID` to be used in selecting a single `City`."""
    nodeId: ID!
  ): City

  """Reads a single `Collection` using its globally unique `ID`."""
  collectionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Collection`.
    """
    nodeId: ID!
  ): Collection

  """Reads a single `ContentType` using its globally unique `ID`."""
  contentTypeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ContentType`.
    """
    nodeId: ID!
  ): ContentType

  """Reads a single `Country` using its globally unique `ID`."""
  countryByNodeId(
    """The globally unique `ID` to be used in selecting a single `Country`."""
    nodeId: ID!
  ): Country

  """Reads a single `Currency` using its globally unique `ID`."""
  currencyByNodeId(
    """The globally unique `ID` to be used in selecting a single `Currency`."""
    nodeId: ID!
  ): Currency

  """Reads a single `Customer` using its globally unique `ID`."""
  customerByNodeId(
    """The globally unique `ID` to be used in selecting a single `Customer`."""
    nodeId: ID!
  ): Customer

  """Reads a single `Dashboard` using its globally unique `ID`."""
  dashboardByNodeId(
    """The globally unique `ID` to be used in selecting a single `Dashboard`."""
    nodeId: ID!
  ): Dashboard

  """Reads a single `Deepdive` using its globally unique `ID`."""
  deepdiveByNodeId(
    """The globally unique `ID` to be used in selecting a single `Deepdive`."""
    nodeId: ID!
  ): Deepdive

  """Reads a single `Discount` using its globally unique `ID`."""
  discountByNodeId(
    """The globally unique `ID` to be used in selecting a single `Discount`."""
    nodeId: ID!
  ): Discount

  """Reads a single `Endofshift` using its globally unique `ID`."""
  endofshiftByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Endofshift`.
    """
    nodeId: ID!
  ): Endofshift

  """Reads a single `Event` using its globally unique `ID`."""
  eventByNodeId(
    """The globally unique `ID` to be used in selecting a single `Event`."""
    nodeId: ID!
  ): Event

  """Reads a single `Fullfillment` using its globally unique `ID`."""
  fullfillmentByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Fullfillment`.
    """
    nodeId: ID!
  ): Fullfillment

  """Reads a single `Glossary` using its globally unique `ID`."""
  glossaryByNodeId(
    """The globally unique `ID` to be used in selecting a single `Glossary`."""
    nodeId: ID!
  ): Glossary

  """Reads a single `Integration` using its globally unique `ID`."""
  integrationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Integration`.
    """
    nodeId: ID!
  ): Integration

  """Reads a single `Internalization` using its globally unique `ID`."""
  internalizationByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Internalization`.
    """
    nodeId: ID!
  ): Internalization

  """Reads a single `Invoice` using its globally unique `ID`."""
  invoiceByNodeId(
    """The globally unique `ID` to be used in selecting a single `Invoice`."""
    nodeId: ID!
  ): Invoice

  """Reads a single `LogIn` using its globally unique `ID`."""
  logInByNodeId(
    """The globally unique `ID` to be used in selecting a single `LogIn`."""
    nodeId: ID!
  ): LogIn

  """Reads a single `Manufacturer` using its globally unique `ID`."""
  manufacturerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Manufacturer`.
    """
    nodeId: ID!
  ): Manufacturer

  """Reads a single `Mediamanager` using its globally unique `ID`."""
  mediamanagerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Mediamanager`.
    """
    nodeId: ID!
  ): Mediamanager

  """Reads a single `Newsletter` using its globally unique `ID`."""
  newsletterByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Newsletter`.
    """
    nodeId: ID!
  ): Newsletter

  """Reads a single `Ooto` using its globally unique `ID`."""
  ootoByNodeId(
    """The globally unique `ID` to be used in selecting a single `Ooto`."""
    nodeId: ID!
  ): Ooto

  """Reads a single `Order` using its globally unique `ID`."""
  orderByNodeId(
    """The globally unique `ID` to be used in selecting a single `Order`."""
    nodeId: ID!
  ): Order

  """Reads a single `Page` using its globally unique `ID`."""
  pageByNodeId(
    """The globally unique `ID` to be used in selecting a single `Page`."""
    nodeId: ID!
  ): Page

  """Reads a single `Partner` using its globally unique `ID`."""
  partnerByNodeId(
    """The globally unique `ID` to be used in selecting a single `Partner`."""
    nodeId: ID!
  ): Partner

  """Reads a single `Payment` using its globally unique `ID`."""
  paymentByNodeId(
    """The globally unique `ID` to be used in selecting a single `Payment`."""
    nodeId: ID!
  ): Payment

  """Reads a single `Permission` using its globally unique `ID`."""
  permissionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Permission`.
    """
    nodeId: ID!
  ): Permission

  """Reads a single `Plugin` using its globally unique `ID`."""
  pluginByNodeId(
    """The globally unique `ID` to be used in selecting a single `Plugin`."""
    nodeId: ID!
  ): Plugin

  """Reads a single `ProductType` using its globally unique `ID`."""
  productTypeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ProductType`.
    """
    nodeId: ID!
  ): ProductType

  """Reads a single `Product` using its globally unique `ID`."""
  productByNodeId(
    """The globally unique `ID` to be used in selecting a single `Product`."""
    nodeId: ID!
  ): Product

  """Reads a single `Project` using its globally unique `ID`."""
  projectByNodeId(
    """The globally unique `ID` to be used in selecting a single `Project`."""
    nodeId: ID!
  ): Project

  """Reads a single `Provider` using its globally unique `ID`."""
  providerByNodeId(
    """The globally unique `ID` to be used in selecting a single `Provider`."""
    nodeId: ID!
  ): Provider

  """Reads a single `Quote` using its globally unique `ID`."""
  quoteByNodeId(
    """The globally unique `ID` to be used in selecting a single `Quote`."""
    nodeId: ID!
  ): Quote

  """Reads a single `Return` using its globally unique `ID`."""
  returnByNodeId(
    """The globally unique `ID` to be used in selecting a single `Return`."""
    nodeId: ID!
  ): Return

  """Reads a single `Review` using its globally unique `ID`."""
  reviewByNodeId(
    """The globally unique `ID` to be used in selecting a single `Review`."""
    nodeId: ID!
  ): Review

  """Reads a single `Reward` using its globally unique `ID`."""
  rewardByNodeId(
    """The globally unique `ID` to be used in selecting a single `Reward`."""
    nodeId: ID!
  ): Reward

  """Reads a single `Role` using its globally unique `ID`."""
  roleByNodeId(
    """The globally unique `ID` to be used in selecting a single `Role`."""
    nodeId: ID!
  ): Role

  """Reads a single `Scheduler` using its globally unique `ID`."""
  schedulerByNodeId(
    """The globally unique `ID` to be used in selecting a single `Scheduler`."""
    nodeId: ID!
  ): Scheduler

  """Reads a single `Segment` using its globally unique `ID`."""
  segmentByNodeId(
    """The globally unique `ID` to be used in selecting a single `Segment`."""
    nodeId: ID!
  ): Segment

  """Reads a single `Setting` using its globally unique `ID`."""
  settingByNodeId(
    """The globally unique `ID` to be used in selecting a single `Setting`."""
    nodeId: ID!
  ): Setting

  """Reads a single `Shipment` using its globally unique `ID`."""
  shipmentByNodeId(
    """The globally unique `ID` to be used in selecting a single `Shipment`."""
    nodeId: ID!
  ): Shipment

  """Reads a single `State` using its globally unique `ID`."""
  stateByNodeId(
    """The globally unique `ID` to be used in selecting a single `State`."""
    nodeId: ID!
  ): State

  """Reads a single `Tag` using its globally unique `ID`."""
  tagByNodeId(
    """The globally unique `ID` to be used in selecting a single `Tag`."""
    nodeId: ID!
  ): Tag

  """Reads a single `Tax` using its globally unique `ID`."""
  taxByNodeId(
    """The globally unique `ID` to be used in selecting a single `Tax`."""
    nodeId: ID!
  ): Tax

  """Reads a single `Theme` using its globally unique `ID`."""
  themeByNodeId(
    """The globally unique `ID` to be used in selecting a single `Theme`."""
    nodeId: ID!
  ): Theme

  """Reads a single `Ticketing` using its globally unique `ID`."""
  ticketingByNodeId(
    """The globally unique `ID` to be used in selecting a single `Ticketing`."""
    nodeId: ID!
  ): Ticketing

  """Reads a single `Transaction` using its globally unique `ID`."""
  transactionByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Transaction`.
    """
    nodeId: ID!
  ): Transaction

  """Reads a single `UploadFile` using its globally unique `ID`."""
  uploadFileByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `UploadFile`.
    """
    nodeId: ID!
  ): UploadFile

  """Reads a single `User` using its globally unique `ID`."""
  userByNodeId(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User

  """Reads a single `Vendor` using its globally unique `ID`."""
  vendorByNodeId(
    """The globally unique `ID` to be used in selecting a single `Vendor`."""
    nodeId: ID!
  ): Vendor

  """Reads a single `Visit` using its globally unique `ID`."""
  visitByNodeId(
    """The globally unique `ID` to be used in selecting a single `Visit`."""
    nodeId: ID!
  ): Visit

  """Reads a single `Warehouse` using its globally unique `ID`."""
  warehouseByNodeId(
    """The globally unique `ID` to be used in selecting a single `Warehouse`."""
    nodeId: ID!
  ): Warehouse

  """Reads a single `Webhook` using its globally unique `ID`."""
  webhookByNodeId(
    """The globally unique `ID` to be used in selecting a single `Webhook`."""
    nodeId: ID!
  ): Webhook

  """Reads a single `Website` using its globally unique `ID`."""
  websiteByNodeId(
    """The globally unique `ID` to be used in selecting a single `Website`."""
    nodeId: ID!
  ): Website

  """Reads a single `Wishlist` using its globally unique `ID`."""
  wishlistByNodeId(
    """The globally unique `ID` to be used in selecting a single `Wishlist`."""
    nodeId: ID!
  ): Wishlist

  """Reads a single `Workspace` using its globally unique `ID`."""
  workspaceByNodeId(
    """The globally unique `ID` to be used in selecting a single `Workspace`."""
    nodeId: ID!
  ): Workspace

  """Reads a single `Zone` using its globally unique `ID`."""
  zoneByNodeId(
    """The globally unique `ID` to be used in selecting a single `Zone`."""
    nodeId: ID!
  ): Zone
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `_PrismaMigration` values."""
type _PrismaMigrationsConnection {
  """A list of `_PrismaMigration` objects."""
  nodes: [_PrismaMigration!]!

  """
  A list of edges which contains the `_PrismaMigration` and cursor to aid in pagination.
  """
  edges: [_PrismaMigrationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `_PrismaMigration` you could get from the connection.
  """
  totalCount: Int!
}

type _PrismaMigration implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: String!
  checksum: String!
  finishedAt: Datetime
  migrationName: String!
  logs: String
  rolledBackAt: Datetime
  startedAt: Datetime!
  appliedStepsCount: Int!
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""A `_PrismaMigration` edge in the connection."""
type _PrismaMigrationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `_PrismaMigration` at the end of the edge."""
  node: _PrismaMigration!
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `_PrismaMigration`."""
enum _PrismaMigrationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CHECKSUM_ASC
  CHECKSUM_DESC
  FINISHED_AT_ASC
  FINISHED_AT_DESC
  MIGRATION_NAME_ASC
  MIGRATION_NAME_DESC
  LOGS_ASC
  LOGS_DESC
  ROLLED_BACK_AT_ASC
  ROLLED_BACK_AT_DESC
  STARTED_AT_ASC
  STARTED_AT_DESC
  APPLIED_STEPS_COUNT_ASC
  APPLIED_STEPS_COUNT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `_PrismaMigration` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input _PrismaMigrationCondition {
  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `checksum` field."""
  checksum: String

  """Checks for equality with the object’s `finishedAt` field."""
  finishedAt: Datetime

  """Checks for equality with the object’s `migrationName` field."""
  migrationName: String

  """Checks for equality with the object’s `logs` field."""
  logs: String

  """Checks for equality with the object’s `rolledBackAt` field."""
  rolledBackAt: Datetime

  """Checks for equality with the object’s `startedAt` field."""
  startedAt: Datetime

  """Checks for equality with the object’s `appliedStepsCount` field."""
  appliedStepsCount: Int
}

"""A connection to a list of `Agreement` values."""
type AgreementsConnection {
  """A list of `Agreement` objects."""
  nodes: [Agreement!]!

  """
  A list of edges which contains the `Agreement` and cursor to aid in pagination.
  """
  edges: [AgreementsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Agreement` you could get from the connection."""
  totalCount: Int!
}

type Agreement implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  referenceId: String
  created: Datetime
  updated: Datetime
  content: String
  name: String
  image: String
  excerpt: String
  type: String
  userId: String
  shopId: String
  mediamanager: String
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""A `Agreement` edge in the connection."""
type AgreementsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Agreement` at the end of the edge."""
  node: Agreement!
}

"""Methods to use when ordering `Agreement`."""
enum AgreementsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  REFERENCE_ID_ASC
  REFERENCE_ID_DESC
  CREATED_ASC
  CREATED_DESC
  UPDATED_ASC
  UPDATED_DESC
  CONTENT_ASC
  CONTENT_DESC
  NAME_ASC
  NAME_DESC
  IMAGE_ASC
  IMAGE_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  TYPE_ASC
  TYPE_DESC
  USER_ID_ASC
  USER_ID_DESC
  SHOP_ID_ASC
  SHOP_ID_DESC
  MEDIAMANAGER_ASC
  MEDIAMANAGER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Agreement` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AgreementCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `referenceId` field."""
  referenceId: String

  """Checks for equality with the object’s `created` field."""
  created: Datetime

  """Checks for equality with the object’s `updated` field."""
  updated: Datetime

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `excerpt` field."""
  excerpt: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `userId` field."""
  userId: String

  """Checks for equality with the object’s `shopId` field."""
  shopId: String

  """Checks for equality with the object’s `mediamanager` field."""
  mediamanager: String
}

"""A connection to a list of `Apitoken` values."""
type ApitokensConnection {
  """A list of `Apitoken` objects."""
  nodes: [Apitoken!]!

  """
  A list of edges which contains the `Apitoken` and cursor to aid in pagination.
  """
  edges: [ApitokensEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Apitoken` you could get from the connection."""
  totalCount: Int!
}

type Apitoken implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String!
  tokenType: String
  description: String
  token: BigInt!
}

"""A `Apitoken` edge in the connection."""
type ApitokensEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Apitoken` at the end of the edge."""
  node: Apitoken!
}

"""Methods to use when ordering `Apitoken`."""
enum ApitokensOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  TOKEN_TYPE_ASC
  TOKEN_TYPE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  TOKEN_ASC
  TOKEN_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Apitoken` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ApitokenCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `tokenType` field."""
  tokenType: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `token` field."""
  token: BigInt
}

"""A connection to a list of `Article` values."""
type ArticlesConnection {
  """A list of `Article` objects."""
  nodes: [Article!]!

  """
  A list of edges which contains the `Article` and cursor to aid in pagination.
  """
  edges: [ArticlesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Article` you could get from the connection."""
  totalCount: Int!
}

type Article implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String
  excerpt: String
  content: String
  image: String
  categories: String
  customers: String
  users: String
  published: String
  custId: String
  isPublic: String
  metaDescription: String
  metaName: String
  metaUrl: String
  tags: String
  type: String
}

"""A `Article` edge in the connection."""
type ArticlesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Article` at the end of the edge."""
  node: Article!
}

"""Methods to use when ordering `Article`."""
enum ArticlesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  CONTENT_ASC
  CONTENT_DESC
  IMAGE_ASC
  IMAGE_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  META_NAME_ASC
  META_NAME_DESC
  META_URL_ASC
  META_URL_DESC
  TAGS_ASC
  TAGS_DESC
  TYPE_ASC
  TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Article` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ArticleCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `excerpt` field."""
  excerpt: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `categories` field."""
  categories: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `users` field."""
  users: String

  """Checks for equality with the object’s `published` field."""
  published: String

  """Checks for equality with the object’s `custId` field."""
  custId: String

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: String

  """Checks for equality with the object’s `metaDescription` field."""
  metaDescription: String

  """Checks for equality with the object’s `metaName` field."""
  metaName: String

  """Checks for equality with the object’s `metaUrl` field."""
  metaUrl: String

  """Checks for equality with the object’s `tags` field."""
  tags: String

  """Checks for equality with the object’s `type` field."""
  type: String
}

"""A connection to a list of `Attribute` values."""
type AttributesConnection {
  """A list of `Attribute` objects."""
  nodes: [Attribute!]!

  """
  A list of edges which contains the `Attribute` and cursor to aid in pagination.
  """
  edges: [AttributesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Attribute` you could get from the connection."""
  totalCount: Int!
}

type Attribute implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  defaultLabel: String
  attributeCode: String
  filterOptions: String
  useSearch: String
  layeredNavigation: Boolean
  searchResultsLayeredNavigation: Boolean
  position: String
  promoRuleConditions: Boolean
  allowHtmlTagsStorefront: Boolean
  visibleCatalogPagesStorefront: Boolean
  usedProductListing: Boolean
  usedSortingProductListing: Boolean
  prodId: BigInt!
  attributeClass: String
  attributeValue: String
  columnOptions: String
  facetedNavigation: Boolean
  isPublic: String
  metaDescription: String
  metaName: Boolean
  metaUrl: String
  productAttributeSet: String
  products: String
}

"""A `Attribute` edge in the connection."""
type AttributesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Attribute` at the end of the edge."""
  node: Attribute!
}

"""Methods to use when ordering `Attribute`."""
enum AttributesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  DEFAULT_LABEL_ASC
  DEFAULT_LABEL_DESC
  ATTRIBUTE_CODE_ASC
  ATTRIBUTE_CODE_DESC
  FILTER_OPTIONS_ASC
  FILTER_OPTIONS_DESC
  USE_SEARCH_ASC
  USE_SEARCH_DESC
  LAYERED_NAVIGATION_ASC
  LAYERED_NAVIGATION_DESC
  SEARCH_RESULTS_LAYERED_NAVIGATION_ASC
  SEARCH_RESULTS_LAYERED_NAVIGATION_DESC
  POSITION_ASC
  POSITION_DESC
  PROMO_RULE_CONDITIONS_ASC
  PROMO_RULE_CONDITIONS_DESC
  ALLOW_HTML_TAGS_STOREFRONT_ASC
  ALLOW_HTML_TAGS_STOREFRONT_DESC
  VISIBLE_CATALOG_PAGES_STOREFRONT_ASC
  VISIBLE_CATALOG_PAGES_STOREFRONT_DESC
  USED_PRODUCT_LISTING_ASC
  USED_PRODUCT_LISTING_DESC
  USED_SORTING_PRODUCT_LISTING_ASC
  USED_SORTING_PRODUCT_LISTING_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  ATTRIBUTE_CLASS_ASC
  ATTRIBUTE_CLASS_DESC
  ATTRIBUTE_VALUE_ASC
  ATTRIBUTE_VALUE_DESC
  COLUMN_OPTIONS_ASC
  COLUMN_OPTIONS_DESC
  FACETED_NAVIGATION_ASC
  FACETED_NAVIGATION_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  META_NAME_ASC
  META_NAME_DESC
  META_URL_ASC
  META_URL_DESC
  PRODUCT_ATTRIBUTE_SET_ASC
  PRODUCT_ATTRIBUTE_SET_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Attribute` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AttributeCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `defaultLabel` field."""
  defaultLabel: String

  """Checks for equality with the object’s `attributeCode` field."""
  attributeCode: String

  """Checks for equality with the object’s `filterOptions` field."""
  filterOptions: String

  """Checks for equality with the object’s `useSearch` field."""
  useSearch: String

  """Checks for equality with the object’s `layeredNavigation` field."""
  layeredNavigation: Boolean

  """
  Checks for equality with the object’s `searchResultsLayeredNavigation` field.
  """
  searchResultsLayeredNavigation: Boolean

  """Checks for equality with the object’s `position` field."""
  position: String

  """Checks for equality with the object’s `promoRuleConditions` field."""
  promoRuleConditions: Boolean

  """Checks for equality with the object’s `allowHtmlTagsStorefront` field."""
  allowHtmlTagsStorefront: Boolean

  """
  Checks for equality with the object’s `visibleCatalogPagesStorefront` field.
  """
  visibleCatalogPagesStorefront: Boolean

  """Checks for equality with the object’s `usedProductListing` field."""
  usedProductListing: Boolean

  """
  Checks for equality with the object’s `usedSortingProductListing` field.
  """
  usedSortingProductListing: Boolean

  """Checks for equality with the object’s `prodId` field."""
  prodId: BigInt

  """Checks for equality with the object’s `attributeClass` field."""
  attributeClass: String

  """Checks for equality with the object’s `attributeValue` field."""
  attributeValue: String

  """Checks for equality with the object’s `columnOptions` field."""
  columnOptions: String

  """Checks for equality with the object’s `facetedNavigation` field."""
  facetedNavigation: Boolean

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: String

  """Checks for equality with the object’s `metaDescription` field."""
  metaDescription: String

  """Checks for equality with the object’s `metaName` field."""
  metaName: Boolean

  """Checks for equality with the object’s `metaUrl` field."""
  metaUrl: String

  """Checks for equality with the object’s `productAttributeSet` field."""
  productAttributeSet: String

  """Checks for equality with the object’s `products` field."""
  products: String
}

"""A connection to a list of `Brand` values."""
type BrandsConnection {
  """A list of `Brand` objects."""
  nodes: [Brand!]!

  """
  A list of edges which contains the `Brand` and cursor to aid in pagination.
  """
  edges: [BrandsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Brand` you could get from the connection."""
  totalCount: Int!
}

type Brand implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
  mediamanager: String
  products: String
  workspaces: String
}

"""A `Brand` edge in the connection."""
type BrandsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Brand` at the end of the edge."""
  node: Brand!
}

"""Methods to use when ordering `Brand`."""
enum BrandsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  STATE_ASC
  STATE_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  CITY_ASC
  CITY_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  MEDIA_ASC
  MEDIA_DESC
  MEDIAMANAGER_ASC
  MEDIAMANAGER_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  WORKSPACES_ASC
  WORKSPACES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Brand` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input BrandCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: String

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `product` field."""
  product: BigInt

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """Checks for equality with the object’s `mediamanager` field."""
  mediamanager: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `workspaces` field."""
  workspaces: String
}

"""A connection to a list of `Category` values."""
type CategoriesConnection {
  """A list of `Category` objects."""
  nodes: [Category!]!

  """
  A list of edges which contains the `Category` and cursor to aid in pagination.
  """
  edges: [CategoriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Category` you could get from the connection."""
  totalCount: Int!
}

type Category implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  thumbnail: String
  name: String!
  visibility: String
  status: Boolean
  websites: String
  product: String
  country: String
  description: String
  content: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  workspaces: String
}

"""A `Category` edge in the connection."""
type CategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Category` at the end of the edge."""
  node: Category!
}

"""Methods to use when ordering `Category`."""
enum CategoriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  THUMBNAIL_ASC
  THUMBNAIL_DESC
  NAME_ASC
  NAME_DESC
  VISIBILITY_ASC
  VISIBILITY_DESC
  STATUS_ASC
  STATUS_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CONTENT_ASC
  CONTENT_DESC
  IMAGE_ASC
  IMAGE_DESC
  META_TITLE_ASC
  META_TITLE_DESC
  META_KEYWORDS_ASC
  META_KEYWORDS_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  META_URL_ASC
  META_URL_DESC
  WORKSPACES_ASC
  WORKSPACES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Category` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CategoryCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `thumbnail` field."""
  thumbnail: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `visibility` field."""
  visibility: String

  """Checks for equality with the object’s `status` field."""
  status: Boolean

  """Checks for equality with the object’s `websites` field."""
  websites: String

  """Checks for equality with the object’s `product` field."""
  product: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `metaTitle` field."""
  metaTitle: String

  """Checks for equality with the object’s `metaKeywords` field."""
  metaKeywords: String

  """Checks for equality with the object’s `metaDescription` field."""
  metaDescription: String

  """Checks for equality with the object’s `metaUrl` field."""
  metaUrl: String

  """Checks for equality with the object’s `workspaces` field."""
  workspaces: String
}

"""A connection to a list of `Channel` values."""
type ChannelsConnection {
  """A list of `Channel` objects."""
  nodes: [Channel!]!

  """
  A list of edges which contains the `Channel` and cursor to aid in pagination.
  """
  edges: [ChannelsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Channel` you could get from the connection."""
  totalCount: Int!
}

type Channel implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  currency: String
  defaultLang: String
  includeTax: String
  defaultZone: String
  defaultShipping: String
  clientId: String
  clientSecret: String
}

"""A `Channel` edge in the connection."""
type ChannelsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Channel` at the end of the edge."""
  node: Channel!
}

"""Methods to use when ordering `Channel`."""
enum ChannelsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  CURRENCY_ASC
  CURRENCY_DESC
  DEFAULT_LANG_ASC
  DEFAULT_LANG_DESC
  INCLUDE_TAX_ASC
  INCLUDE_TAX_DESC
  DEFAULT_ZONE_ASC
  DEFAULT_ZONE_DESC
  DEFAULT_SHIPPING_ASC
  DEFAULT_SHIPPING_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Channel` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ChannelCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `currency` field."""
  currency: String

  """Checks for equality with the object’s `defaultLang` field."""
  defaultLang: String

  """Checks for equality with the object’s `includeTax` field."""
  includeTax: String

  """Checks for equality with the object’s `defaultZone` field."""
  defaultZone: String

  """Checks for equality with the object’s `defaultShipping` field."""
  defaultShipping: String

  """Checks for equality with the object’s `clientId` field."""
  clientId: String

  """Checks for equality with the object’s `clientSecret` field."""
  clientSecret: String
}

"""A connection to a list of `Checklist` values."""
type ChecklistsConnection {
  """A list of `Checklist` objects."""
  nodes: [Checklist!]!

  """
  A list of edges which contains the `Checklist` and cursor to aid in pagination.
  """
  edges: [ChecklistsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Checklist` you could get from the connection."""
  totalCount: Int!
}

type Checklist implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  username: String
  location: String
  regionalManager: String
  manager: String
  description: String
  ticket: String
  project: String
  region: String
  country: String
  media: String
  prodId: String
  trainings: String
  task: String
  type: String
}

"""A `Checklist` edge in the connection."""
type ChecklistsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Checklist` at the end of the edge."""
  node: Checklist!
}

"""Methods to use when ordering `Checklist`."""
enum ChecklistsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  USERNAME_ASC
  USERNAME_DESC
  LOCATION_ASC
  LOCATION_DESC
  REGIONAL_MANAGER_ASC
  REGIONAL_MANAGER_DESC
  MANAGER_ASC
  MANAGER_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  TICKET_ASC
  TICKET_DESC
  PROJECT_ASC
  PROJECT_DESC
  REGION_ASC
  REGION_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  MEDIA_ASC
  MEDIA_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  TRAININGS_ASC
  TRAININGS_DESC
  TASK_ASC
  TASK_DESC
  TYPE_ASC
  TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Checklist` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ChecklistCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `username` field."""
  username: String

  """Checks for equality with the object’s `location` field."""
  location: String

  """Checks for equality with the object’s `regionalManager` field."""
  regionalManager: String

  """Checks for equality with the object’s `manager` field."""
  manager: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `ticket` field."""
  ticket: String

  """Checks for equality with the object’s `project` field."""
  project: String

  """Checks for equality with the object’s `region` field."""
  region: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """Checks for equality with the object’s `prodId` field."""
  prodId: String

  """Checks for equality with the object’s `trainings` field."""
  trainings: String

  """Checks for equality with the object’s `task` field."""
  task: String

  """Checks for equality with the object’s `type` field."""
  type: String
}

"""A connection to a list of `City` values."""
type CitiesConnection {
  """A list of `City` objects."""
  nodes: [City!]!

  """
  A list of edges which contains the `City` and cursor to aid in pagination.
  """
  edges: [CitiesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `City` you could get from the connection."""
  totalCount: Int!
}

type City implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  description: String
  state: String
  country: String
  postalCode: String
  image: String
}

"""A `City` edge in the connection."""
type CitiesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `City` at the end of the edge."""
  node: City!
}

"""Methods to use when ordering `City`."""
enum CitiesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  POSTAL_CODE_ASC
  POSTAL_CODE_DESC
  IMAGE_ASC
  IMAGE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `City` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CityCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `postalCode` field."""
  postalCode: String

  """Checks for equality with the object’s `image` field."""
  image: String
}

"""A connection to a list of `Collection` values."""
type CollectionsConnection {
  """A list of `Collection` objects."""
  nodes: [Collection!]!

  """
  A list of edges which contains the `Collection` and cursor to aid in pagination.
  """
  edges: [CollectionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Collection` you could get from the connection."""
  totalCount: Int!
}

type Collection implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  description: String
  image: String
  product: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
}

"""A `Collection` edge in the connection."""
type CollectionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Collection` at the end of the edge."""
  node: Collection!
}

"""Methods to use when ordering `Collection`."""
enum CollectionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  META_TITLE_ASC
  META_TITLE_DESC
  META_KEYWORDS_ASC
  META_KEYWORDS_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Collection` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CollectionCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `product` field."""
  product: String

  """Checks for equality with the object’s `metaTitle` field."""
  metaTitle: String

  """Checks for equality with the object’s `metaKeywords` field."""
  metaKeywords: String

  """Checks for equality with the object’s `metaDescription` field."""
  metaDescription: String
}

"""A connection to a list of `ContentType` values."""
type ContentTypesConnection {
  """A list of `ContentType` objects."""
  nodes: [ContentType!]!

  """
  A list of edges which contains the `ContentType` and cursor to aid in pagination.
  """
  edges: [ContentTypesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ContentType` you could get from the connection."""
  totalCount: Int!
}

type ContentType implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  text: String
  number: BigFloat
  json: JSON
  link: String
  email: String
  uid: String
  date: Date
  time: Time
  timestamp: Datetime
  boolean: Boolean
  richText: String
  password: String
  media: String
  databaseName: String
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""The day, does not include a time."""
scalar Date

"""
The exact time of day, does not include the date. May or may not have a timezone offset.
"""
scalar Time

"""A `ContentType` edge in the connection."""
type ContentTypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ContentType` at the end of the edge."""
  node: ContentType!
}

"""Methods to use when ordering `ContentType`."""
enum ContentTypesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  TEXT_ASC
  TEXT_DESC
  NUMBER_ASC
  NUMBER_DESC
  JSON_ASC
  JSON_DESC
  LINK_ASC
  LINK_DESC
  EMAIL_ASC
  EMAIL_DESC
  UID_ASC
  UID_DESC
  DATE_ASC
  DATE_DESC
  TIME_ASC
  TIME_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  BOOLEAN_ASC
  BOOLEAN_DESC
  RICH_TEXT_ASC
  RICH_TEXT_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  MEDIA_ASC
  MEDIA_DESC
  DATABASE_NAME_ASC
  DATABASE_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ContentType` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ContentTypeCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `text` field."""
  text: String

  """Checks for equality with the object’s `number` field."""
  number: BigFloat

  """Checks for equality with the object’s `json` field."""
  json: JSON

  """Checks for equality with the object’s `link` field."""
  link: String

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `uid` field."""
  uid: String

  """Checks for equality with the object’s `date` field."""
  date: Date

  """Checks for equality with the object’s `time` field."""
  time: Time

  """Checks for equality with the object’s `timestamp` field."""
  timestamp: Datetime

  """Checks for equality with the object’s `boolean` field."""
  boolean: Boolean

  """Checks for equality with the object’s `richText` field."""
  richText: String

  """Checks for equality with the object’s `password` field."""
  password: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """Checks for equality with the object’s `databaseName` field."""
  databaseName: String
}

"""A connection to a list of `Country` values."""
type CountriesConnection {
  """A list of `Country` objects."""
  nodes: [Country!]!

  """
  A list of edges which contains the `Country` and cursor to aid in pagination.
  """
  edges: [CountriesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Country` you could get from the connection."""
  totalCount: Int!
}

type Country implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  description: String
  image: String
  region: String
  trainings: String
}

"""A `Country` edge in the connection."""
type CountriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Country` at the end of the edge."""
  node: Country!
}

"""Methods to use when ordering `Country`."""
enum CountriesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  REGION_ASC
  REGION_DESC
  TRAININGS_ASC
  TRAININGS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CountryCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `region` field."""
  region: String

  """Checks for equality with the object’s `trainings` field."""
  trainings: String
}

"""A connection to a list of `Currency` values."""
type CurrenciesConnection {
  """A list of `Currency` objects."""
  nodes: [Currency!]!

  """
  A list of edges which contains the `Currency` and cursor to aid in pagination.
  """
  edges: [CurrenciesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Currency` you could get from the connection."""
  totalCount: Int!
}

type Currency implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  region: String
  symbol: String
  useStandard: String
}

"""A `Currency` edge in the connection."""
type CurrenciesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Currency` at the end of the edge."""
  node: Currency!
}

"""Methods to use when ordering `Currency`."""
enum CurrenciesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  REGION_ASC
  REGION_DESC
  SYMBOL_ASC
  SYMBOL_DESC
  USE_STANDARD_ASC
  USE_STANDARD_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Currency` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CurrencyCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `region` field."""
  region: String

  """Checks for equality with the object’s `symbol` field."""
  symbol: String

  """Checks for equality with the object’s `useStandard` field."""
  useStandard: String
}

"""A connection to a list of `Customer` values."""
type CustomersConnection {
  """A list of `Customer` objects."""
  nodes: [Customer!]!

  """
  A list of edges which contains the `Customer` and cursor to aid in pagination.
  """
  edges: [CustomersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Customer` you could get from the connection."""
  totalCount: Int!
}

type Customer implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  thumbnail: String
  namePrefix: String
  firstName: String!
  middleName: String
  lastName: String!
  email: String!
  customerGroup: String
  phone: String
  zipcode: String
  nameSuffix: String
  websites: String
  product: String
  country: String
  state: String
  customerSince: Datetime
  confirmedEmail: String
  dateOfBirth: String
  taxVatNumber: String
  gender: String
  description: String
  shortDescription: String
  image: String
  address: String
  addressTwo: String
  paymentType: String
  username: String
  password: String
  comments: String
  creditMemos: String
  customerPayment: String
  emails: String
  mediamanager: String
  messages: String
  newsletterSubscribers: String
  orders: String
  projects: String
  quotes: String
  returns: String
  workspaces: String
}

"""A `Customer` edge in the connection."""
type CustomersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Customer` at the end of the edge."""
  node: Customer!
}

"""Methods to use when ordering `Customer`."""
enum CustomersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  THUMBNAIL_ASC
  THUMBNAIL_DESC
  NAME_PREFIX_ASC
  NAME_PREFIX_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  MIDDLE_NAME_ASC
  MIDDLE_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  CUSTOMER_GROUP_ASC
  CUSTOMER_GROUP_DESC
  PHONE_ASC
  PHONE_DESC
  ZIPCODE_ASC
  ZIPCODE_DESC
  NAME_SUFFIX_ASC
  NAME_SUFFIX_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  STATE_ASC
  STATE_DESC
  CUSTOMER_SINCE_ASC
  CUSTOMER_SINCE_DESC
  CONFIRMED_EMAIL_ASC
  CONFIRMED_EMAIL_DESC
  DATE_OF_BIRTH_ASC
  DATE_OF_BIRTH_DESC
  TAX_VAT_NUMBER_ASC
  TAX_VAT_NUMBER_DESC
  GENDER_ASC
  GENDER_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  SHORT_DESCRIPTION_ASC
  SHORT_DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ADDRESS_TWO_ASC
  ADDRESS_TWO_DESC
  PAYMENT_TYPE_ASC
  PAYMENT_TYPE_DESC
  USERNAME_ASC
  USERNAME_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  COMMENTS_ASC
  COMMENTS_DESC
  CREDIT_MEMOS_ASC
  CREDIT_MEMOS_DESC
  CUSTOMER_PAYMENT_ASC
  CUSTOMER_PAYMENT_DESC
  EMAILS_ASC
  EMAILS_DESC
  MEDIAMANAGER_ASC
  MEDIAMANAGER_DESC
  MESSAGES_ASC
  MESSAGES_DESC
  NEWSLETTER_SUBSCRIBERS_ASC
  NEWSLETTER_SUBSCRIBERS_DESC
  ORDERS_ASC
  ORDERS_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  QUOTES_ASC
  QUOTES_DESC
  RETURNS_ASC
  RETURNS_DESC
  WORKSPACES_ASC
  WORKSPACES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Customer` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CustomerCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `thumbnail` field."""
  thumbnail: String

  """Checks for equality with the object’s `namePrefix` field."""
  namePrefix: String

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `middleName` field."""
  middleName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `customerGroup` field."""
  customerGroup: String

  """Checks for equality with the object’s `phone` field."""
  phone: String

  """Checks for equality with the object’s `zipcode` field."""
  zipcode: String

  """Checks for equality with the object’s `nameSuffix` field."""
  nameSuffix: String

  """Checks for equality with the object’s `websites` field."""
  websites: String

  """Checks for equality with the object’s `product` field."""
  product: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `customerSince` field."""
  customerSince: Datetime

  """Checks for equality with the object’s `confirmedEmail` field."""
  confirmedEmail: String

  """Checks for equality with the object’s `dateOfBirth` field."""
  dateOfBirth: String

  """Checks for equality with the object’s `taxVatNumber` field."""
  taxVatNumber: String

  """Checks for equality with the object’s `gender` field."""
  gender: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `shortDescription` field."""
  shortDescription: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `address` field."""
  address: String

  """Checks for equality with the object’s `addressTwo` field."""
  addressTwo: String

  """Checks for equality with the object’s `paymentType` field."""
  paymentType: String

  """Checks for equality with the object’s `username` field."""
  username: String

  """Checks for equality with the object’s `password` field."""
  password: String

  """Checks for equality with the object’s `comments` field."""
  comments: String

  """Checks for equality with the object’s `creditMemos` field."""
  creditMemos: String

  """Checks for equality with the object’s `customerPayment` field."""
  customerPayment: String

  """Checks for equality with the object’s `emails` field."""
  emails: String

  """Checks for equality with the object’s `mediamanager` field."""
  mediamanager: String

  """Checks for equality with the object’s `messages` field."""
  messages: String

  """Checks for equality with the object’s `newsletterSubscribers` field."""
  newsletterSubscribers: String

  """Checks for equality with the object’s `orders` field."""
  orders: String

  """Checks for equality with the object’s `projects` field."""
  projects: String

  """Checks for equality with the object’s `quotes` field."""
  quotes: String

  """Checks for equality with the object’s `returns` field."""
  returns: String

  """Checks for equality with the object’s `workspaces` field."""
  workspaces: String
}

"""A connection to a list of `Dashboard` values."""
type DashboardsConnection {
  """A list of `Dashboard` objects."""
  nodes: [Dashboard!]!

  """
  A list of edges which contains the `Dashboard` and cursor to aid in pagination.
  """
  edges: [DashboardsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Dashboard` you could get from the connection."""
  totalCount: Int!
}

type Dashboard implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  clientId: String
  clientSecret: String
  privacy: String
  category: String
  url: String
  media: String
  reports: String
  tasks: String
  projects: String
  tickets: String
  customers: String
  checklists: String
  visits: String
  users: String
  products: String
  articles: String
  sales: String
  logo: String
  content: String
  published: String
}

"""A `Dashboard` edge in the connection."""
type DashboardsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Dashboard` at the end of the edge."""
  node: Dashboard!
}

"""Methods to use when ordering `Dashboard`."""
enum DashboardsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  PRIVACY_ASC
  PRIVACY_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  URL_ASC
  URL_DESC
  MEDIA_ASC
  MEDIA_DESC
  REPORTS_ASC
  REPORTS_DESC
  TASKS_ASC
  TASKS_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  TICKETS_ASC
  TICKETS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  CHECKLISTS_ASC
  CHECKLISTS_DESC
  VISITS_ASC
  VISITS_DESC
  USERS_ASC
  USERS_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  SALES_ASC
  SALES_DESC
  LOGO_ASC
  LOGO_DESC
  CONTENT_ASC
  CONTENT_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Dashboard` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input DashboardCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `clientId` field."""
  clientId: String

  """Checks for equality with the object’s `clientSecret` field."""
  clientSecret: String

  """Checks for equality with the object’s `privacy` field."""
  privacy: String

  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """Checks for equality with the object’s `reports` field."""
  reports: String

  """Checks for equality with the object’s `tasks` field."""
  tasks: String

  """Checks for equality with the object’s `projects` field."""
  projects: String

  """Checks for equality with the object’s `tickets` field."""
  tickets: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `checklists` field."""
  checklists: String

  """Checks for equality with the object’s `visits` field."""
  visits: String

  """Checks for equality with the object’s `users` field."""
  users: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `articles` field."""
  articles: String

  """Checks for equality with the object’s `sales` field."""
  sales: String

  """Checks for equality with the object’s `logo` field."""
  logo: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `published` field."""
  published: String
}

"""A connection to a list of `Deepdive` values."""
type DeepdivesConnection {
  """A list of `Deepdive` objects."""
  nodes: [Deepdive!]!

  """
  A list of edges which contains the `Deepdive` and cursor to aid in pagination.
  """
  edges: [DeepdivesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Deepdive` you could get from the connection."""
  totalCount: Int!
}

type Deepdive implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  endDate: String
  content: String
  attendees: String
  login: String
  startDate: String
  whid: String
}

"""A `Deepdive` edge in the connection."""
type DeepdivesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Deepdive` at the end of the edge."""
  node: Deepdive!
}

"""Methods to use when ordering `Deepdive`."""
enum DeepdivesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  END_DATE_ASC
  END_DATE_DESC
  CONTENT_ASC
  CONTENT_DESC
  ATTENDEES_ASC
  ATTENDEES_DESC
  LOGIN_ASC
  LOGIN_DESC
  START_DATE_ASC
  START_DATE_DESC
  WHID_ASC
  WHID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Deepdive` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input DeepdiveCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `endDate` field."""
  endDate: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `attendees` field."""
  attendees: String

  """Checks for equality with the object’s `login` field."""
  login: String

  """Checks for equality with the object’s `startDate` field."""
  startDate: String

  """Checks for equality with the object’s `whid` field."""
  whid: String
}

"""A connection to a list of `Discount` values."""
type DiscountsConnection {
  """A list of `Discount` objects."""
  nodes: [Discount!]!

  """
  A list of edges which contains the `Discount` and cursor to aid in pagination.
  """
  edges: [DiscountsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Discount` you could get from the connection."""
  totalCount: Int!
}

type Discount implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  name: String!
  excerpt: String
  discount: String
  image: String
  published: Datetime
  specialOffers: String
  rewards: String
  coupons: String
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  type: String
  creditMemo: String
  billToName: String
  orderNumber: String
  refunded: String
  status: String
}

"""A `Discount` edge in the connection."""
type DiscountsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Discount` at the end of the edge."""
  node: Discount!
}

"""Methods to use when ordering `Discount`."""
enum DiscountsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  DISCOUNT_ASC
  DISCOUNT_DESC
  IMAGE_ASC
  IMAGE_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  SPECIAL_OFFERS_ASC
  SPECIAL_OFFERS_DESC
  REWARDS_ASC
  REWARDS_DESC
  COUPONS_ASC
  COUPONS_DESC
  EXPIRATION_ASC
  EXPIRATION_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  TYPE_ASC
  TYPE_DESC
  CREDIT_MEMO_ASC
  CREDIT_MEMO_DESC
  BILL_TO_NAME_ASC
  BILL_TO_NAME_DESC
  ORDER_NUMBER_ASC
  ORDER_NUMBER_DESC
  REFUNDED_ASC
  REFUNDED_DESC
  STATUS_ASC
  STATUS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Discount` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input DiscountCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `excerpt` field."""
  excerpt: String

  """Checks for equality with the object’s `discount` field."""
  discount: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `published` field."""
  published: Datetime

  """Checks for equality with the object’s `specialOffers` field."""
  specialOffers: String

  """Checks for equality with the object’s `rewards` field."""
  rewards: String

  """Checks for equality with the object’s `coupons` field."""
  coupons: String

  """Checks for equality with the object’s `expiration` field."""
  expiration: String

  """Checks for equality with the object’s `categories` field."""
  categories: String

  """Checks for equality with the object’s `articles` field."""
  articles: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `users` field."""
  users: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `creditMemo` field."""
  creditMemo: String

  """Checks for equality with the object’s `billToName` field."""
  billToName: String

  """Checks for equality with the object’s `orderNumber` field."""
  orderNumber: String

  """Checks for equality with the object’s `refunded` field."""
  refunded: String

  """Checks for equality with the object’s `status` field."""
  status: String
}

"""A connection to a list of `Endofshift` values."""
type EndofshiftsConnection {
  """A list of `Endofshift` objects."""
  nodes: [Endofshift!]!

  """
  A list of edges which contains the `Endofshift` and cursor to aid in pagination.
  """
  edges: [EndofshiftsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Endofshift` you could get from the connection."""
  totalCount: Int!
}

type Endofshift implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  content: String
  login: String
  mcms: String
  nextShift: String
  projects: String
  tickets: String
  whid: String
}

"""A `Endofshift` edge in the connection."""
type EndofshiftsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Endofshift` at the end of the edge."""
  node: Endofshift!
}

"""Methods to use when ordering `Endofshift`."""
enum EndofshiftsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CONTENT_ASC
  CONTENT_DESC
  LOGIN_ASC
  LOGIN_DESC
  MCMS_ASC
  MCMS_DESC
  NEXT_SHIFT_ASC
  NEXT_SHIFT_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  TICKETS_ASC
  TICKETS_DESC
  WHID_ASC
  WHID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Endofshift` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input EndofshiftCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `login` field."""
  login: String

  """Checks for equality with the object’s `mcms` field."""
  mcms: String

  """Checks for equality with the object’s `nextShift` field."""
  nextShift: String

  """Checks for equality with the object’s `projects` field."""
  projects: String

  """Checks for equality with the object’s `tickets` field."""
  tickets: String

  """Checks for equality with the object’s `whid` field."""
  whid: String
}

"""A connection to a list of `Event` values."""
type EventsConnection {
  """A list of `Event` objects."""
  nodes: [Event!]!

  """
  A list of edges which contains the `Event` and cursor to aid in pagination.
  """
  edges: [EventsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Event` you could get from the connection."""
  totalCount: Int!
}

type Event implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  content: String
  tickets: String
  image: String
  start: String
  end: String
  category: String
  city: String
  state: String
  country: String
  postalcode: String
  type: String
  invitationEmail: String
  invitationBillingAddress: String
  invitationGrandTotalPurchased: String
  invitationInvoiceDate: String
  invitationOrderNumber: String
  invitationPaymentMethod: String
  invitationShippingAddress: String
  invitationCustomerName: String
  invitationStatus: String
  media: String
}

"""A `Event` edge in the connection."""
type EventsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Event` at the end of the edge."""
  node: Event!
}

"""Methods to use when ordering `Event`."""
enum EventsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  TICKETS_ASC
  TICKETS_DESC
  IMAGE_ASC
  IMAGE_DESC
  START_ASC
  START_DESC
  END_ASC
  END_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  POSTALCODE_ASC
  POSTALCODE_DESC
  TYPE_ASC
  TYPE_DESC
  INVITATION_EMAIL_ASC
  INVITATION_EMAIL_DESC
  INVITATION_BILLING_ADDRESS_ASC
  INVITATION_BILLING_ADDRESS_DESC
  INVITATION_GRAND_TOTAL_PURCHASED_ASC
  INVITATION_GRAND_TOTAL_PURCHASED_DESC
  INVITATION_INVOICE_DATE_ASC
  INVITATION_INVOICE_DATE_DESC
  INVITATION_ORDER_NUMBER_ASC
  INVITATION_ORDER_NUMBER_DESC
  INVITATION_PAYMENT_METHOD_ASC
  INVITATION_PAYMENT_METHOD_DESC
  INVITATION_SHIPPING_ADDRESS_ASC
  INVITATION_SHIPPING_ADDRESS_DESC
  INVITATION_CUSTOMER_NAME_ASC
  INVITATION_CUSTOMER_NAME_DESC
  INVITATION_STATUS_ASC
  INVITATION_STATUS_DESC
  MEDIA_ASC
  MEDIA_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Event` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input EventCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `tickets` field."""
  tickets: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `start` field."""
  start: String

  """Checks for equality with the object’s `end` field."""
  end: String

  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `postalcode` field."""
  postalcode: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `invitationEmail` field."""
  invitationEmail: String

  """
  Checks for equality with the object’s `invitationBillingAddress` field.
  """
  invitationBillingAddress: String

  """
  Checks for equality with the object’s `invitationGrandTotalPurchased` field.
  """
  invitationGrandTotalPurchased: String

  """Checks for equality with the object’s `invitationInvoiceDate` field."""
  invitationInvoiceDate: String

  """Checks for equality with the object’s `invitationOrderNumber` field."""
  invitationOrderNumber: String

  """Checks for equality with the object’s `invitationPaymentMethod` field."""
  invitationPaymentMethod: String

  """
  Checks for equality with the object’s `invitationShippingAddress` field.
  """
  invitationShippingAddress: String

  """Checks for equality with the object’s `invitationCustomerName` field."""
  invitationCustomerName: String

  """Checks for equality with the object’s `invitationStatus` field."""
  invitationStatus: String

  """Checks for equality with the object’s `media` field."""
  media: String
}

"""A connection to a list of `Fullfillment` values."""
type FullfillmentsConnection {
  """A list of `Fullfillment` objects."""
  nodes: [Fullfillment!]!

  """
  A list of edges which contains the `Fullfillment` and cursor to aid in pagination.
  """
  edges: [FullfillmentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Fullfillment` you could get from the connection."""
  totalCount: Int!
}

type Fullfillment implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  shippingZones: String
  company: String
  address: String
  addressTwo: String
  city: String
  state: String
  zipcode: String
  country: String
  countryArea: String
  phone: String
  pickup: String
  stock: String
}

"""A `Fullfillment` edge in the connection."""
type FullfillmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Fullfillment` at the end of the edge."""
  node: Fullfillment!
}

"""Methods to use when ordering `Fullfillment`."""
enum FullfillmentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  SHIPPING_ZONES_ASC
  SHIPPING_ZONES_DESC
  COMPANY_ASC
  COMPANY_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ADDRESS_TWO_ASC
  ADDRESS_TWO_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  ZIPCODE_ASC
  ZIPCODE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  COUNTRY_AREA_ASC
  COUNTRY_AREA_DESC
  PHONE_ASC
  PHONE_DESC
  PICKUP_ASC
  PICKUP_DESC
  STOCK_ASC
  STOCK_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Fullfillment` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input FullfillmentCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `shippingZones` field."""
  shippingZones: String

  """Checks for equality with the object’s `company` field."""
  company: String

  """Checks for equality with the object’s `address` field."""
  address: String

  """Checks for equality with the object’s `addressTwo` field."""
  addressTwo: String

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `zipcode` field."""
  zipcode: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `countryArea` field."""
  countryArea: String

  """Checks for equality with the object’s `phone` field."""
  phone: String

  """Checks for equality with the object’s `pickup` field."""
  pickup: String

  """Checks for equality with the object’s `stock` field."""
  stock: String
}

"""A connection to a list of `Glossary` values."""
type GlossariesConnection {
  """A list of `Glossary` objects."""
  nodes: [Glossary!]!

  """
  A list of edges which contains the `Glossary` and cursor to aid in pagination.
  """
  edges: [GlossariesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Glossary` you could get from the connection."""
  totalCount: Int!
}

type Glossary implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  content: String
  image: String
  published: Datetime
}

"""A `Glossary` edge in the connection."""
type GlossariesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Glossary` at the end of the edge."""
  node: Glossary!
}

"""Methods to use when ordering `Glossary`."""
enum GlossariesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  IMAGE_ASC
  IMAGE_DESC
  PUBLISHED_ASC
  PUBLISHED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Glossary` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input GlossaryCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `published` field."""
  published: Datetime
}

"""A connection to a list of `Integration` values."""
type IntegrationsConnection {
  """A list of `Integration` objects."""
  nodes: [Integration!]!

  """
  A list of edges which contains the `Integration` and cursor to aid in pagination.
  """
  edges: [IntegrationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Integration` you could get from the connection."""
  totalCount: Int!
}

type Integration implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  content: String
  media: String
  location: String
  category: String
}

"""A `Integration` edge in the connection."""
type IntegrationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Integration` at the end of the edge."""
  node: Integration!
}

"""Methods to use when ordering `Integration`."""
enum IntegrationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  MEDIA_ASC
  MEDIA_DESC
  LOCATION_ASC
  LOCATION_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Integration` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input IntegrationCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """Checks for equality with the object’s `location` field."""
  location: String

  """Checks for equality with the object’s `category` field."""
  category: String
}

"""A connection to a list of `Internalization` values."""
type InternalizationsConnection {
  """A list of `Internalization` objects."""
  nodes: [Internalization!]!

  """
  A list of edges which contains the `Internalization` and cursor to aid in pagination.
  """
  edges: [InternalizationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `Internalization` you could get from the connection.
  """
  totalCount: Int!
}

type Internalization implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  region: String
  description: String
  default: String
  website: String
}

"""A `Internalization` edge in the connection."""
type InternalizationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Internalization` at the end of the edge."""
  node: Internalization!
}

"""Methods to use when ordering `Internalization`."""
enum InternalizationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  REGION_ASC
  REGION_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  DEFAULT_ASC
  DEFAULT_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Internalization` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input InternalizationCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `region` field."""
  region: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `default` field."""
  default: String

  """Checks for equality with the object’s `website` field."""
  website: String
}

"""A connection to a list of `Invoice` values."""
type InvoicesConnection {
  """A list of `Invoice` objects."""
  nodes: [Invoice!]!

  """
  A list of edges which contains the `Invoice` and cursor to aid in pagination.
  """
  edges: [InvoicesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Invoice` you could get from the connection."""
  totalCount: Int!
}

type Invoice implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  invoice: Int!
  orderNumber: BigInt!
  invoiceDate: Datetime
  billToName: String!
  billingAddress: String
  grandTotalBase: String
  grandTotalPurchased: String
  status: String
  shippingAddress: String
  customerName: String
  email: String
  customerGroup: String
  paymentMethod: String
  shippingInformation: String
  subtotal: String
  shippingAndHandling: String
  id: BigInt!
}

"""A `Invoice` edge in the connection."""
type InvoicesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Invoice` at the end of the edge."""
  node: Invoice!
}

"""Methods to use when ordering `Invoice`."""
enum InvoicesOrderBy {
  NATURAL
  INVOICE_ASC
  INVOICE_DESC
  ORDER_NUMBER_ASC
  ORDER_NUMBER_DESC
  INVOICE_DATE_ASC
  INVOICE_DATE_DESC
  BILL_TO_NAME_ASC
  BILL_TO_NAME_DESC
  BILLING_ADDRESS_ASC
  BILLING_ADDRESS_DESC
  GRAND_TOTAL_BASE_ASC
  GRAND_TOTAL_BASE_DESC
  GRAND_TOTAL_PURCHASED_ASC
  GRAND_TOTAL_PURCHASED_DESC
  STATUS_ASC
  STATUS_DESC
  SHIPPING_ADDRESS_ASC
  SHIPPING_ADDRESS_DESC
  CUSTOMER_NAME_ASC
  CUSTOMER_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  CUSTOMER_GROUP_ASC
  CUSTOMER_GROUP_DESC
  PAYMENT_METHOD_ASC
  PAYMENT_METHOD_DESC
  SHIPPING_INFORMATION_ASC
  SHIPPING_INFORMATION_DESC
  SUBTOTAL_ASC
  SUBTOTAL_DESC
  SHIPPING_AND_HANDLING_ASC
  SHIPPING_AND_HANDLING_DESC
  ID_ASC
  ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Invoice` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input InvoiceCondition {
  """Checks for equality with the object’s `invoice` field."""
  invoice: Int

  """Checks for equality with the object’s `orderNumber` field."""
  orderNumber: BigInt

  """Checks for equality with the object’s `invoiceDate` field."""
  invoiceDate: Datetime

  """Checks for equality with the object’s `billToName` field."""
  billToName: String

  """Checks for equality with the object’s `billingAddress` field."""
  billingAddress: String

  """Checks for equality with the object’s `grandTotalBase` field."""
  grandTotalBase: String

  """Checks for equality with the object’s `grandTotalPurchased` field."""
  grandTotalPurchased: String

  """Checks for equality with the object’s `status` field."""
  status: String

  """Checks for equality with the object’s `shippingAddress` field."""
  shippingAddress: String

  """Checks for equality with the object’s `customerName` field."""
  customerName: String

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `customerGroup` field."""
  customerGroup: String

  """Checks for equality with the object’s `paymentMethod` field."""
  paymentMethod: String

  """Checks for equality with the object’s `shippingInformation` field."""
  shippingInformation: String

  """Checks for equality with the object’s `subtotal` field."""
  subtotal: String

  """Checks for equality with the object’s `shippingAndHandling` field."""
  shippingAndHandling: String

  """Checks for equality with the object’s `id` field."""
  id: BigInt
}

"""A connection to a list of `LogIn` values."""
type LogInsConnection {
  """A list of `LogIn` objects."""
  nodes: [LogIn!]!

  """
  A list of edges which contains the `LogIn` and cursor to aid in pagination.
  """
  edges: [LogInsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `LogIn` you could get from the connection."""
  totalCount: Int!
}

type LogIn implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  email: String
  password: String
  token: String
  expiresIn: String
  users: String
  username: String
}

"""A `LogIn` edge in the connection."""
type LogInsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `LogIn` at the end of the edge."""
  node: LogIn!
}

"""Methods to use when ordering `LogIn`."""
enum LogInsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  EMAIL_ASC
  EMAIL_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  TOKEN_ASC
  TOKEN_DESC
  EXPIRES_IN_ASC
  EXPIRES_IN_DESC
  USERS_ASC
  USERS_DESC
  USERNAME_ASC
  USERNAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LogIn` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input LogInCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `password` field."""
  password: String

  """Checks for equality with the object’s `token` field."""
  token: String

  """Checks for equality with the object’s `expiresIn` field."""
  expiresIn: String

  """Checks for equality with the object’s `users` field."""
  users: String

  """Checks for equality with the object’s `username` field."""
  username: String
}

"""A connection to a list of `Manufacturer` values."""
type ManufacturersConnection {
  """A list of `Manufacturer` objects."""
  nodes: [Manufacturer!]!

  """
  A list of edges which contains the `Manufacturer` and cursor to aid in pagination.
  """
  edges: [ManufacturersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Manufacturer` you could get from the connection."""
  totalCount: Int!
}

type Manufacturer implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
  products: String
}

"""A `Manufacturer` edge in the connection."""
type ManufacturersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Manufacturer` at the end of the edge."""
  node: Manufacturer!
}

"""Methods to use when ordering `Manufacturer`."""
enum ManufacturersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  STATE_ASC
  STATE_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  CITY_ASC
  CITY_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  MEDIA_ASC
  MEDIA_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Manufacturer` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ManufacturerCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: String

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `product` field."""
  product: BigInt

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """Checks for equality with the object’s `products` field."""
  products: String
}

"""A connection to a list of `Mediamanager` values."""
type MediamanagersConnection {
  """A list of `Mediamanager` objects."""
  nodes: [Mediamanager!]!

  """
  A list of edges which contains the `Mediamanager` and cursor to aid in pagination.
  """
  edges: [MediamanagersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Mediamanager` you could get from the connection."""
  totalCount: Int!
}

type Mediamanager implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  createdAt: Datetime
  name: String
  description: String
  media: String
  keywords: String
  tags: String
  brands: String
  status: String
  expirationDate: String
  copyright: String
  dimensions: String
  author: String
  contentType: String
  versions: String
  watermarkName: String
  watermarkDescription: String
  watermarkMedia: String
  agreements: String
  albums: String
  comment: String
  workspace: String
  taskName: String
  taskDescription: String
  taskType: String
  members: String
  products: String
  agreementsAgreementsTomediamanager: String
  brandsBrandsTomediamanager: String
  comments: String
  customers: String
  productsMediamanagerToproducts: String
  tasks: String
  users: String
}

"""A `Mediamanager` edge in the connection."""
type MediamanagersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Mediamanager` at the end of the edge."""
  node: Mediamanager!
}

"""Methods to use when ordering `Mediamanager`."""
enum MediamanagersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  MEDIA_ASC
  MEDIA_DESC
  KEYWORDS_ASC
  KEYWORDS_DESC
  TAGS_ASC
  TAGS_DESC
  BRANDS_ASC
  BRANDS_DESC
  STATUS_ASC
  STATUS_DESC
  EXPIRATION_DATE_ASC
  EXPIRATION_DATE_DESC
  COPYRIGHT_ASC
  COPYRIGHT_DESC
  DIMENSIONS_ASC
  DIMENSIONS_DESC
  AUTHOR_ASC
  AUTHOR_DESC
  CONTENT_TYPE_ASC
  CONTENT_TYPE_DESC
  VERSIONS_ASC
  VERSIONS_DESC
  WATERMARK_NAME_ASC
  WATERMARK_NAME_DESC
  WATERMARK_DESCRIPTION_ASC
  WATERMARK_DESCRIPTION_DESC
  WATERMARK_MEDIA_ASC
  WATERMARK_MEDIA_DESC
  AGREEMENTS_ASC
  AGREEMENTS_DESC
  ALBUMS_ASC
  ALBUMS_DESC
  COMMENT_ASC
  COMMENT_DESC
  WORKSPACE_ASC
  WORKSPACE_DESC
  TASK_NAME_ASC
  TASK_NAME_DESC
  TASK_DESCRIPTION_ASC
  TASK_DESCRIPTION_DESC
  TASK_TYPE_ASC
  TASK_TYPE_DESC
  MEMBERS_ASC
  MEMBERS_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  AGREEMENTS_AGREEMENTS_TOMEDIAMANAGER_ASC
  AGREEMENTS_AGREEMENTS_TOMEDIAMANAGER_DESC
  BRANDS_BRANDS_TOMEDIAMANAGER_ASC
  BRANDS_BRANDS_TOMEDIAMANAGER_DESC
  COMMENTS_ASC
  COMMENTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  PRODUCTS_MEDIAMANAGER_TOPRODUCTS_ASC
  PRODUCTS_MEDIAMANAGER_TOPRODUCTS_DESC
  TASKS_ASC
  TASKS_DESC
  USERS_ASC
  USERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Mediamanager` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input MediamanagerCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """Checks for equality with the object’s `keywords` field."""
  keywords: String

  """Checks for equality with the object’s `tags` field."""
  tags: String

  """Checks for equality with the object’s `brands` field."""
  brands: String

  """Checks for equality with the object’s `status` field."""
  status: String

  """Checks for equality with the object’s `expirationDate` field."""
  expirationDate: String

  """Checks for equality with the object’s `copyright` field."""
  copyright: String

  """Checks for equality with the object’s `dimensions` field."""
  dimensions: String

  """Checks for equality with the object’s `author` field."""
  author: String

  """Checks for equality with the object’s `contentType` field."""
  contentType: String

  """Checks for equality with the object’s `versions` field."""
  versions: String

  """Checks for equality with the object’s `watermarkName` field."""
  watermarkName: String

  """Checks for equality with the object’s `watermarkDescription` field."""
  watermarkDescription: String

  """Checks for equality with the object’s `watermarkMedia` field."""
  watermarkMedia: String

  """Checks for equality with the object’s `agreements` field."""
  agreements: String

  """Checks for equality with the object’s `albums` field."""
  albums: String

  """Checks for equality with the object’s `comment` field."""
  comment: String

  """Checks for equality with the object’s `workspace` field."""
  workspace: String

  """Checks for equality with the object’s `taskName` field."""
  taskName: String

  """Checks for equality with the object’s `taskDescription` field."""
  taskDescription: String

  """Checks for equality with the object’s `taskType` field."""
  taskType: String

  """Checks for equality with the object’s `members` field."""
  members: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """
  Checks for equality with the object’s `agreementsAgreementsTomediamanager` field.
  """
  agreementsAgreementsTomediamanager: String

  """
  Checks for equality with the object’s `brandsBrandsTomediamanager` field.
  """
  brandsBrandsTomediamanager: String

  """Checks for equality with the object’s `comments` field."""
  comments: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """
  Checks for equality with the object’s `productsMediamanagerToproducts` field.
  """
  productsMediamanagerToproducts: String

  """Checks for equality with the object’s `tasks` field."""
  tasks: String

  """Checks for equality with the object’s `users` field."""
  users: String
}

"""A connection to a list of `Newsletter` values."""
type NewslettersConnection {
  """A list of `Newsletter` objects."""
  nodes: [Newsletter!]!

  """
  A list of edges which contains the `Newsletter` and cursor to aid in pagination.
  """
  edges: [NewslettersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Newsletter` you could get from the connection."""
  totalCount: Int!
}

type Newsletter implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  email: String!
  customerFirstName: String
  customerLastName: String
  store: String
  status: String
  websites: String
  createdAt: Datetime
  custId: Int!
  customers: String
}

"""A `Newsletter` edge in the connection."""
type NewslettersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Newsletter` at the end of the edge."""
  node: Newsletter!
}

"""Methods to use when ordering `Newsletter`."""
enum NewslettersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  CUSTOMER_FIRST_NAME_ASC
  CUSTOMER_FIRST_NAME_DESC
  CUSTOMER_LAST_NAME_ASC
  CUSTOMER_LAST_NAME_DESC
  STORE_ASC
  STORE_DESC
  STATUS_ASC
  STATUS_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Newsletter` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input NewsletterCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `customerFirstName` field."""
  customerFirstName: String

  """Checks for equality with the object’s `customerLastName` field."""
  customerLastName: String

  """Checks for equality with the object’s `store` field."""
  store: String

  """Checks for equality with the object’s `status` field."""
  status: String

  """Checks for equality with the object’s `websites` field."""
  websites: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `custId` field."""
  custId: Int

  """Checks for equality with the object’s `customers` field."""
  customers: String
}

"""A connection to a list of `Ooto` values."""
type OotosConnection {
  """A list of `Ooto` objects."""
  nodes: [Ooto!]!

  """
  A list of edges which contains the `Ooto` and cursor to aid in pagination.
  """
  edges: [OotosEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Ooto` you could get from the connection."""
  totalCount: Int!
}

type Ooto implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  login: String
  startDate: String
  endDate: String
  note: String
  usingTime: String
  location: String
}

"""A `Ooto` edge in the connection."""
type OotosEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Ooto` at the end of the edge."""
  node: Ooto!
}

"""Methods to use when ordering `Ooto`."""
enum OotosOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  LOGIN_ASC
  LOGIN_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  NOTE_ASC
  NOTE_DESC
  USING_TIME_ASC
  USING_TIME_DESC
  LOCATION_ASC
  LOCATION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Ooto` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input OotoCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `login` field."""
  login: String

  """Checks for equality with the object’s `startDate` field."""
  startDate: String

  """Checks for equality with the object’s `endDate` field."""
  endDate: String

  """Checks for equality with the object’s `note` field."""
  note: String

  """Checks for equality with the object’s `usingTime` field."""
  usingTime: String

  """Checks for equality with the object’s `location` field."""
  location: String
}

"""A connection to a list of `Order` values."""
type OrdersConnection {
  """A list of `Order` objects."""
  nodes: [Order!]!

  """
  A list of edges which contains the `Order` and cursor to aid in pagination.
  """
  edges: [OrdersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Order` you could get from the connection."""
  totalCount: Int!
}

type Order implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  purchasePoint: Int
  purchaseDate: Datetime
  billToName: String!
  shipToName: String
  grandTotalBase: Int
  grandTotalPurchased: Int
  status: Boolean
  action: Boolean
  allocatedSources: String
  braintreeTransactionSource: String
  custId: Int!
  prodId: BigInt!
  customers: String
  products: String
  quotes: String
  transactions: String
}

"""A `Order` edge in the connection."""
type OrdersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Order` at the end of the edge."""
  node: Order!
}

"""Methods to use when ordering `Order`."""
enum OrdersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PURCHASE_POINT_ASC
  PURCHASE_POINT_DESC
  PURCHASE_DATE_ASC
  PURCHASE_DATE_DESC
  BILL_TO_NAME_ASC
  BILL_TO_NAME_DESC
  SHIP_TO_NAME_ASC
  SHIP_TO_NAME_DESC
  GRAND_TOTAL_BASE_ASC
  GRAND_TOTAL_BASE_DESC
  GRAND_TOTAL_PURCHASED_ASC
  GRAND_TOTAL_PURCHASED_DESC
  STATUS_ASC
  STATUS_DESC
  ACTION_ASC
  ACTION_DESC
  ALLOCATED_SOURCES_ASC
  ALLOCATED_SOURCES_DESC
  BRAINTREE_TRANSACTION_SOURCE_ASC
  BRAINTREE_TRANSACTION_SOURCE_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  QUOTES_ASC
  QUOTES_DESC
  TRANSACTIONS_ASC
  TRANSACTIONS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Order` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input OrderCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `purchasePoint` field."""
  purchasePoint: Int

  """Checks for equality with the object’s `purchaseDate` field."""
  purchaseDate: Datetime

  """Checks for equality with the object’s `billToName` field."""
  billToName: String

  """Checks for equality with the object’s `shipToName` field."""
  shipToName: String

  """Checks for equality with the object’s `grandTotalBase` field."""
  grandTotalBase: Int

  """Checks for equality with the object’s `grandTotalPurchased` field."""
  grandTotalPurchased: Int

  """Checks for equality with the object’s `status` field."""
  status: Boolean

  """Checks for equality with the object’s `action` field."""
  action: Boolean

  """Checks for equality with the object’s `allocatedSources` field."""
  allocatedSources: String

  """
  Checks for equality with the object’s `braintreeTransactionSource` field.
  """
  braintreeTransactionSource: String

  """Checks for equality with the object’s `custId` field."""
  custId: Int

  """Checks for equality with the object’s `prodId` field."""
  prodId: BigInt

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `quotes` field."""
  quotes: String

  """Checks for equality with the object’s `transactions` field."""
  transactions: String
}

"""A connection to a list of `Page` values."""
type PagesConnection {
  """A list of `Page` objects."""
  nodes: [Page!]!

  """
  A list of edges which contains the `Page` and cursor to aid in pagination.
  """
  edges: [PagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Page` you could get from the connection."""
  totalCount: Int!
}

type Page implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  enablePage: Boolean
  title: String!
  contentTitle: String
  content: String
  urlKey: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
}

"""A `Page` edge in the connection."""
type PagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Page` at the end of the edge."""
  node: Page!
}

"""Methods to use when ordering `Page`."""
enum PagesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ENABLE_PAGE_ASC
  ENABLE_PAGE_DESC
  TITLE_ASC
  TITLE_DESC
  CONTENT_TITLE_ASC
  CONTENT_TITLE_DESC
  CONTENT_ASC
  CONTENT_DESC
  URL_KEY_ASC
  URL_KEY_DESC
  META_TITLE_ASC
  META_TITLE_DESC
  META_KEYWORDS_ASC
  META_KEYWORDS_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Page` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PageCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `enablePage` field."""
  enablePage: Boolean

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `contentTitle` field."""
  contentTitle: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `urlKey` field."""
  urlKey: String

  """Checks for equality with the object’s `metaTitle` field."""
  metaTitle: String

  """Checks for equality with the object’s `metaKeywords` field."""
  metaKeywords: String

  """Checks for equality with the object’s `metaDescription` field."""
  metaDescription: String
}

"""A connection to a list of `Partner` values."""
type PartnersConnection {
  """A list of `Partner` objects."""
  nodes: [Partner!]!

  """
  A list of edges which contains the `Partner` and cursor to aid in pagination.
  """
  edges: [PartnersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Partner` you could get from the connection."""
  totalCount: Int!
}

type Partner implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  address: String
  city: String
  state: String
  country: String
  isPublic: String
  businessType: String
}

"""A `Partner` edge in the connection."""
type PartnersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Partner` at the end of the edge."""
  node: Partner!
}

"""Methods to use when ordering `Partner`."""
enum PartnersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  BUSINESS_TYPE_ASC
  BUSINESS_TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Partner` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PartnerCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `address` field."""
  address: String

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: String

  """Checks for equality with the object’s `businessType` field."""
  businessType: String
}

"""A connection to a list of `Payment` values."""
type PaymentsConnection {
  """A list of `Payment` objects."""
  nodes: [Payment!]!

  """
  A list of edges which contains the `Payment` and cursor to aid in pagination.
  """
  edges: [PaymentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Payment` you could get from the connection."""
  totalCount: Int!
}

type Payment implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String!
  active: String
  country: String
}

"""A `Payment` edge in the connection."""
type PaymentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Payment` at the end of the edge."""
  node: Payment!
}

"""Methods to use when ordering `Payment`."""
enum PaymentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  HOST_URI_ASC
  HOST_URI_DESC
  REDIRECT_URL_ASC
  REDIRECT_URL_DESC
  REDIRECT_URL_APP_ASC
  REDIRECT_URL_APP_DESC
  ICON_ASC
  ICON_DESC
  NAME_ASC
  NAME_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Payment` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PaymentCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `clientId` field."""
  clientId: String

  """Checks for equality with the object’s `clientSecret` field."""
  clientSecret: String

  """Checks for equality with the object’s `hostUri` field."""
  hostUri: String

  """Checks for equality with the object’s `redirectUrl` field."""
  redirectUrl: String

  """Checks for equality with the object’s `redirectUrlApp` field."""
  redirectUrlApp: String

  """Checks for equality with the object’s `icon` field."""
  icon: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `active` field."""
  active: String

  """Checks for equality with the object’s `country` field."""
  country: String
}

"""A connection to a list of `Permission` values."""
type PermissionsConnection {
  """A list of `Permission` objects."""
  nodes: [Permission!]!

  """
  A list of edges which contains the `Permission` and cursor to aid in pagination.
  """
  edges: [PermissionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Permission` you could get from the connection."""
  totalCount: Int!
}

type Permission implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  content: String
  create: String
  delete: String
  read: String
  role: String
  update: String
  users: String
}

"""A `Permission` edge in the connection."""
type PermissionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Permission` at the end of the edge."""
  node: Permission!
}

"""Methods to use when ordering `Permission`."""
enum PermissionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  CREATE_ASC
  CREATE_DESC
  DELETE_ASC
  DELETE_DESC
  READ_ASC
  READ_DESC
  ROLE_ASC
  ROLE_DESC
  UPDATE_ASC
  UPDATE_DESC
  USERS_ASC
  USERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Permission` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input PermissionCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `create` field."""
  create: String

  """Checks for equality with the object’s `delete` field."""
  delete: String

  """Checks for equality with the object’s `read` field."""
  read: String

  """Checks for equality with the object’s `role` field."""
  role: String

  """Checks for equality with the object’s `update` field."""
  update: String

  """Checks for equality with the object’s `users` field."""
  users: String
}

"""A connection to a list of `Plugin` values."""
type PluginsConnection {
  """A list of `Plugin` objects."""
  nodes: [Plugin!]!

  """
  A list of edges which contains the `Plugin` and cursor to aid in pagination.
  """
  edges: [PluginsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Plugin` you could get from the connection."""
  totalCount: Int!
}

type Plugin implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  url: String
  githubLink: String
  description: String
  logo: String
  screenshots: String
  lastUpdated: Datetime
  publisherName: String
  agreeTerms: Boolean
  publisherEmail: String
}

"""A `Plugin` edge in the connection."""
type PluginsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Plugin` at the end of the edge."""
  node: Plugin!
}

"""Methods to use when ordering `Plugin`."""
enum PluginsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  URL_ASC
  URL_DESC
  GITHUB_LINK_ASC
  GITHUB_LINK_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  LOGO_ASC
  LOGO_DESC
  SCREENSHOTS_ASC
  SCREENSHOTS_DESC
  LAST_UPDATED_ASC
  LAST_UPDATED_DESC
  PUBLISHER_NAME_ASC
  PUBLISHER_NAME_DESC
  AGREE_TERMS_ASC
  AGREE_TERMS_DESC
  PUBLISHER_EMAIL_ASC
  PUBLISHER_EMAIL_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Plugin` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PluginCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `githubLink` field."""
  githubLink: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `logo` field."""
  logo: String

  """Checks for equality with the object’s `screenshots` field."""
  screenshots: String

  """Checks for equality with the object’s `lastUpdated` field."""
  lastUpdated: Datetime

  """Checks for equality with the object’s `publisherName` field."""
  publisherName: String

  """Checks for equality with the object’s `agreeTerms` field."""
  agreeTerms: Boolean

  """Checks for equality with the object’s `publisherEmail` field."""
  publisherEmail: String
}

"""A connection to a list of `ProductType` values."""
type ProductTypesConnection {
  """A list of `ProductType` objects."""
  nodes: [ProductType!]!

  """
  A list of edges which contains the `ProductType` and cursor to aid in pagination.
  """
  edges: [ProductTypesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ProductType` you could get from the connection."""
  totalCount: Int!
}

type ProductType implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  typeName: String
  taxes: String
  isShippable: String
  metaUrl: String
  metaDescription: String
  filterOptions: String
  productType: String
  prodId: BigInt!
  products: String
}

"""A `ProductType` edge in the connection."""
type ProductTypesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProductType` at the end of the edge."""
  node: ProductType!
}

"""Methods to use when ordering `ProductType`."""
enum ProductTypesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TYPE_NAME_ASC
  TYPE_NAME_DESC
  TAXES_ASC
  TAXES_DESC
  IS_SHIPPABLE_ASC
  IS_SHIPPABLE_DESC
  META_URL_ASC
  META_URL_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  FILTER_OPTIONS_ASC
  FILTER_OPTIONS_DESC
  PRODUCT_TYPE_ASC
  PRODUCT_TYPE_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ProductType` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ProductTypeCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `typeName` field."""
  typeName: String

  """Checks for equality with the object’s `taxes` field."""
  taxes: String

  """Checks for equality with the object’s `isShippable` field."""
  isShippable: String

  """Checks for equality with the object’s `metaUrl` field."""
  metaUrl: String

  """Checks for equality with the object’s `metaDescription` field."""
  metaDescription: String

  """Checks for equality with the object’s `filterOptions` field."""
  filterOptions: String

  """Checks for equality with the object’s `productType` field."""
  productType: String

  """Checks for equality with the object’s `prodId` field."""
  prodId: BigInt

  """Checks for equality with the object’s `products` field."""
  products: String
}

"""A connection to a list of `Product` values."""
type ProductsConnection {
  """A list of `Product` objects."""
  nodes: [Product!]!

  """
  A list of edges which contains the `Product` and cursor to aid in pagination.
  """
  edges: [ProductsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Product` you could get from the connection."""
  totalCount: Int!
}

type Product implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  sku: BigInt!
  thumbnail: String
  name: String!
  price: String
  quantityPerSource: String
  salableQuantity: String
  visibility: String
  status: Boolean
  websites: String
  product: String
  taxClass: String
  stockStatus: String
  weight: String
  categories: String
  createdAt: Datetime
  country: String
  size: String
  format: String
  height: String
  content: String
  shortDescription: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  file: String
  manufacture: String
  attributes: String
  brand: String
  contract: String
  costString: String
  customerType: String
  family: String
  manufacturerPartNumber: String
  occassions: String
  partNumber: String
  relatedProduct: BigInt
  tags: String
  types: String
  variants: String
  zone: String
  brands: String
  coupons: String
  creditMemos: String
  manufacturer: String
  mediamanager: String
  occassionsOccassionsToproducts: String
  orders: String
  otherProducts: String
  productAttribute: String
  productTypes: String
  products: String
  quotes: String
  rating: String
  returns: String
  taxRate: String
  taxRule: String
  trainings: String
  workspaces: String
}

"""A `Product` edge in the connection."""
type ProductsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Product` at the end of the edge."""
  node: Product!
}

"""Methods to use when ordering `Product`."""
enum ProductsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  SKU_ASC
  SKU_DESC
  THUMBNAIL_ASC
  THUMBNAIL_DESC
  NAME_ASC
  NAME_DESC
  PRICE_ASC
  PRICE_DESC
  QUANTITY_PER_SOURCE_ASC
  QUANTITY_PER_SOURCE_DESC
  SALABLE_QUANTITY_ASC
  SALABLE_QUANTITY_DESC
  VISIBILITY_ASC
  VISIBILITY_DESC
  STATUS_ASC
  STATUS_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  TAX_CLASS_ASC
  TAX_CLASS_DESC
  STOCK_STATUS_ASC
  STOCK_STATUS_DESC
  WEIGHT_ASC
  WEIGHT_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  SIZE_ASC
  SIZE_DESC
  FORMAT_ASC
  FORMAT_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  CONTENT_ASC
  CONTENT_DESC
  SHORT_DESCRIPTION_ASC
  SHORT_DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  META_TITLE_ASC
  META_TITLE_DESC
  META_KEYWORDS_ASC
  META_KEYWORDS_DESC
  META_DESCRIPTION_ASC
  META_DESCRIPTION_DESC
  META_URL_ASC
  META_URL_DESC
  FILE_ASC
  FILE_DESC
  MANUFACTURE_ASC
  MANUFACTURE_DESC
  ATTRIBUTES_ASC
  ATTRIBUTES_DESC
  BRAND_ASC
  BRAND_DESC
  CONTRACT_ASC
  CONTRACT_DESC
  COST_STRING_ASC
  COST_STRING_DESC
  CUSTOMER_TYPE_ASC
  CUSTOMER_TYPE_DESC
  FAMILY_ASC
  FAMILY_DESC
  MANUFACTURER_PART_NUMBER_ASC
  MANUFACTURER_PART_NUMBER_DESC
  OCCASSIONS_ASC
  OCCASSIONS_DESC
  PART_NUMBER_ASC
  PART_NUMBER_DESC
  RELATED_PRODUCT_ASC
  RELATED_PRODUCT_DESC
  TAGS_ASC
  TAGS_DESC
  TYPES_ASC
  TYPES_DESC
  VARIANTS_ASC
  VARIANTS_DESC
  ZONE_ASC
  ZONE_DESC
  BRANDS_ASC
  BRANDS_DESC
  COUPONS_ASC
  COUPONS_DESC
  CREDIT_MEMOS_ASC
  CREDIT_MEMOS_DESC
  MANUFACTURER_ASC
  MANUFACTURER_DESC
  MEDIAMANAGER_ASC
  MEDIAMANAGER_DESC
  OCCASSIONS_OCCASSIONS_TOPRODUCTS_ASC
  OCCASSIONS_OCCASSIONS_TOPRODUCTS_DESC
  ORDERS_ASC
  ORDERS_DESC
  OTHER_PRODUCTS_ASC
  OTHER_PRODUCTS_DESC
  PRODUCT_ATTRIBUTE_ASC
  PRODUCT_ATTRIBUTE_DESC
  PRODUCT_TYPES_ASC
  PRODUCT_TYPES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  QUOTES_ASC
  QUOTES_DESC
  RATING_ASC
  RATING_DESC
  RETURNS_ASC
  RETURNS_DESC
  TAX_RATE_ASC
  TAX_RATE_DESC
  TAX_RULE_ASC
  TAX_RULE_DESC
  TRAININGS_ASC
  TRAININGS_DESC
  WORKSPACES_ASC
  WORKSPACES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Product` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProductCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `sku` field."""
  sku: BigInt

  """Checks for equality with the object’s `thumbnail` field."""
  thumbnail: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `price` field."""
  price: String

  """Checks for equality with the object’s `quantityPerSource` field."""
  quantityPerSource: String

  """Checks for equality with the object’s `salableQuantity` field."""
  salableQuantity: String

  """Checks for equality with the object’s `visibility` field."""
  visibility: String

  """Checks for equality with the object’s `status` field."""
  status: Boolean

  """Checks for equality with the object’s `websites` field."""
  websites: String

  """Checks for equality with the object’s `product` field."""
  product: String

  """Checks for equality with the object’s `taxClass` field."""
  taxClass: String

  """Checks for equality with the object’s `stockStatus` field."""
  stockStatus: String

  """Checks for equality with the object’s `weight` field."""
  weight: String

  """Checks for equality with the object’s `categories` field."""
  categories: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `size` field."""
  size: String

  """Checks for equality with the object’s `format` field."""
  format: String

  """Checks for equality with the object’s `height` field."""
  height: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `shortDescription` field."""
  shortDescription: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `metaTitle` field."""
  metaTitle: String

  """Checks for equality with the object’s `metaKeywords` field."""
  metaKeywords: String

  """Checks for equality with the object’s `metaDescription` field."""
  metaDescription: String

  """Checks for equality with the object’s `metaUrl` field."""
  metaUrl: String

  """Checks for equality with the object’s `file` field."""
  file: String

  """Checks for equality with the object’s `manufacture` field."""
  manufacture: String

  """Checks for equality with the object’s `attributes` field."""
  attributes: String

  """Checks for equality with the object’s `brand` field."""
  brand: String

  """Checks for equality with the object’s `contract` field."""
  contract: String

  """Checks for equality with the object’s `costString` field."""
  costString: String

  """Checks for equality with the object’s `customerType` field."""
  customerType: String

  """Checks for equality with the object’s `family` field."""
  family: String

  """Checks for equality with the object’s `manufacturerPartNumber` field."""
  manufacturerPartNumber: String

  """Checks for equality with the object’s `occassions` field."""
  occassions: String

  """Checks for equality with the object’s `partNumber` field."""
  partNumber: String

  """Checks for equality with the object’s `relatedProduct` field."""
  relatedProduct: BigInt

  """Checks for equality with the object’s `tags` field."""
  tags: String

  """Checks for equality with the object’s `types` field."""
  types: String

  """Checks for equality with the object’s `variants` field."""
  variants: String

  """Checks for equality with the object’s `zone` field."""
  zone: String

  """Checks for equality with the object’s `brands` field."""
  brands: String

  """Checks for equality with the object’s `coupons` field."""
  coupons: String

  """Checks for equality with the object’s `creditMemos` field."""
  creditMemos: String

  """Checks for equality with the object’s `manufacturer` field."""
  manufacturer: String

  """Checks for equality with the object’s `mediamanager` field."""
  mediamanager: String

  """
  Checks for equality with the object’s `occassionsOccassionsToproducts` field.
  """
  occassionsOccassionsToproducts: String

  """Checks for equality with the object’s `orders` field."""
  orders: String

  """Checks for equality with the object’s `otherProducts` field."""
  otherProducts: String

  """Checks for equality with the object’s `productAttribute` field."""
  productAttribute: String

  """Checks for equality with the object’s `productTypes` field."""
  productTypes: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `quotes` field."""
  quotes: String

  """Checks for equality with the object’s `rating` field."""
  rating: String

  """Checks for equality with the object’s `returns` field."""
  returns: String

  """Checks for equality with the object’s `taxRate` field."""
  taxRate: String

  """Checks for equality with the object’s `taxRule` field."""
  taxRule: String

  """Checks for equality with the object’s `trainings` field."""
  trainings: String

  """Checks for equality with the object’s `workspaces` field."""
  workspaces: String
}

"""A connection to a list of `Project` values."""
type ProjectsConnection {
  """A list of `Project` objects."""
  nodes: [Project!]!

  """
  A list of edges which contains the `Project` and cursor to aid in pagination.
  """
  edges: [ProjectsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

type Project implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  name: String
  projectManager: String
  startDate: String
  endDate: String
  resource: String
  considerworkingdays: String
  projectTemplate: String
  status: String
  createdAt: Datetime
  assignee: String
  custId: Int
  doing: String
  done: String
  goalCollaborators: String
  goalMeasurement: String
  goalName: String
  goalPrivacy: String
  goalProgressSource: String
  goalTimeperiod: String
  goalUpdatemethod: String
  priority: String
  sectionRule: String
  staffId: Int
  taskId: BigInt
  ticketId: BigInt
  customers: String
  tasks: String
  ticketing: String
  users: String
  workspaces: String
  tags: String
  product: String
  websites: String
  method: String
  zone: String
  type: String
  team: String
  categories: String
  company: String
  file: String
}

"""A `Project` edge in the connection."""
type ProjectsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Project` at the end of the edge."""
  node: Project!
}

"""Methods to use when ordering `Project`."""
enum ProjectsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  PROJECT_MANAGER_ASC
  PROJECT_MANAGER_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  RESOURCE_ASC
  RESOURCE_DESC
  CONSIDERWORKINGDAYS_ASC
  CONSIDERWORKINGDAYS_DESC
  PROJECT_TEMPLATE_ASC
  PROJECT_TEMPLATE_DESC
  STATUS_ASC
  STATUS_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ASSIGNEE_ASC
  ASSIGNEE_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  DOING_ASC
  DOING_DESC
  DONE_ASC
  DONE_DESC
  GOAL_COLLABORATORS_ASC
  GOAL_COLLABORATORS_DESC
  GOAL_MEASUREMENT_ASC
  GOAL_MEASUREMENT_DESC
  GOAL_NAME_ASC
  GOAL_NAME_DESC
  GOAL_PRIVACY_ASC
  GOAL_PRIVACY_DESC
  GOAL_PROGRESS_SOURCE_ASC
  GOAL_PROGRESS_SOURCE_DESC
  GOAL_TIMEPERIOD_ASC
  GOAL_TIMEPERIOD_DESC
  GOAL_UPDATEMETHOD_ASC
  GOAL_UPDATEMETHOD_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  SECTION_RULE_ASC
  SECTION_RULE_DESC
  STAFF_ID_ASC
  STAFF_ID_DESC
  TASK_ID_ASC
  TASK_ID_DESC
  TICKET_ID_ASC
  TICKET_ID_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  TASKS_ASC
  TASKS_DESC
  TICKETING_ASC
  TICKETING_DESC
  USERS_ASC
  USERS_DESC
  WORKSPACES_ASC
  WORKSPACES_DESC
  TAGS_ASC
  TAGS_DESC
  PRODUCT_ASC
  PRODUCT_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  METHOD_ASC
  METHOD_DESC
  ZONE_ASC
  ZONE_DESC
  TYPE_ASC
  TYPE_DESC
  TEAM_ASC
  TEAM_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  COMPANY_ASC
  COMPANY_DESC
  FILE_ASC
  FILE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProjectCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `projectManager` field."""
  projectManager: String

  """Checks for equality with the object’s `startDate` field."""
  startDate: String

  """Checks for equality with the object’s `endDate` field."""
  endDate: String

  """Checks for equality with the object’s `resource` field."""
  resource: String

  """Checks for equality with the object’s `considerworkingdays` field."""
  considerworkingdays: String

  """Checks for equality with the object’s `projectTemplate` field."""
  projectTemplate: String

  """Checks for equality with the object’s `status` field."""
  status: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `assignee` field."""
  assignee: String

  """Checks for equality with the object’s `custId` field."""
  custId: Int

  """Checks for equality with the object’s `doing` field."""
  doing: String

  """Checks for equality with the object’s `done` field."""
  done: String

  """Checks for equality with the object’s `goalCollaborators` field."""
  goalCollaborators: String

  """Checks for equality with the object’s `goalMeasurement` field."""
  goalMeasurement: String

  """Checks for equality with the object’s `goalName` field."""
  goalName: String

  """Checks for equality with the object’s `goalPrivacy` field."""
  goalPrivacy: String

  """Checks for equality with the object’s `goalProgressSource` field."""
  goalProgressSource: String

  """Checks for equality with the object’s `goalTimeperiod` field."""
  goalTimeperiod: String

  """Checks for equality with the object’s `goalUpdatemethod` field."""
  goalUpdatemethod: String

  """Checks for equality with the object’s `priority` field."""
  priority: String

  """Checks for equality with the object’s `sectionRule` field."""
  sectionRule: String

  """Checks for equality with the object’s `staffId` field."""
  staffId: Int

  """Checks for equality with the object’s `taskId` field."""
  taskId: BigInt

  """Checks for equality with the object’s `ticketId` field."""
  ticketId: BigInt

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `tasks` field."""
  tasks: String

  """Checks for equality with the object’s `ticketing` field."""
  ticketing: String

  """Checks for equality with the object’s `users` field."""
  users: String

  """Checks for equality with the object’s `workspaces` field."""
  workspaces: String

  """Checks for equality with the object’s `tags` field."""
  tags: String

  """Checks for equality with the object’s `product` field."""
  product: String

  """Checks for equality with the object’s `websites` field."""
  websites: String

  """Checks for equality with the object’s `method` field."""
  method: String

  """Checks for equality with the object’s `zone` field."""
  zone: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `team` field."""
  team: String

  """Checks for equality with the object’s `categories` field."""
  categories: String

  """Checks for equality with the object’s `company` field."""
  company: String

  """Checks for equality with the object’s `file` field."""
  file: String
}

"""A connection to a list of `Provider` values."""
type ProvidersConnection {
  """A list of `Provider` objects."""
  nodes: [Provider!]!

  """
  A list of edges which contains the `Provider` and cursor to aid in pagination.
  """
  edges: [ProvidersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Provider` you could get from the connection."""
  totalCount: Int!
}

type Provider implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String!
  active: String
}

"""A `Provider` edge in the connection."""
type ProvidersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Provider` at the end of the edge."""
  node: Provider!
}

"""Methods to use when ordering `Provider`."""
enum ProvidersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  HOST_URI_ASC
  HOST_URI_DESC
  REDIRECT_URL_ASC
  REDIRECT_URL_DESC
  REDIRECT_URL_APP_ASC
  REDIRECT_URL_APP_DESC
  ICON_ASC
  ICON_DESC
  NAME_ASC
  NAME_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Provider` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ProviderCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `clientId` field."""
  clientId: String

  """Checks for equality with the object’s `clientSecret` field."""
  clientSecret: String

  """Checks for equality with the object’s `hostUri` field."""
  hostUri: String

  """Checks for equality with the object’s `redirectUrl` field."""
  redirectUrl: String

  """Checks for equality with the object’s `redirectUrlApp` field."""
  redirectUrlApp: String

  """Checks for equality with the object’s `icon` field."""
  icon: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `active` field."""
  active: String
}

"""A connection to a list of `Quote` values."""
type QuotesConnection {
  """A list of `Quote` objects."""
  nodes: [Quote!]!

  """
  A list of edges which contains the `Quote` and cursor to aid in pagination.
  """
  edges: [QuotesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Quote` you could get from the connection."""
  totalCount: Int!
}

type Quote implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  grandTotal: String
  createdAt: Datetime
  categories: String
  validUntil: String
  quoteStage: String
  customers: String
  custId: Int!
  prodId: BigInt!
  orderId: Int!
  account: String
  approvalIssues: String
  approvalStatus: String
  assignedTo: String
  billingCity: String
  billingCountry: String
  billingPostal: String
  billingState: String
  billingStreet: String
  contact: String
  currency: String
  discount: String
  invoiceStatus: String
  lineItemDiscount: String
  lineItemGroupTotal: String
  lineItemName: String
  lineItemSubtotal: String
  lineItemTax: String
  lineItemTotal: String
  paymentTerms: String
  shipping: String
  shippingCity: String
  shippingCountry: String
  shippingPostal: String
  shippingState: String
  shippingStreet: String
  shippingTax: String
  subtotal: String
  tax: String
  total: String
  customersCustomersToquotes: String
  orders: String
  productsProductsToquotes: String
}

"""A `Quote` edge in the connection."""
type QuotesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Quote` at the end of the edge."""
  node: Quote!
}

"""Methods to use when ordering `Quote`."""
enum QuotesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  GRAND_TOTAL_ASC
  GRAND_TOTAL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  VALID_UNTIL_ASC
  VALID_UNTIL_DESC
  QUOTE_STAGE_ASC
  QUOTE_STAGE_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  CUST_ID_ASC
  CUST_ID_DESC
  PROD_ID_ASC
  PROD_ID_DESC
  ORDER_ID_ASC
  ORDER_ID_DESC
  ACCOUNT_ASC
  ACCOUNT_DESC
  APPROVAL_ISSUES_ASC
  APPROVAL_ISSUES_DESC
  APPROVAL_STATUS_ASC
  APPROVAL_STATUS_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  BILLING_CITY_ASC
  BILLING_CITY_DESC
  BILLING_COUNTRY_ASC
  BILLING_COUNTRY_DESC
  BILLING_POSTAL_ASC
  BILLING_POSTAL_DESC
  BILLING_STATE_ASC
  BILLING_STATE_DESC
  BILLING_STREET_ASC
  BILLING_STREET_DESC
  CONTACT_ASC
  CONTACT_DESC
  CURRENCY_ASC
  CURRENCY_DESC
  DISCOUNT_ASC
  DISCOUNT_DESC
  INVOICE_STATUS_ASC
  INVOICE_STATUS_DESC
  LINE_ITEM_DISCOUNT_ASC
  LINE_ITEM_DISCOUNT_DESC
  LINE_ITEM_GROUP_TOTAL_ASC
  LINE_ITEM_GROUP_TOTAL_DESC
  LINE_ITEM_NAME_ASC
  LINE_ITEM_NAME_DESC
  LINE_ITEM_SUBTOTAL_ASC
  LINE_ITEM_SUBTOTAL_DESC
  LINE_ITEM_TAX_ASC
  LINE_ITEM_TAX_DESC
  LINE_ITEM_TOTAL_ASC
  LINE_ITEM_TOTAL_DESC
  PAYMENT_TERMS_ASC
  PAYMENT_TERMS_DESC
  SHIPPING_ASC
  SHIPPING_DESC
  SHIPPING_CITY_ASC
  SHIPPING_CITY_DESC
  SHIPPING_COUNTRY_ASC
  SHIPPING_COUNTRY_DESC
  SHIPPING_POSTAL_ASC
  SHIPPING_POSTAL_DESC
  SHIPPING_STATE_ASC
  SHIPPING_STATE_DESC
  SHIPPING_STREET_ASC
  SHIPPING_STREET_DESC
  SHIPPING_TAX_ASC
  SHIPPING_TAX_DESC
  SUBTOTAL_ASC
  SUBTOTAL_DESC
  TAX_ASC
  TAX_DESC
  TOTAL_ASC
  TOTAL_DESC
  CUSTOMERS_CUSTOMERS_TOQUOTES_ASC
  CUSTOMERS_CUSTOMERS_TOQUOTES_DESC
  ORDERS_ASC
  ORDERS_DESC
  PRODUCTS_PRODUCTS_TOQUOTES_ASC
  PRODUCTS_PRODUCTS_TOQUOTES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Quote` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input QuoteCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `grandTotal` field."""
  grandTotal: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `categories` field."""
  categories: String

  """Checks for equality with the object’s `validUntil` field."""
  validUntil: String

  """Checks for equality with the object’s `quoteStage` field."""
  quoteStage: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `custId` field."""
  custId: Int

  """Checks for equality with the object’s `prodId` field."""
  prodId: BigInt

  """Checks for equality with the object’s `orderId` field."""
  orderId: Int

  """Checks for equality with the object’s `account` field."""
  account: String

  """Checks for equality with the object’s `approvalIssues` field."""
  approvalIssues: String

  """Checks for equality with the object’s `approvalStatus` field."""
  approvalStatus: String

  """Checks for equality with the object’s `assignedTo` field."""
  assignedTo: String

  """Checks for equality with the object’s `billingCity` field."""
  billingCity: String

  """Checks for equality with the object’s `billingCountry` field."""
  billingCountry: String

  """Checks for equality with the object’s `billingPostal` field."""
  billingPostal: String

  """Checks for equality with the object’s `billingState` field."""
  billingState: String

  """Checks for equality with the object’s `billingStreet` field."""
  billingStreet: String

  """Checks for equality with the object’s `contact` field."""
  contact: String

  """Checks for equality with the object’s `currency` field."""
  currency: String

  """Checks for equality with the object’s `discount` field."""
  discount: String

  """Checks for equality with the object’s `invoiceStatus` field."""
  invoiceStatus: String

  """Checks for equality with the object’s `lineItemDiscount` field."""
  lineItemDiscount: String

  """Checks for equality with the object’s `lineItemGroupTotal` field."""
  lineItemGroupTotal: String

  """Checks for equality with the object’s `lineItemName` field."""
  lineItemName: String

  """Checks for equality with the object’s `lineItemSubtotal` field."""
  lineItemSubtotal: String

  """Checks for equality with the object’s `lineItemTax` field."""
  lineItemTax: String

  """Checks for equality with the object’s `lineItemTotal` field."""
  lineItemTotal: String

  """Checks for equality with the object’s `paymentTerms` field."""
  paymentTerms: String

  """Checks for equality with the object’s `shipping` field."""
  shipping: String

  """Checks for equality with the object’s `shippingCity` field."""
  shippingCity: String

  """Checks for equality with the object’s `shippingCountry` field."""
  shippingCountry: String

  """Checks for equality with the object’s `shippingPostal` field."""
  shippingPostal: String

  """Checks for equality with the object’s `shippingState` field."""
  shippingState: String

  """Checks for equality with the object’s `shippingStreet` field."""
  shippingStreet: String

  """Checks for equality with the object’s `shippingTax` field."""
  shippingTax: String

  """Checks for equality with the object’s `subtotal` field."""
  subtotal: String

  """Checks for equality with the object’s `tax` field."""
  tax: String

  """Checks for equality with the object’s `total` field."""
  total: String

  """
  Checks for equality with the object’s `customersCustomersToquotes` field.
  """
  customersCustomersToquotes: String

  """Checks for equality with the object’s `orders` field."""
  orders: String

  """
  Checks for equality with the object’s `productsProductsToquotes` field.
  """
  productsProductsToquotes: String
}

"""A connection to a list of `Return` values."""
type ReturnsConnection {
  """A list of `Return` objects."""
  nodes: [Return!]!

  """
  A list of edges which contains the `Return` and cursor to aid in pagination.
  """
  edges: [ReturnsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Return` you could get from the connection."""
  totalCount: Int!
}

type Return implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  validity: String
  returnPrefix: String
  customers: String
  products: String
  type: String
  description: String
  shippingNumber: String
  shippingDescription: String
  status: String
  liquidationReason: String
  media: String
  weight: String
  height: String
  howShipped: String
  location: String
  shipTo: String
  caseId: String
}

"""A `Return` edge in the connection."""
type ReturnsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Return` at the end of the edge."""
  node: Return!
}

"""Methods to use when ordering `Return`."""
enum ReturnsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  VALIDITY_ASC
  VALIDITY_DESC
  RETURN_PREFIX_ASC
  RETURN_PREFIX_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  TYPE_ASC
  TYPE_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  SHIPPING_NUMBER_ASC
  SHIPPING_NUMBER_DESC
  SHIPPING_DESCRIPTION_ASC
  SHIPPING_DESCRIPTION_DESC
  STATUS_ASC
  STATUS_DESC
  LIQUIDATION_REASON_ASC
  LIQUIDATION_REASON_DESC
  MEDIA_ASC
  MEDIA_DESC
  WEIGHT_ASC
  WEIGHT_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  HOW_SHIPPED_ASC
  HOW_SHIPPED_DESC
  LOCATION_ASC
  LOCATION_DESC
  SHIP_TO_ASC
  SHIP_TO_DESC
  CASE_ID_ASC
  CASE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Return` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ReturnCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `validity` field."""
  validity: String

  """Checks for equality with the object’s `returnPrefix` field."""
  returnPrefix: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `shippingNumber` field."""
  shippingNumber: String

  """Checks for equality with the object’s `shippingDescription` field."""
  shippingDescription: String

  """Checks for equality with the object’s `status` field."""
  status: String

  """Checks for equality with the object’s `liquidationReason` field."""
  liquidationReason: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """Checks for equality with the object’s `weight` field."""
  weight: String

  """Checks for equality with the object’s `height` field."""
  height: String

  """Checks for equality with the object’s `howShipped` field."""
  howShipped: String

  """Checks for equality with the object’s `location` field."""
  location: String

  """Checks for equality with the object’s `shipTo` field."""
  shipTo: String

  """Checks for equality with the object’s `caseId` field."""
  caseId: String
}

"""A connection to a list of `Review` values."""
type ReviewsConnection {
  """A list of `Review` objects."""
  nodes: [Review!]!

  """
  A list of edges which contains the `Review` and cursor to aid in pagination.
  """
  edges: [ReviewsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Review` you could get from the connection."""
  totalCount: Int!
}

type Review implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  firstName: String
  lastName: String
  content: String
  websites: String
  createdAt: Datetime
  shopId: Int!
  commentId: Int!
}

"""A `Review` edge in the connection."""
type ReviewsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Review` at the end of the edge."""
  node: Review!
}

"""Methods to use when ordering `Review`."""
enum ReviewsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  SHOP_ID_ASC
  SHOP_ID_DESC
  COMMENT_ID_ASC
  COMMENT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Review` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ReviewCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `websites` field."""
  websites: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `shopId` field."""
  shopId: Int

  """Checks for equality with the object’s `commentId` field."""
  commentId: Int
}

"""A connection to a list of `Reward` values."""
type RewardsConnection {
  """A list of `Reward` objects."""
  nodes: [Reward!]!

  """
  A list of edges which contains the `Reward` and cursor to aid in pagination.
  """
  edges: [RewardsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Reward` you could get from the connection."""
  totalCount: Int!
}

type Reward implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  slug: String
  level: String
  createdAt: Datetime
  coupons: String
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""A `Reward` edge in the connection."""
type RewardsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Reward` at the end of the edge."""
  node: Reward!
}

"""Methods to use when ordering `Reward`."""
enum RewardsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  SLUG_ASC
  SLUG_DESC
  LEVEL_ASC
  LEVEL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  COUPONS_ASC
  COUPONS_DESC
  EXPIRATION_ASC
  EXPIRATION_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Reward` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RewardCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `level` field."""
  level: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `coupons` field."""
  coupons: String

  """Checks for equality with the object’s `expiration` field."""
  expiration: String

  """Checks for equality with the object’s `categories` field."""
  categories: String

  """Checks for equality with the object’s `articles` field."""
  articles: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `users` field."""
  users: String
}

"""A connection to a list of `Role` values."""
type RolesConnection {
  """A list of `Role` objects."""
  nodes: [Role!]!

  """
  A list of edges which contains the `Role` and cursor to aid in pagination.
  """
  edges: [RolesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Role` you could get from the connection."""
  totalCount: Int!
}

type Role implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  roleName: String!
  content: String
  createdAt: Datetime
}

"""A `Role` edge in the connection."""
type RolesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Role` at the end of the edge."""
  node: Role!
}

"""Methods to use when ordering `Role`."""
enum RolesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ROLE_NAME_ASC
  ROLE_NAME_DESC
  CONTENT_ASC
  CONTENT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Role` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RoleCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `roleName` field."""
  roleName: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime
}

"""A connection to a list of `Scheduler` values."""
type SchedulersConnection {
  """A list of `Scheduler` objects."""
  nodes: [Scheduler!]!

  """
  A list of edges which contains the `Scheduler` and cursor to aid in pagination.
  """
  edges: [SchedulersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Scheduler` you could get from the connection."""
  totalCount: Int!
}

type Scheduler implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  endDate: String
  level: String
  login: String
  notes: String
  startDate: String
  whid: String
  label: String
  public: String
  permission: String
  name: String
}

"""A `Scheduler` edge in the connection."""
type SchedulersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Scheduler` at the end of the edge."""
  node: Scheduler!
}

"""Methods to use when ordering `Scheduler`."""
enum SchedulersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  END_DATE_ASC
  END_DATE_DESC
  LEVEL_ASC
  LEVEL_DESC
  LOGIN_ASC
  LOGIN_DESC
  NOTES_ASC
  NOTES_DESC
  START_DATE_ASC
  START_DATE_DESC
  WHID_ASC
  WHID_DESC
  LABEL_ASC
  LABEL_DESC
  PUBLIC_ASC
  PUBLIC_DESC
  PERMISSION_ASC
  PERMISSION_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Scheduler` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input SchedulerCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `endDate` field."""
  endDate: String

  """Checks for equality with the object’s `level` field."""
  level: String

  """Checks for equality with the object’s `login` field."""
  login: String

  """Checks for equality with the object’s `notes` field."""
  notes: String

  """Checks for equality with the object’s `startDate` field."""
  startDate: String

  """Checks for equality with the object’s `whid` field."""
  whid: String

  """Checks for equality with the object’s `label` field."""
  label: String

  """Checks for equality with the object’s `public` field."""
  public: String

  """Checks for equality with the object’s `permission` field."""
  permission: String

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""A connection to a list of `Segment` values."""
type SegmentsConnection {
  """A list of `Segment` objects."""
  nodes: [Segment!]!

  """
  A list of edges which contains the `Segment` and cursor to aid in pagination.
  """
  edges: [SegmentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Segment` you could get from the connection."""
  totalCount: Int!
}

type Segment implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  description: String
  website: String
  status: String
  applyTo: String
  customers: String
}

"""A `Segment` edge in the connection."""
type SegmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Segment` at the end of the edge."""
  node: Segment!
}

"""Methods to use when ordering `Segment`."""
enum SegmentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  STATUS_ASC
  STATUS_DESC
  APPLY_TO_ASC
  APPLY_TO_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Segment` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input SegmentCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `website` field."""
  website: String

  """Checks for equality with the object’s `status` field."""
  status: String

  """Checks for equality with the object’s `applyTo` field."""
  applyTo: String

  """Checks for equality with the object’s `customers` field."""
  customers: String
}

"""A connection to a list of `Setting` values."""
type SettingsConnection {
  """A list of `Setting` objects."""
  nodes: [Setting!]!

  """
  A list of edges which contains the `Setting` and cursor to aid in pagination.
  """
  edges: [SettingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Setting` you could get from the connection."""
  totalCount: Int!
}

type Setting implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  storeName: String
  storePhone: String
  storeHours: String
  country: String
  region: String
  zipcode: String
  city: String
  address: String
  addressTwo: String
  vatNumber: String
  allowState: String
  stateRequiredFor: String
  allowCountries: String
  defaultCountry: String
  optionalZip: String
  europeanUnionCountries: String
  topDestinations: String
  baseCurrency: String
  defaultCurrency: String
  allowedCurrency: String
  siteName: String
  siteWebsite: String
  sentryDsn: String
  awsS3: String
  databaseUrl: String
  isPublic: String
  type: String
  googleAnalytics: String
  searchSetting: String
  mailServer: String
  siteTagline: String
}

"""A `Setting` edge in the connection."""
type SettingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Setting` at the end of the edge."""
  node: Setting!
}

"""Methods to use when ordering `Setting`."""
enum SettingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  STORE_NAME_ASC
  STORE_NAME_DESC
  STORE_PHONE_ASC
  STORE_PHONE_DESC
  STORE_HOURS_ASC
  STORE_HOURS_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  REGION_ASC
  REGION_DESC
  ZIPCODE_ASC
  ZIPCODE_DESC
  CITY_ASC
  CITY_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ADDRESS_TWO_ASC
  ADDRESS_TWO_DESC
  VAT_NUMBER_ASC
  VAT_NUMBER_DESC
  ALLOW_STATE_ASC
  ALLOW_STATE_DESC
  STATE_REQUIRED_FOR_ASC
  STATE_REQUIRED_FOR_DESC
  ALLOW_COUNTRIES_ASC
  ALLOW_COUNTRIES_DESC
  DEFAULT_COUNTRY_ASC
  DEFAULT_COUNTRY_DESC
  OPTIONAL_ZIP_ASC
  OPTIONAL_ZIP_DESC
  EUROPEAN_UNION_COUNTRIES_ASC
  EUROPEAN_UNION_COUNTRIES_DESC
  TOP_DESTINATIONS_ASC
  TOP_DESTINATIONS_DESC
  BASE_CURRENCY_ASC
  BASE_CURRENCY_DESC
  DEFAULT_CURRENCY_ASC
  DEFAULT_CURRENCY_DESC
  ALLOWED_CURRENCY_ASC
  ALLOWED_CURRENCY_DESC
  SITE_NAME_ASC
  SITE_NAME_DESC
  SITE_WEBSITE_ASC
  SITE_WEBSITE_DESC
  SENTRY_DSN_ASC
  SENTRY_DSN_DESC
  AWS_S3_ASC
  AWS_S3_DESC
  DATABASE_URL_ASC
  DATABASE_URL_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  TYPE_ASC
  TYPE_DESC
  GOOGLE_ANALYTICS_ASC
  GOOGLE_ANALYTICS_DESC
  SEARCH_SETTING_ASC
  SEARCH_SETTING_DESC
  MAIL_SERVER_ASC
  MAIL_SERVER_DESC
  SITE_TAGLINE_ASC
  SITE_TAGLINE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input SettingCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `storeName` field."""
  storeName: String

  """Checks for equality with the object’s `storePhone` field."""
  storePhone: String

  """Checks for equality with the object’s `storeHours` field."""
  storeHours: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `region` field."""
  region: String

  """Checks for equality with the object’s `zipcode` field."""
  zipcode: String

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `address` field."""
  address: String

  """Checks for equality with the object’s `addressTwo` field."""
  addressTwo: String

  """Checks for equality with the object’s `vatNumber` field."""
  vatNumber: String

  """Checks for equality with the object’s `allowState` field."""
  allowState: String

  """Checks for equality with the object’s `stateRequiredFor` field."""
  stateRequiredFor: String

  """Checks for equality with the object’s `allowCountries` field."""
  allowCountries: String

  """Checks for equality with the object’s `defaultCountry` field."""
  defaultCountry: String

  """Checks for equality with the object’s `optionalZip` field."""
  optionalZip: String

  """Checks for equality with the object’s `europeanUnionCountries` field."""
  europeanUnionCountries: String

  """Checks for equality with the object’s `topDestinations` field."""
  topDestinations: String

  """Checks for equality with the object’s `baseCurrency` field."""
  baseCurrency: String

  """Checks for equality with the object’s `defaultCurrency` field."""
  defaultCurrency: String

  """Checks for equality with the object’s `allowedCurrency` field."""
  allowedCurrency: String

  """Checks for equality with the object’s `siteName` field."""
  siteName: String

  """Checks for equality with the object’s `siteWebsite` field."""
  siteWebsite: String

  """Checks for equality with the object’s `sentryDsn` field."""
  sentryDsn: String

  """Checks for equality with the object’s `awsS3` field."""
  awsS3: String

  """Checks for equality with the object’s `databaseUrl` field."""
  databaseUrl: String

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `googleAnalytics` field."""
  googleAnalytics: String

  """Checks for equality with the object’s `searchSetting` field."""
  searchSetting: String

  """Checks for equality with the object’s `mailServer` field."""
  mailServer: String

  """Checks for equality with the object’s `siteTagline` field."""
  siteTagline: String
}

"""A connection to a list of `Shipment` values."""
type ShipmentsConnection {
  """A list of `Shipment` objects."""
  nodes: [Shipment!]!

  """
  A list of edges which contains the `Shipment` and cursor to aid in pagination.
  """
  edges: [ShipmentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Shipment` you could get from the connection."""
  totalCount: Int!
}

type Shipment implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  product: String
  speedGrade: String
  shipDate: Datetime
  carrierName: String!
  transitTime: String
  trackingUrl: String
  image: String
  id: BigInt!
  clientId: String
  clientSecret: String
  country: String
  website: String
}

"""A `Shipment` edge in the connection."""
type ShipmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Shipment` at the end of the edge."""
  node: Shipment!
}

"""Methods to use when ordering `Shipment`."""
enum ShipmentsOrderBy {
  NATURAL
  PRODUCT_ASC
  PRODUCT_DESC
  SPEED_GRADE_ASC
  SPEED_GRADE_DESC
  SHIP_DATE_ASC
  SHIP_DATE_DESC
  CARRIER_NAME_ASC
  CARRIER_NAME_DESC
  TRANSIT_TIME_ASC
  TRANSIT_TIME_DESC
  TRACKING_URL_ASC
  TRACKING_URL_DESC
  IMAGE_ASC
  IMAGE_DESC
  ID_ASC
  ID_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  CLIENT_SECRET_ASC
  CLIENT_SECRET_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Shipment` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ShipmentCondition {
  """Checks for equality with the object’s `product` field."""
  product: String

  """Checks for equality with the object’s `speedGrade` field."""
  speedGrade: String

  """Checks for equality with the object’s `shipDate` field."""
  shipDate: Datetime

  """Checks for equality with the object’s `carrierName` field."""
  carrierName: String

  """Checks for equality with the object’s `transitTime` field."""
  transitTime: String

  """Checks for equality with the object’s `trackingUrl` field."""
  trackingUrl: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `clientId` field."""
  clientId: String

  """Checks for equality with the object’s `clientSecret` field."""
  clientSecret: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `website` field."""
  website: String
}

"""A connection to a list of `State` values."""
type StatesConnection {
  """A list of `State` objects."""
  nodes: [State!]!

  """
  A list of edges which contains the `State` and cursor to aid in pagination.
  """
  edges: [StatesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `State` you could get from the connection."""
  totalCount: Int!
}

type State implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  description: String
  country: String
  image: String
  trainings: String
}

"""A `State` edge in the connection."""
type StatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `State` at the end of the edge."""
  node: State!
}

"""Methods to use when ordering `State`."""
enum StatesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  IMAGE_ASC
  IMAGE_DESC
  TRAININGS_ASC
  TRAININGS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `State` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StateCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `trainings` field."""
  trainings: String
}

"""A connection to a list of `Tag` values."""
type TagsConnection {
  """A list of `Tag` objects."""
  nodes: [Tag!]!

  """
  A list of edges which contains the `Tag` and cursor to aid in pagination.
  """
  edges: [TagsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Tag` you could get from the connection."""
  totalCount: Int!
}

type Tag implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  excerpt: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""A `Tag` edge in the connection."""
type TagsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Tag` at the end of the edge."""
  node: Tag!
}

"""Methods to use when ordering `Tag`."""
enum TagsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  EXCERPT_ASC
  EXCERPT_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TagCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `excerpt` field."""
  excerpt: String

  """Checks for equality with the object’s `categories` field."""
  categories: String

  """Checks for equality with the object’s `articles` field."""
  articles: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `users` field."""
  users: String
}

"""A connection to a list of `Tax` values."""
type TaxesConnection {
  """A list of `Tax` objects."""
  nodes: [Tax!]!

  """
  A list of edges which contains the `Tax` and cursor to aid in pagination.
  """
  edges: [TaxesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Tax` you could get from the connection."""
  totalCount: Int!
}

type Tax implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  taxIdentifier: String!
  postcode: String
  state: String
  country: String
  ratePercent: String
  taxDefault: String
  products: String
  taxRuleName: String
  taxCategory: String
}

"""A `Tax` edge in the connection."""
type TaxesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Tax` at the end of the edge."""
  node: Tax!
}

"""Methods to use when ordering `Tax`."""
enum TaxesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TAX_IDENTIFIER_ASC
  TAX_IDENTIFIER_DESC
  POSTCODE_ASC
  POSTCODE_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  RATE_PERCENT_ASC
  RATE_PERCENT_DESC
  TAX_DEFAULT_ASC
  TAX_DEFAULT_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  TAX_RULE_NAME_ASC
  TAX_RULE_NAME_DESC
  TAX_CATEGORY_ASC
  TAX_CATEGORY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Tax` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TaxCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `taxIdentifier` field."""
  taxIdentifier: String

  """Checks for equality with the object’s `postcode` field."""
  postcode: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `ratePercent` field."""
  ratePercent: String

  """Checks for equality with the object’s `taxDefault` field."""
  taxDefault: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `taxRuleName` field."""
  taxRuleName: String

  """Checks for equality with the object’s `taxCategory` field."""
  taxCategory: String
}

"""A connection to a list of `Theme` values."""
type ThemesConnection {
  """A list of `Theme` objects."""
  nodes: [Theme!]!

  """
  A list of edges which contains the `Theme` and cursor to aid in pagination.
  """
  edges: [ThemesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Theme` you could get from the connection."""
  totalCount: Int!
}

type Theme implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  title: String
  parentTheme: String
  themePath: String
  action: String
  websiteId: BigInt!
  websites: String!
}

"""A `Theme` edge in the connection."""
type ThemesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Theme` at the end of the edge."""
  node: Theme!
}

"""Methods to use when ordering `Theme`."""
enum ThemesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TITLE_ASC
  TITLE_DESC
  PARENT_THEME_ASC
  PARENT_THEME_DESC
  THEME_PATH_ASC
  THEME_PATH_DESC
  ACTION_ASC
  ACTION_DESC
  WEBSITE_ID_ASC
  WEBSITE_ID_DESC
  WEBSITES_ASC
  WEBSITES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Theme` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ThemeCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `title` field."""
  title: String

  """Checks for equality with the object’s `parentTheme` field."""
  parentTheme: String

  """Checks for equality with the object’s `themePath` field."""
  themePath: String

  """Checks for equality with the object’s `action` field."""
  action: String

  """Checks for equality with the object’s `websiteId` field."""
  websiteId: BigInt

  """Checks for equality with the object’s `websites` field."""
  websites: String
}

"""A connection to a list of `Ticketing` values."""
type TicketingsConnection {
  """A list of `Ticketing` objects."""
  nodes: [Ticketing!]!

  """
  A list of edges which contains the `Ticketing` and cursor to aid in pagination.
  """
  edges: [TicketingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Ticketing` you could get from the connection."""
  totalCount: Int!
}

type Ticketing implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  location: String
  date: String
  severity: String
  team: String
  requester: String
  requesterEmail: String
  content: String
  department: String
  media: String
  projects: String
  ticketType: String
  comment: String
  products: String
  priority: String
  status: String
  resolution: String
  assignedTo: String
  dateModified: Datetime
  accountName: String
  level: String
  projectsProjectsToticketing: String
}

"""A `Ticketing` edge in the connection."""
type TicketingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Ticketing` at the end of the edge."""
  node: Ticketing!
}

"""Methods to use when ordering `Ticketing`."""
enum TicketingsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  LOCATION_ASC
  LOCATION_DESC
  DATE_ASC
  DATE_DESC
  SEVERITY_ASC
  SEVERITY_DESC
  TEAM_ASC
  TEAM_DESC
  REQUESTER_ASC
  REQUESTER_DESC
  REQUESTER_EMAIL_ASC
  REQUESTER_EMAIL_DESC
  CONTENT_ASC
  CONTENT_DESC
  DEPARTMENT_ASC
  DEPARTMENT_DESC
  MEDIA_ASC
  MEDIA_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  TICKET_TYPE_ASC
  TICKET_TYPE_DESC
  COMMENT_ASC
  COMMENT_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  PRIORITY_ASC
  PRIORITY_DESC
  STATUS_ASC
  STATUS_DESC
  RESOLUTION_ASC
  RESOLUTION_DESC
  ASSIGNED_TO_ASC
  ASSIGNED_TO_DESC
  DATE_MODIFIED_ASC
  DATE_MODIFIED_DESC
  ACCOUNT_NAME_ASC
  ACCOUNT_NAME_DESC
  LEVEL_ASC
  LEVEL_DESC
  PROJECTS_PROJECTS_TOTICKETING_ASC
  PROJECTS_PROJECTS_TOTICKETING_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Ticketing` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TicketingCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `location` field."""
  location: String

  """Checks for equality with the object’s `date` field."""
  date: String

  """Checks for equality with the object’s `severity` field."""
  severity: String

  """Checks for equality with the object’s `team` field."""
  team: String

  """Checks for equality with the object’s `requester` field."""
  requester: String

  """Checks for equality with the object’s `requesterEmail` field."""
  requesterEmail: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `department` field."""
  department: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """Checks for equality with the object’s `projects` field."""
  projects: String

  """Checks for equality with the object’s `ticketType` field."""
  ticketType: String

  """Checks for equality with the object’s `comment` field."""
  comment: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `priority` field."""
  priority: String

  """Checks for equality with the object’s `status` field."""
  status: String

  """Checks for equality with the object’s `resolution` field."""
  resolution: String

  """Checks for equality with the object’s `assignedTo` field."""
  assignedTo: String

  """Checks for equality with the object’s `dateModified` field."""
  dateModified: Datetime

  """Checks for equality with the object’s `accountName` field."""
  accountName: String

  """Checks for equality with the object’s `level` field."""
  level: String

  """
  Checks for equality with the object’s `projectsProjectsToticketing` field.
  """
  projectsProjectsToticketing: String
}

"""A connection to a list of `Transaction` values."""
type TransactionsConnection {
  """A list of `Transaction` objects."""
  nodes: [Transaction!]!

  """
  A list of edges which contains the `Transaction` and cursor to aid in pagination.
  """
  edges: [TransactionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Transaction` you could get from the connection."""
  totalCount: Int!
}

type Transaction implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  orderId: Int!
  transactionId: Int!
  parentTransactionId: Int!
  created: Datetime
  paymentMethod: BigInt!
  closed: String
  customerPayment: String
  orders: String
}

"""A `Transaction` edge in the connection."""
type TransactionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Transaction` at the end of the edge."""
  node: Transaction!
}

"""Methods to use when ordering `Transaction`."""
enum TransactionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ORDER_ID_ASC
  ORDER_ID_DESC
  TRANSACTION_ID_ASC
  TRANSACTION_ID_DESC
  PARENT_TRANSACTION_ID_ASC
  PARENT_TRANSACTION_ID_DESC
  CREATED_ASC
  CREATED_DESC
  PAYMENT_METHOD_ASC
  PAYMENT_METHOD_DESC
  CLOSED_ASC
  CLOSED_DESC
  CUSTOMER_PAYMENT_ASC
  CUSTOMER_PAYMENT_DESC
  ORDERS_ASC
  ORDERS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Transaction` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TransactionCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `orderId` field."""
  orderId: Int

  """Checks for equality with the object’s `transactionId` field."""
  transactionId: Int

  """Checks for equality with the object’s `parentTransactionId` field."""
  parentTransactionId: Int

  """Checks for equality with the object’s `created` field."""
  created: Datetime

  """Checks for equality with the object’s `paymentMethod` field."""
  paymentMethod: BigInt

  """Checks for equality with the object’s `closed` field."""
  closed: String

  """Checks for equality with the object’s `customerPayment` field."""
  customerPayment: String

  """Checks for equality with the object’s `orders` field."""
  orders: String
}

"""A connection to a list of `UploadFile` values."""
type UploadFilesConnection {
  """A list of `UploadFile` objects."""
  nodes: [UploadFile!]!

  """
  A list of edges which contains the `UploadFile` and cursor to aid in pagination.
  """
  edges: [UploadFilesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UploadFile` you could get from the connection."""
  totalCount: Int!
}

type UploadFile implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: BigFloat!
  url: String!
  previewUrl: String
  provider: String!
  providerMetadata: JSON
  createdBy: Int
  updatedBy: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""A `UploadFile` edge in the connection."""
type UploadFilesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UploadFile` at the end of the edge."""
  node: UploadFile!
}

"""Methods to use when ordering `UploadFile`."""
enum UploadFilesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ALTERNATIVE_TEXT_ASC
  ALTERNATIVE_TEXT_DESC
  CAPTION_ASC
  CAPTION_DESC
  WIDTH_ASC
  WIDTH_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  FORMATS_ASC
  FORMATS_DESC
  HASH_ASC
  HASH_DESC
  EXT_ASC
  EXT_DESC
  MIME_ASC
  MIME_DESC
  SIZE_ASC
  SIZE_DESC
  URL_ASC
  URL_DESC
  PREVIEW_URL_ASC
  PREVIEW_URL_DESC
  PROVIDER_ASC
  PROVIDER_DESC
  PROVIDER_METADATA_ASC
  PROVIDER_METADATA_DESC
  CREATED_BY_ASC
  CREATED_BY_DESC
  UPDATED_BY_ASC
  UPDATED_BY_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `UploadFile` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input UploadFileCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `alternativeText` field."""
  alternativeText: String

  """Checks for equality with the object’s `caption` field."""
  caption: String

  """Checks for equality with the object’s `width` field."""
  width: Int

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `formats` field."""
  formats: JSON

  """Checks for equality with the object’s `hash` field."""
  hash: String

  """Checks for equality with the object’s `ext` field."""
  ext: String

  """Checks for equality with the object’s `mime` field."""
  mime: String

  """Checks for equality with the object’s `size` field."""
  size: BigFloat

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `previewUrl` field."""
  previewUrl: String

  """Checks for equality with the object’s `provider` field."""
  provider: String

  """Checks for equality with the object’s `providerMetadata` field."""
  providerMetadata: JSON

  """Checks for equality with the object’s `createdBy` field."""
  createdBy: Int

  """Checks for equality with the object’s `updatedBy` field."""
  updatedBy: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User!]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  username: String!
  firstName: String!
  lastName: String
  email: String!
  password: String!
  interfaceLocale: String
  value: String
  permissions: String
  createdAt: Datetime
  emails: String
  mediamanager: String
  messages: String
  projects: String
  workspaces: String
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USERNAME_ASC
  USERNAME_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  EMAIL_ASC
  EMAIL_DESC
  PASSWORD_ASC
  PASSWORD_DESC
  INTERFACE_LOCALE_ASC
  INTERFACE_LOCALE_DESC
  VALUE_ASC
  VALUE_DESC
  PERMISSIONS_ASC
  PERMISSIONS_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  EMAILS_ASC
  EMAILS_DESC
  MEDIAMANAGER_ASC
  MEDIAMANAGER_DESC
  MESSAGES_ASC
  MESSAGES_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  WORKSPACES_ASC
  WORKSPACES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `username` field."""
  username: String

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `password` field."""
  password: String

  """Checks for equality with the object’s `interfaceLocale` field."""
  interfaceLocale: String

  """Checks for equality with the object’s `value` field."""
  value: String

  """Checks for equality with the object’s `permissions` field."""
  permissions: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `emails` field."""
  emails: String

  """Checks for equality with the object’s `mediamanager` field."""
  mediamanager: String

  """Checks for equality with the object’s `messages` field."""
  messages: String

  """Checks for equality with the object’s `projects` field."""
  projects: String

  """Checks for equality with the object’s `workspaces` field."""
  workspaces: String
}

"""A connection to a list of `Vendor` values."""
type VendorsConnection {
  """A list of `Vendor` objects."""
  nodes: [Vendor!]!

  """
  A list of edges which contains the `Vendor` and cursor to aid in pagination.
  """
  edges: [VendorsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Vendor` you could get from the connection."""
  totalCount: Int!
}

type Vendor implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: Int!
  name: String!
  description: String
  image: String
  website: String
  products: String
  articles: String
  customers: String
  comments: String
  coupons: String
  categories: String
  polls: String
  quotes: String
  reviews: String
  giftCertificates: String
  rating: String
  tags: String
  users: String
  invoices: String
  reports: String
  rewardPoints: String
  specialDiscounts: String
  statistics: String
  stocks: String
  country: String
  physicalStore: String
  type: String
  workspaces: String
}

"""A `Vendor` edge in the connection."""
type VendorsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Vendor` at the end of the edge."""
  node: Vendor!
}

"""Methods to use when ordering `Vendor`."""
enum VendorsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  IMAGE_ASC
  IMAGE_DESC
  WEBSITE_ASC
  WEBSITE_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  ARTICLES_ASC
  ARTICLES_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  COMMENTS_ASC
  COMMENTS_DESC
  COUPONS_ASC
  COUPONS_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  POLLS_ASC
  POLLS_DESC
  QUOTES_ASC
  QUOTES_DESC
  REVIEWS_ASC
  REVIEWS_DESC
  GIFT_CERTIFICATES_ASC
  GIFT_CERTIFICATES_DESC
  RATING_ASC
  RATING_DESC
  TAGS_ASC
  TAGS_DESC
  USERS_ASC
  USERS_DESC
  INVOICES_ASC
  INVOICES_DESC
  REPORTS_ASC
  REPORTS_DESC
  REWARD_POINTS_ASC
  REWARD_POINTS_DESC
  SPECIAL_DISCOUNTS_ASC
  SPECIAL_DISCOUNTS_DESC
  STATISTICS_ASC
  STATISTICS_DESC
  STOCKS_ASC
  STOCKS_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  PHYSICAL_STORE_ASC
  PHYSICAL_STORE_DESC
  TYPE_ASC
  TYPE_DESC
  WORKSPACES_ASC
  WORKSPACES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Vendor` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input VendorCondition {
  """Checks for equality with the object’s `id` field."""
  id: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `website` field."""
  website: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `articles` field."""
  articles: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `comments` field."""
  comments: String

  """Checks for equality with the object’s `coupons` field."""
  coupons: String

  """Checks for equality with the object’s `categories` field."""
  categories: String

  """Checks for equality with the object’s `polls` field."""
  polls: String

  """Checks for equality with the object’s `quotes` field."""
  quotes: String

  """Checks for equality with the object’s `reviews` field."""
  reviews: String

  """Checks for equality with the object’s `giftCertificates` field."""
  giftCertificates: String

  """Checks for equality with the object’s `rating` field."""
  rating: String

  """Checks for equality with the object’s `tags` field."""
  tags: String

  """Checks for equality with the object’s `users` field."""
  users: String

  """Checks for equality with the object’s `invoices` field."""
  invoices: String

  """Checks for equality with the object’s `reports` field."""
  reports: String

  """Checks for equality with the object’s `rewardPoints` field."""
  rewardPoints: String

  """Checks for equality with the object’s `specialDiscounts` field."""
  specialDiscounts: String

  """Checks for equality with the object’s `statistics` field."""
  statistics: String

  """Checks for equality with the object’s `stocks` field."""
  stocks: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `physicalStore` field."""
  physicalStore: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `workspaces` field."""
  workspaces: String
}

"""A connection to a list of `Visit` values."""
type VisitsConnection {
  """A list of `Visit` objects."""
  nodes: [Visit!]!

  """
  A list of edges which contains the `Visit` and cursor to aid in pagination.
  """
  edges: [VisitsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Visit` you could get from the connection."""
  totalCount: Int!
}

type Visit implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  location: String
  username: String
  reason: String
  content: String
  emergency: String
  startDate: String
  endDate: String
  task: String
  meeting: String
}

"""A `Visit` edge in the connection."""
type VisitsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Visit` at the end of the edge."""
  node: Visit!
}

"""Methods to use when ordering `Visit`."""
enum VisitsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  LOCATION_ASC
  LOCATION_DESC
  USERNAME_ASC
  USERNAME_DESC
  REASON_ASC
  REASON_DESC
  CONTENT_ASC
  CONTENT_DESC
  EMERGENCY_ASC
  EMERGENCY_DESC
  START_DATE_ASC
  START_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  TASK_ASC
  TASK_DESC
  MEETING_ASC
  MEETING_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Visit` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input VisitCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `location` field."""
  location: String

  """Checks for equality with the object’s `username` field."""
  username: String

  """Checks for equality with the object’s `reason` field."""
  reason: String

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `emergency` field."""
  emergency: String

  """Checks for equality with the object’s `startDate` field."""
  startDate: String

  """Checks for equality with the object’s `endDate` field."""
  endDate: String

  """Checks for equality with the object’s `task` field."""
  task: String

  """Checks for equality with the object’s `meeting` field."""
  meeting: String
}

"""A connection to a list of `Warehouse` values."""
type WarehousesConnection {
  """A list of `Warehouse` objects."""
  nodes: [Warehouse!]!

  """
  A list of edges which contains the `Warehouse` and cursor to aid in pagination.
  """
  edges: [WarehousesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Warehouse` you could get from the connection."""
  totalCount: Int!
}

type Warehouse implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  description: String
  city: String
  state: String
  country: String
  postal: String
  status: String
  image: String
  products: String
  category: String
  isPublic: String
}

"""A `Warehouse` edge in the connection."""
type WarehousesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Warehouse` at the end of the edge."""
  node: Warehouse!
}

"""Methods to use when ordering `Warehouse`."""
enum WarehousesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CITY_ASC
  CITY_DESC
  STATE_ASC
  STATE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  POSTAL_ASC
  POSTAL_DESC
  STATUS_ASC
  STATUS_DESC
  IMAGE_ASC
  IMAGE_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Warehouse` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input WarehouseCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `city` field."""
  city: String

  """Checks for equality with the object’s `state` field."""
  state: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `postal` field."""
  postal: String

  """Checks for equality with the object’s `status` field."""
  status: String

  """Checks for equality with the object’s `image` field."""
  image: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: String
}

"""A connection to a list of `Webhook` values."""
type WebhooksConnection {
  """A list of `Webhook` objects."""
  nodes: [Webhook!]!

  """
  A list of edges which contains the `Webhook` and cursor to aid in pagination.
  """
  edges: [WebhooksEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Webhook` you could get from the connection."""
  totalCount: Int!
}

type Webhook implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String!
  url: String!
  headers: String
  create: String
  retrieve: String
  update: String
  delete: String
  publish: String
  unpublish: String
}

"""A `Webhook` edge in the connection."""
type WebhooksEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Webhook` at the end of the edge."""
  node: Webhook!
}

"""Methods to use when ordering `Webhook`."""
enum WebhooksOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  URL_ASC
  URL_DESC
  HEADERS_ASC
  HEADERS_DESC
  CREATE_ASC
  CREATE_DESC
  RETRIEVE_ASC
  RETRIEVE_DESC
  UPDATE_ASC
  UPDATE_DESC
  DELETE_ASC
  DELETE_DESC
  PUBLISH_ASC
  PUBLISH_DESC
  UNPUBLISH_ASC
  UNPUBLISH_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Webhook` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input WebhookCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `headers` field."""
  headers: String

  """Checks for equality with the object’s `create` field."""
  create: String

  """Checks for equality with the object’s `retrieve` field."""
  retrieve: String

  """Checks for equality with the object’s `update` field."""
  update: String

  """Checks for equality with the object’s `delete` field."""
  delete: String

  """Checks for equality with the object’s `publish` field."""
  publish: String

  """Checks for equality with the object’s `unpublish` field."""
  unpublish: String
}

"""A connection to a list of `Website` values."""
type WebsitesConnection {
  """A list of `Website` objects."""
  nodes: [Website!]!

  """
  A list of edges which contains the `Website` and cursor to aid in pagination.
  """
  edges: [WebsitesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Website` you could get from the connection."""
  totalCount: Int!
}

type Website implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  url: String
  shop: String
  store: String
  category: String
  themes: String
  image: String
}

"""A `Website` edge in the connection."""
type WebsitesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Website` at the end of the edge."""
  node: Website!
}

"""Methods to use when ordering `Website`."""
enum WebsitesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  URL_ASC
  URL_DESC
  SHOP_ASC
  SHOP_DESC
  STORE_ASC
  STORE_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  THEMES_ASC
  THEMES_DESC
  IMAGE_ASC
  IMAGE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Website` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input WebsiteCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `shop` field."""
  shop: String

  """Checks for equality with the object’s `store` field."""
  store: String

  """Checks for equality with the object’s `category` field."""
  category: String

  """Checks for equality with the object’s `themes` field."""
  themes: String

  """Checks for equality with the object’s `image` field."""
  image: String
}

"""A connection to a list of `Wishlist` values."""
type WishlistsConnection {
  """A list of `Wishlist` objects."""
  nodes: [Wishlist!]!

  """
  A list of edges which contains the `Wishlist` and cursor to aid in pagination.
  """
  edges: [WishlistsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Wishlist` you could get from the connection."""
  totalCount: Int!
}

type Wishlist implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  customers: String
  visibility: String
  products: String
  quantity: String
  occassions: String
}

"""A `Wishlist` edge in the connection."""
type WishlistsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Wishlist` at the end of the edge."""
  node: Wishlist!
}

"""Methods to use when ordering `Wishlist`."""
enum WishlistsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  VISIBILITY_ASC
  VISIBILITY_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  QUANTITY_ASC
  QUANTITY_DESC
  OCCASSIONS_ASC
  OCCASSIONS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Wishlist` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input WishlistCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `customers` field."""
  customers: String

  """Checks for equality with the object’s `visibility` field."""
  visibility: String

  """Checks for equality with the object’s `products` field."""
  products: String

  """Checks for equality with the object’s `quantity` field."""
  quantity: String

  """Checks for equality with the object’s `occassions` field."""
  occassions: String
}

"""A connection to a list of `Workspace` values."""
type WorkspacesConnection {
  """A list of `Workspace` objects."""
  nodes: [Workspace!]!

  """
  A list of edges which contains the `Workspace` and cursor to aid in pagination.
  """
  edges: [WorkspacesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Workspace` you could get from the connection."""
  totalCount: Int!
}

type Workspace implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  code: String
  name: String
  description: String
  customers: Int
  users: Int
  products: BigInt
  tasks: BigInt
  brands: BigInt
  shops: Int
  category: Int
  isPublic: Boolean
  projects: BigInt
  author: String
  media: String
  brandsBrandsToworkspaces: String
  categories: String
  customersCustomersToworkspaces: String
  productsProductsToworkspaces: String
  projectsProjectsToworkspaces: String
  shopsShopsToworkspaces: String
  tasksTasksToworkspaces: String
  usersUsersToworkspaces: String
}

"""A `Workspace` edge in the connection."""
type WorkspacesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Workspace` at the end of the edge."""
  node: Workspace!
}

"""Methods to use when ordering `Workspace`."""
enum WorkspacesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CODE_ASC
  CODE_DESC
  NAME_ASC
  NAME_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  CUSTOMERS_ASC
  CUSTOMERS_DESC
  USERS_ASC
  USERS_DESC
  PRODUCTS_ASC
  PRODUCTS_DESC
  TASKS_ASC
  TASKS_DESC
  BRANDS_ASC
  BRANDS_DESC
  SHOPS_ASC
  SHOPS_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  PROJECTS_ASC
  PROJECTS_DESC
  AUTHOR_ASC
  AUTHOR_DESC
  MEDIA_ASC
  MEDIA_DESC
  BRANDS_BRANDS_TOWORKSPACES_ASC
  BRANDS_BRANDS_TOWORKSPACES_DESC
  CATEGORIES_ASC
  CATEGORIES_DESC
  CUSTOMERS_CUSTOMERS_TOWORKSPACES_ASC
  CUSTOMERS_CUSTOMERS_TOWORKSPACES_DESC
  PRODUCTS_PRODUCTS_TOWORKSPACES_ASC
  PRODUCTS_PRODUCTS_TOWORKSPACES_DESC
  PROJECTS_PROJECTS_TOWORKSPACES_ASC
  PROJECTS_PROJECTS_TOWORKSPACES_DESC
  SHOPS_SHOPS_TOWORKSPACES_ASC
  SHOPS_SHOPS_TOWORKSPACES_DESC
  TASKS_TASKS_TOWORKSPACES_ASC
  TASKS_TASKS_TOWORKSPACES_DESC
  USERS_USERS_TOWORKSPACES_ASC
  USERS_USERS_TOWORKSPACES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Workspace` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input WorkspaceCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `customers` field."""
  customers: Int

  """Checks for equality with the object’s `users` field."""
  users: Int

  """Checks for equality with the object’s `products` field."""
  products: BigInt

  """Checks for equality with the object’s `tasks` field."""
  tasks: BigInt

  """Checks for equality with the object’s `brands` field."""
  brands: BigInt

  """Checks for equality with the object’s `shops` field."""
  shops: Int

  """Checks for equality with the object’s `category` field."""
  category: Int

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: Boolean

  """Checks for equality with the object’s `projects` field."""
  projects: BigInt

  """Checks for equality with the object’s `author` field."""
  author: String

  """Checks for equality with the object’s `media` field."""
  media: String

  """
  Checks for equality with the object’s `brandsBrandsToworkspaces` field.
  """
  brandsBrandsToworkspaces: String

  """Checks for equality with the object’s `categories` field."""
  categories: String

  """
  Checks for equality with the object’s `customersCustomersToworkspaces` field.
  """
  customersCustomersToworkspaces: String

  """
  Checks for equality with the object’s `productsProductsToworkspaces` field.
  """
  productsProductsToworkspaces: String

  """
  Checks for equality with the object’s `projectsProjectsToworkspaces` field.
  """
  projectsProjectsToworkspaces: String

  """Checks for equality with the object’s `shopsShopsToworkspaces` field."""
  shopsShopsToworkspaces: String

  """Checks for equality with the object’s `tasksTasksToworkspaces` field."""
  tasksTasksToworkspaces: String

  """Checks for equality with the object’s `usersUsersToworkspaces` field."""
  usersUsersToworkspaces: String
}

"""A connection to a list of `Zone` values."""
type ZonesConnection {
  """A list of `Zone` objects."""
  nodes: [Zone!]!

  """
  A list of edges which contains the `Zone` and cursor to aid in pagination.
  """
  edges: [ZonesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Zone` you could get from the connection."""
  totalCount: Int!
}

type Zone implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime
  name: String
  updatedAt: Datetime
  scope: String
  type: String
  country: String
  code: String
}

"""A `Zone` edge in the connection."""
type ZonesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Zone` at the end of the edge."""
  node: Zone!
}

"""Methods to use when ordering `Zone`."""
enum ZonesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  NAME_ASC
  NAME_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  SCOPE_ASC
  SCOPE_DESC
  TYPE_ASC
  TYPE_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  CODE_ASC
  CODE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Zone` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ZoneCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `scope` field."""
  scope: String

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `code` field."""
  code: String
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `_PrismaMigration`."""
  createPrismaMigration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePrismaMigrationInput!
  ): CreatePrismaMigrationPayload

  """Creates a single `Agreement`."""
  createAgreement(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAgreementInput!
  ): CreateAgreementPayload

  """Creates a single `Apitoken`."""
  createApitoken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateApitokenInput!
  ): CreateApitokenPayload

  """Creates a single `Article`."""
  createArticle(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateArticleInput!
  ): CreateArticlePayload

  """Creates a single `Attribute`."""
  createAttribute(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAttributeInput!
  ): CreateAttributePayload

  """Creates a single `Brand`."""
  createBrand(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateBrandInput!
  ): CreateBrandPayload

  """Creates a single `Category`."""
  createCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCategoryInput!
  ): CreateCategoryPayload

  """Creates a single `Channel`."""
  createChannel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateChannelInput!
  ): CreateChannelPayload

  """Creates a single `Checklist`."""
  createChecklist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateChecklistInput!
  ): CreateChecklistPayload

  """Creates a single `City`."""
  createCity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCityInput!
  ): CreateCityPayload

  """Creates a single `Collection`."""
  createCollection(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCollectionInput!
  ): CreateCollectionPayload

  """Creates a single `ContentType`."""
  createContentType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateContentTypeInput!
  ): CreateContentTypePayload

  """Creates a single `Country`."""
  createCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCountryInput!
  ): CreateCountryPayload

  """Creates a single `Currency`."""
  createCurrency(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCurrencyInput!
  ): CreateCurrencyPayload

  """Creates a single `Customer`."""
  createCustomer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCustomerInput!
  ): CreateCustomerPayload

  """Creates a single `Dashboard`."""
  createDashboard(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateDashboardInput!
  ): CreateDashboardPayload

  """Creates a single `Deepdive`."""
  createDeepdive(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateDeepdiveInput!
  ): CreateDeepdivePayload

  """Creates a single `Discount`."""
  createDiscount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateDiscountInput!
  ): CreateDiscountPayload

  """Creates a single `Endofshift`."""
  createEndofshift(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateEndofshiftInput!
  ): CreateEndofshiftPayload

  """Creates a single `Event`."""
  createEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateEventInput!
  ): CreateEventPayload

  """Creates a single `Fullfillment`."""
  createFullfillment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateFullfillmentInput!
  ): CreateFullfillmentPayload

  """Creates a single `Glossary`."""
  createGlossary(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGlossaryInput!
  ): CreateGlossaryPayload

  """Creates a single `Integration`."""
  createIntegration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateIntegrationInput!
  ): CreateIntegrationPayload

  """Creates a single `Internalization`."""
  createInternalization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateInternalizationInput!
  ): CreateInternalizationPayload

  """Creates a single `Invoice`."""
  createInvoice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateInvoiceInput!
  ): CreateInvoicePayload

  """Creates a single `LogIn`."""
  createLogIn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLogInInput!
  ): CreateLogInPayload

  """Creates a single `Manufacturer`."""
  createManufacturer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateManufacturerInput!
  ): CreateManufacturerPayload

  """Creates a single `Mediamanager`."""
  createMediamanager(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMediamanagerInput!
  ): CreateMediamanagerPayload

  """Creates a single `Newsletter`."""
  createNewsletter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateNewsletterInput!
  ): CreateNewsletterPayload

  """Creates a single `Ooto`."""
  createOoto(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOotoInput!
  ): CreateOotoPayload

  """Creates a single `Order`."""
  createOrder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOrderInput!
  ): CreateOrderPayload

  """Creates a single `Page`."""
  createPage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePageInput!
  ): CreatePagePayload

  """Creates a single `Partner`."""
  createPartner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePartnerInput!
  ): CreatePartnerPayload

  """Creates a single `Payment`."""
  createPayment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePaymentInput!
  ): CreatePaymentPayload

  """Creates a single `Permission`."""
  createPermission(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePermissionInput!
  ): CreatePermissionPayload

  """Creates a single `Plugin`."""
  createPlugin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePluginInput!
  ): CreatePluginPayload

  """Creates a single `ProductType`."""
  createProductType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProductTypeInput!
  ): CreateProductTypePayload

  """Creates a single `Product`."""
  createProduct(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProductInput!
  ): CreateProductPayload

  """Creates a single `Project`."""
  createProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectInput!
  ): CreateProjectPayload

  """Creates a single `Provider`."""
  createProvider(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProviderInput!
  ): CreateProviderPayload

  """Creates a single `Quote`."""
  createQuote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateQuoteInput!
  ): CreateQuotePayload

  """Creates a single `Return`."""
  createReturn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateReturnInput!
  ): CreateReturnPayload

  """Creates a single `Review`."""
  createReview(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateReviewInput!
  ): CreateReviewPayload

  """Creates a single `Reward`."""
  createReward(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateRewardInput!
  ): CreateRewardPayload

  """Creates a single `Role`."""
  createRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateRoleInput!
  ): CreateRolePayload

  """Creates a single `Scheduler`."""
  createScheduler(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSchedulerInput!
  ): CreateSchedulerPayload

  """Creates a single `Segment`."""
  createSegment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSegmentInput!
  ): CreateSegmentPayload

  """Creates a single `Setting`."""
  createSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSettingInput!
  ): CreateSettingPayload

  """Creates a single `Shipment`."""
  createShipment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateShipmentInput!
  ): CreateShipmentPayload

  """Creates a single `State`."""
  createState(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStateInput!
  ): CreateStatePayload

  """Creates a single `Tag`."""
  createTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTagInput!
  ): CreateTagPayload

  """Creates a single `Tax`."""
  createTax(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTaxInput!
  ): CreateTaxPayload

  """Creates a single `Theme`."""
  createTheme(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateThemeInput!
  ): CreateThemePayload

  """Creates a single `Ticketing`."""
  createTicketing(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTicketingInput!
  ): CreateTicketingPayload

  """Creates a single `Transaction`."""
  createTransaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTransactionInput!
  ): CreateTransactionPayload

  """Creates a single `UploadFile`."""
  createUploadFile(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUploadFileInput!
  ): CreateUploadFilePayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Creates a single `Vendor`."""
  createVendor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVendorInput!
  ): CreateVendorPayload

  """Creates a single `Visit`."""
  createVisit(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVisitInput!
  ): CreateVisitPayload

  """Creates a single `Warehouse`."""
  createWarehouse(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateWarehouseInput!
  ): CreateWarehousePayload

  """Creates a single `Webhook`."""
  createWebhook(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateWebhookInput!
  ): CreateWebhookPayload

  """Creates a single `Website`."""
  createWebsite(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateWebsiteInput!
  ): CreateWebsitePayload

  """Creates a single `Wishlist`."""
  createWishlist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateWishlistInput!
  ): CreateWishlistPayload

  """Creates a single `Workspace`."""
  createWorkspace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateWorkspaceInput!
  ): CreateWorkspacePayload

  """Creates a single `Zone`."""
  createZone(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateZoneInput!
  ): CreateZonePayload

  """
  Updates a single `_PrismaMigration` using its globally unique id and a patch.
  """
  updatePrismaMigrationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePrismaMigrationByNodeIdInput!
  ): UpdatePrismaMigrationPayload

  """Updates a single `_PrismaMigration` using a unique key and a patch."""
  updatePrismaMigration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePrismaMigrationInput!
  ): UpdatePrismaMigrationPayload

  """Updates a single `Agreement` using its globally unique id and a patch."""
  updateAgreementByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAgreementByNodeIdInput!
  ): UpdateAgreementPayload

  """Updates a single `Agreement` using a unique key and a patch."""
  updateAgreement(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAgreementInput!
  ): UpdateAgreementPayload

  """Updates a single `Apitoken` using its globally unique id and a patch."""
  updateApitokenByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateApitokenByNodeIdInput!
  ): UpdateApitokenPayload

  """Updates a single `Apitoken` using a unique key and a patch."""
  updateApitoken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateApitokenInput!
  ): UpdateApitokenPayload

  """Updates a single `Article` using its globally unique id and a patch."""
  updateArticleByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateArticleByNodeIdInput!
  ): UpdateArticlePayload

  """Updates a single `Article` using a unique key and a patch."""
  updateArticle(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateArticleInput!
  ): UpdateArticlePayload

  """Updates a single `Attribute` using its globally unique id and a patch."""
  updateAttributeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAttributeByNodeIdInput!
  ): UpdateAttributePayload

  """Updates a single `Attribute` using a unique key and a patch."""
  updateAttribute(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAttributeInput!
  ): UpdateAttributePayload

  """Updates a single `Brand` using its globally unique id and a patch."""
  updateBrandByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBrandByNodeIdInput!
  ): UpdateBrandPayload

  """Updates a single `Brand` using a unique key and a patch."""
  updateBrand(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBrandInput!
  ): UpdateBrandPayload

  """Updates a single `Category` using its globally unique id and a patch."""
  updateCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCategoryByNodeIdInput!
  ): UpdateCategoryPayload

  """Updates a single `Category` using a unique key and a patch."""
  updateCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCategoryInput!
  ): UpdateCategoryPayload

  """Updates a single `Channel` using its globally unique id and a patch."""
  updateChannelByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateChannelByNodeIdInput!
  ): UpdateChannelPayload

  """Updates a single `Channel` using a unique key and a patch."""
  updateChannel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateChannelInput!
  ): UpdateChannelPayload

  """Updates a single `Checklist` using its globally unique id and a patch."""
  updateChecklistByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateChecklistByNodeIdInput!
  ): UpdateChecklistPayload

  """Updates a single `Checklist` using a unique key and a patch."""
  updateChecklist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateChecklistInput!
  ): UpdateChecklistPayload

  """Updates a single `City` using its globally unique id and a patch."""
  updateCityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCityByNodeIdInput!
  ): UpdateCityPayload

  """Updates a single `City` using a unique key and a patch."""
  updateCity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCityInput!
  ): UpdateCityPayload

  """
  Updates a single `Collection` using its globally unique id and a patch.
  """
  updateCollectionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCollectionByNodeIdInput!
  ): UpdateCollectionPayload

  """Updates a single `Collection` using a unique key and a patch."""
  updateCollection(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCollectionInput!
  ): UpdateCollectionPayload

  """
  Updates a single `ContentType` using its globally unique id and a patch.
  """
  updateContentTypeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContentTypeByNodeIdInput!
  ): UpdateContentTypePayload

  """Updates a single `ContentType` using a unique key and a patch."""
  updateContentType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContentTypeInput!
  ): UpdateContentTypePayload

  """Updates a single `Country` using its globally unique id and a patch."""
  updateCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCountryByNodeIdInput!
  ): UpdateCountryPayload

  """Updates a single `Country` using a unique key and a patch."""
  updateCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCountryInput!
  ): UpdateCountryPayload

  """Updates a single `Currency` using its globally unique id and a patch."""
  updateCurrencyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyByNodeIdInput!
  ): UpdateCurrencyPayload

  """Updates a single `Currency` using a unique key and a patch."""
  updateCurrency(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyInput!
  ): UpdateCurrencyPayload

  """Updates a single `Customer` using its globally unique id and a patch."""
  updateCustomerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCustomerByNodeIdInput!
  ): UpdateCustomerPayload

  """Updates a single `Customer` using a unique key and a patch."""
  updateCustomer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCustomerInput!
  ): UpdateCustomerPayload

  """Updates a single `Dashboard` using its globally unique id and a patch."""
  updateDashboardByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDashboardByNodeIdInput!
  ): UpdateDashboardPayload

  """Updates a single `Dashboard` using a unique key and a patch."""
  updateDashboard(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDashboardInput!
  ): UpdateDashboardPayload

  """Updates a single `Dashboard` using a unique key and a patch."""
  updateDashboardByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDashboardByNameInput!
  ): UpdateDashboardPayload

  """Updates a single `Deepdive` using its globally unique id and a patch."""
  updateDeepdiveByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDeepdiveByNodeIdInput!
  ): UpdateDeepdivePayload

  """Updates a single `Deepdive` using a unique key and a patch."""
  updateDeepdive(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDeepdiveInput!
  ): UpdateDeepdivePayload

  """Updates a single `Discount` using its globally unique id and a patch."""
  updateDiscountByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDiscountByNodeIdInput!
  ): UpdateDiscountPayload

  """Updates a single `Discount` using a unique key and a patch."""
  updateDiscount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDiscountInput!
  ): UpdateDiscountPayload

  """
  Updates a single `Endofshift` using its globally unique id and a patch.
  """
  updateEndofshiftByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEndofshiftByNodeIdInput!
  ): UpdateEndofshiftPayload

  """Updates a single `Endofshift` using a unique key and a patch."""
  updateEndofshift(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEndofshiftInput!
  ): UpdateEndofshiftPayload

  """Updates a single `Event` using its globally unique id and a patch."""
  updateEventByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEventByNodeIdInput!
  ): UpdateEventPayload

  """Updates a single `Event` using a unique key and a patch."""
  updateEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEventInput!
  ): UpdateEventPayload

  """
  Updates a single `Fullfillment` using its globally unique id and a patch.
  """
  updateFullfillmentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFullfillmentByNodeIdInput!
  ): UpdateFullfillmentPayload

  """Updates a single `Fullfillment` using a unique key and a patch."""
  updateFullfillment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFullfillmentInput!
  ): UpdateFullfillmentPayload

  """Updates a single `Glossary` using its globally unique id and a patch."""
  updateGlossaryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGlossaryByNodeIdInput!
  ): UpdateGlossaryPayload

  """Updates a single `Glossary` using a unique key and a patch."""
  updateGlossary(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGlossaryInput!
  ): UpdateGlossaryPayload

  """
  Updates a single `Integration` using its globally unique id and a patch.
  """
  updateIntegrationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateIntegrationByNodeIdInput!
  ): UpdateIntegrationPayload

  """Updates a single `Integration` using a unique key and a patch."""
  updateIntegration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateIntegrationInput!
  ): UpdateIntegrationPayload

  """
  Updates a single `Internalization` using its globally unique id and a patch.
  """
  updateInternalizationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInternalizationByNodeIdInput!
  ): UpdateInternalizationPayload

  """Updates a single `Internalization` using a unique key and a patch."""
  updateInternalization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInternalizationInput!
  ): UpdateInternalizationPayload

  """Updates a single `Invoice` using its globally unique id and a patch."""
  updateInvoiceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInvoiceByNodeIdInput!
  ): UpdateInvoicePayload

  """Updates a single `Invoice` using a unique key and a patch."""
  updateInvoice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInvoiceInput!
  ): UpdateInvoicePayload

  """Updates a single `LogIn` using its globally unique id and a patch."""
  updateLogInByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLogInByNodeIdInput!
  ): UpdateLogInPayload

  """Updates a single `LogIn` using a unique key and a patch."""
  updateLogIn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLogInInput!
  ): UpdateLogInPayload

  """
  Updates a single `Manufacturer` using its globally unique id and a patch.
  """
  updateManufacturerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateManufacturerByNodeIdInput!
  ): UpdateManufacturerPayload

  """Updates a single `Manufacturer` using a unique key and a patch."""
  updateManufacturer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateManufacturerInput!
  ): UpdateManufacturerPayload

  """
  Updates a single `Mediamanager` using its globally unique id and a patch.
  """
  updateMediamanagerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMediamanagerByNodeIdInput!
  ): UpdateMediamanagerPayload

  """Updates a single `Mediamanager` using a unique key and a patch."""
  updateMediamanager(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMediamanagerInput!
  ): UpdateMediamanagerPayload

  """
  Updates a single `Newsletter` using its globally unique id and a patch.
  """
  updateNewsletterByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNewsletterByNodeIdInput!
  ): UpdateNewsletterPayload

  """Updates a single `Newsletter` using a unique key and a patch."""
  updateNewsletter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNewsletterInput!
  ): UpdateNewsletterPayload

  """Updates a single `Ooto` using its globally unique id and a patch."""
  updateOotoByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOotoByNodeIdInput!
  ): UpdateOotoPayload

  """Updates a single `Ooto` using a unique key and a patch."""
  updateOoto(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOotoInput!
  ): UpdateOotoPayload

  """Updates a single `Order` using its globally unique id and a patch."""
  updateOrderByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOrderByNodeIdInput!
  ): UpdateOrderPayload

  """Updates a single `Order` using a unique key and a patch."""
  updateOrder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOrderInput!
  ): UpdateOrderPayload

  """Updates a single `Page` using its globally unique id and a patch."""
  updatePageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePageByNodeIdInput!
  ): UpdatePagePayload

  """Updates a single `Page` using a unique key and a patch."""
  updatePage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePageInput!
  ): UpdatePagePayload

  """Updates a single `Partner` using its globally unique id and a patch."""
  updatePartnerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePartnerByNodeIdInput!
  ): UpdatePartnerPayload

  """Updates a single `Partner` using a unique key and a patch."""
  updatePartner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePartnerInput!
  ): UpdatePartnerPayload

  """Updates a single `Payment` using its globally unique id and a patch."""
  updatePaymentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePaymentByNodeIdInput!
  ): UpdatePaymentPayload

  """Updates a single `Payment` using a unique key and a patch."""
  updatePayment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePaymentInput!
  ): UpdatePaymentPayload

  """
  Updates a single `Permission` using its globally unique id and a patch.
  """
  updatePermissionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePermissionByNodeIdInput!
  ): UpdatePermissionPayload

  """Updates a single `Permission` using a unique key and a patch."""
  updatePermission(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePermissionInput!
  ): UpdatePermissionPayload

  """Updates a single `Plugin` using its globally unique id and a patch."""
  updatePluginByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePluginByNodeIdInput!
  ): UpdatePluginPayload

  """Updates a single `Plugin` using a unique key and a patch."""
  updatePlugin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePluginInput!
  ): UpdatePluginPayload

  """
  Updates a single `ProductType` using its globally unique id and a patch.
  """
  updateProductTypeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductTypeByNodeIdInput!
  ): UpdateProductTypePayload

  """Updates a single `ProductType` using a unique key and a patch."""
  updateProductType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductTypeInput!
  ): UpdateProductTypePayload

  """Updates a single `Product` using its globally unique id and a patch."""
  updateProductByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductByNodeIdInput!
  ): UpdateProductPayload

  """Updates a single `Product` using a unique key and a patch."""
  updateProduct(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProductInput!
  ): UpdateProductPayload

  """Updates a single `Project` using its globally unique id and a patch."""
  updateProjectByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectByNodeIdInput!
  ): UpdateProjectPayload

  """Updates a single `Project` using a unique key and a patch."""
  updateProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectInput!
  ): UpdateProjectPayload

  """Updates a single `Provider` using its globally unique id and a patch."""
  updateProviderByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProviderByNodeIdInput!
  ): UpdateProviderPayload

  """Updates a single `Provider` using a unique key and a patch."""
  updateProvider(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProviderInput!
  ): UpdateProviderPayload

  """Updates a single `Quote` using its globally unique id and a patch."""
  updateQuoteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateQuoteByNodeIdInput!
  ): UpdateQuotePayload

  """Updates a single `Quote` using a unique key and a patch."""
  updateQuote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateQuoteInput!
  ): UpdateQuotePayload

  """Updates a single `Return` using its globally unique id and a patch."""
  updateReturnByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReturnByNodeIdInput!
  ): UpdateReturnPayload

  """Updates a single `Return` using a unique key and a patch."""
  updateReturn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReturnInput!
  ): UpdateReturnPayload

  """Updates a single `Review` using its globally unique id and a patch."""
  updateReviewByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReviewByNodeIdInput!
  ): UpdateReviewPayload

  """Updates a single `Review` using a unique key and a patch."""
  updateReview(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReviewInput!
  ): UpdateReviewPayload

  """Updates a single `Reward` using its globally unique id and a patch."""
  updateRewardByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRewardByNodeIdInput!
  ): UpdateRewardPayload

  """Updates a single `Reward` using a unique key and a patch."""
  updateReward(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRewardInput!
  ): UpdateRewardPayload

  """Updates a single `Role` using its globally unique id and a patch."""
  updateRoleByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRoleByNodeIdInput!
  ): UpdateRolePayload

  """Updates a single `Role` using a unique key and a patch."""
  updateRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRoleInput!
  ): UpdateRolePayload

  """Updates a single `Scheduler` using its globally unique id and a patch."""
  updateSchedulerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSchedulerByNodeIdInput!
  ): UpdateSchedulerPayload

  """Updates a single `Scheduler` using a unique key and a patch."""
  updateScheduler(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSchedulerInput!
  ): UpdateSchedulerPayload

  """Updates a single `Segment` using its globally unique id and a patch."""
  updateSegmentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSegmentByNodeIdInput!
  ): UpdateSegmentPayload

  """Updates a single `Segment` using a unique key and a patch."""
  updateSegment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSegmentInput!
  ): UpdateSegmentPayload

  """Updates a single `Setting` using its globally unique id and a patch."""
  updateSettingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSettingByNodeIdInput!
  ): UpdateSettingPayload

  """Updates a single `Setting` using a unique key and a patch."""
  updateSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSettingInput!
  ): UpdateSettingPayload

  """Updates a single `Shipment` using its globally unique id and a patch."""
  updateShipmentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateShipmentByNodeIdInput!
  ): UpdateShipmentPayload

  """Updates a single `Shipment` using a unique key and a patch."""
  updateShipment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateShipmentInput!
  ): UpdateShipmentPayload

  """Updates a single `State` using its globally unique id and a patch."""
  updateStateByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStateByNodeIdInput!
  ): UpdateStatePayload

  """Updates a single `State` using a unique key and a patch."""
  updateState(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStateInput!
  ): UpdateStatePayload

  """Updates a single `Tag` using its globally unique id and a patch."""
  updateTagByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagByNodeIdInput!
  ): UpdateTagPayload

  """Updates a single `Tag` using a unique key and a patch."""
  updateTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagInput!
  ): UpdateTagPayload

  """Updates a single `Tax` using its globally unique id and a patch."""
  updateTaxByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTaxByNodeIdInput!
  ): UpdateTaxPayload

  """Updates a single `Tax` using a unique key and a patch."""
  updateTax(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTaxInput!
  ): UpdateTaxPayload

  """Updates a single `Theme` using its globally unique id and a patch."""
  updateThemeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateThemeByNodeIdInput!
  ): UpdateThemePayload

  """Updates a single `Theme` using a unique key and a patch."""
  updateTheme(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateThemeInput!
  ): UpdateThemePayload

  """Updates a single `Ticketing` using its globally unique id and a patch."""
  updateTicketingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTicketingByNodeIdInput!
  ): UpdateTicketingPayload

  """Updates a single `Ticketing` using a unique key and a patch."""
  updateTicketing(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTicketingInput!
  ): UpdateTicketingPayload

  """
  Updates a single `Transaction` using its globally unique id and a patch.
  """
  updateTransactionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTransactionByNodeIdInput!
  ): UpdateTransactionPayload

  """Updates a single `Transaction` using a unique key and a patch."""
  updateTransaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTransactionInput!
  ): UpdateTransactionPayload

  """
  Updates a single `UploadFile` using its globally unique id and a patch.
  """
  updateUploadFileByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUploadFileByNodeIdInput!
  ): UpdateUploadFilePayload

  """Updates a single `UploadFile` using a unique key and a patch."""
  updateUploadFile(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUploadFileInput!
  ): UpdateUploadFilePayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByNodeIdInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Updates a single `Vendor` using its globally unique id and a patch."""
  updateVendorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVendorByNodeIdInput!
  ): UpdateVendorPayload

  """Updates a single `Vendor` using a unique key and a patch."""
  updateVendor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVendorInput!
  ): UpdateVendorPayload

  """Updates a single `Visit` using its globally unique id and a patch."""
  updateVisitByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVisitByNodeIdInput!
  ): UpdateVisitPayload

  """Updates a single `Visit` using a unique key and a patch."""
  updateVisit(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVisitInput!
  ): UpdateVisitPayload

  """Updates a single `Warehouse` using its globally unique id and a patch."""
  updateWarehouseByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWarehouseByNodeIdInput!
  ): UpdateWarehousePayload

  """Updates a single `Warehouse` using a unique key and a patch."""
  updateWarehouse(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWarehouseInput!
  ): UpdateWarehousePayload

  """Updates a single `Webhook` using its globally unique id and a patch."""
  updateWebhookByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWebhookByNodeIdInput!
  ): UpdateWebhookPayload

  """Updates a single `Webhook` using a unique key and a patch."""
  updateWebhook(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWebhookInput!
  ): UpdateWebhookPayload

  """Updates a single `Website` using its globally unique id and a patch."""
  updateWebsiteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWebsiteByNodeIdInput!
  ): UpdateWebsitePayload

  """Updates a single `Website` using a unique key and a patch."""
  updateWebsite(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWebsiteInput!
  ): UpdateWebsitePayload

  """Updates a single `Wishlist` using its globally unique id and a patch."""
  updateWishlistByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWishlistByNodeIdInput!
  ): UpdateWishlistPayload

  """Updates a single `Wishlist` using a unique key and a patch."""
  updateWishlist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWishlistInput!
  ): UpdateWishlistPayload

  """Updates a single `Workspace` using its globally unique id and a patch."""
  updateWorkspaceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWorkspaceByNodeIdInput!
  ): UpdateWorkspacePayload

  """Updates a single `Workspace` using a unique key and a patch."""
  updateWorkspace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWorkspaceInput!
  ): UpdateWorkspacePayload

  """Updates a single `Zone` using its globally unique id and a patch."""
  updateZoneByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateZoneByNodeIdInput!
  ): UpdateZonePayload

  """Updates a single `Zone` using a unique key and a patch."""
  updateZone(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateZoneInput!
  ): UpdateZonePayload

  """Deletes a single `_PrismaMigration` using its globally unique id."""
  deletePrismaMigrationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePrismaMigrationByNodeIdInput!
  ): DeletePrismaMigrationPayload

  """Deletes a single `_PrismaMigration` using a unique key."""
  deletePrismaMigration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePrismaMigrationInput!
  ): DeletePrismaMigrationPayload

  """Deletes a single `Agreement` using its globally unique id."""
  deleteAgreementByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAgreementByNodeIdInput!
  ): DeleteAgreementPayload

  """Deletes a single `Agreement` using a unique key."""
  deleteAgreement(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAgreementInput!
  ): DeleteAgreementPayload

  """Deletes a single `Apitoken` using its globally unique id."""
  deleteApitokenByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteApitokenByNodeIdInput!
  ): DeleteApitokenPayload

  """Deletes a single `Apitoken` using a unique key."""
  deleteApitoken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteApitokenInput!
  ): DeleteApitokenPayload

  """Deletes a single `Article` using its globally unique id."""
  deleteArticleByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteArticleByNodeIdInput!
  ): DeleteArticlePayload

  """Deletes a single `Article` using a unique key."""
  deleteArticle(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteArticleInput!
  ): DeleteArticlePayload

  """Deletes a single `Attribute` using its globally unique id."""
  deleteAttributeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAttributeByNodeIdInput!
  ): DeleteAttributePayload

  """Deletes a single `Attribute` using a unique key."""
  deleteAttribute(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAttributeInput!
  ): DeleteAttributePayload

  """Deletes a single `Brand` using its globally unique id."""
  deleteBrandByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBrandByNodeIdInput!
  ): DeleteBrandPayload

  """Deletes a single `Brand` using a unique key."""
  deleteBrand(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBrandInput!
  ): DeleteBrandPayload

  """Deletes a single `Category` using its globally unique id."""
  deleteCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCategoryByNodeIdInput!
  ): DeleteCategoryPayload

  """Deletes a single `Category` using a unique key."""
  deleteCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCategoryInput!
  ): DeleteCategoryPayload

  """Deletes a single `Channel` using its globally unique id."""
  deleteChannelByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteChannelByNodeIdInput!
  ): DeleteChannelPayload

  """Deletes a single `Channel` using a unique key."""
  deleteChannel(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteChannelInput!
  ): DeleteChannelPayload

  """Deletes a single `Checklist` using its globally unique id."""
  deleteChecklistByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteChecklistByNodeIdInput!
  ): DeleteChecklistPayload

  """Deletes a single `Checklist` using a unique key."""
  deleteChecklist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteChecklistInput!
  ): DeleteChecklistPayload

  """Deletes a single `City` using its globally unique id."""
  deleteCityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCityByNodeIdInput!
  ): DeleteCityPayload

  """Deletes a single `City` using a unique key."""
  deleteCity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCityInput!
  ): DeleteCityPayload

  """Deletes a single `Collection` using its globally unique id."""
  deleteCollectionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCollectionByNodeIdInput!
  ): DeleteCollectionPayload

  """Deletes a single `Collection` using a unique key."""
  deleteCollection(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCollectionInput!
  ): DeleteCollectionPayload

  """Deletes a single `ContentType` using its globally unique id."""
  deleteContentTypeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContentTypeByNodeIdInput!
  ): DeleteContentTypePayload

  """Deletes a single `ContentType` using a unique key."""
  deleteContentType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContentTypeInput!
  ): DeleteContentTypePayload

  """Deletes a single `Country` using its globally unique id."""
  deleteCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCountryByNodeIdInput!
  ): DeleteCountryPayload

  """Deletes a single `Country` using a unique key."""
  deleteCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCountryInput!
  ): DeleteCountryPayload

  """Deletes a single `Currency` using its globally unique id."""
  deleteCurrencyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyByNodeIdInput!
  ): DeleteCurrencyPayload

  """Deletes a single `Currency` using a unique key."""
  deleteCurrency(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyInput!
  ): DeleteCurrencyPayload

  """Deletes a single `Customer` using its globally unique id."""
  deleteCustomerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCustomerByNodeIdInput!
  ): DeleteCustomerPayload

  """Deletes a single `Customer` using a unique key."""
  deleteCustomer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCustomerInput!
  ): DeleteCustomerPayload

  """Deletes a single `Dashboard` using its globally unique id."""
  deleteDashboardByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDashboardByNodeIdInput!
  ): DeleteDashboardPayload

  """Deletes a single `Dashboard` using a unique key."""
  deleteDashboard(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDashboardInput!
  ): DeleteDashboardPayload

  """Deletes a single `Dashboard` using a unique key."""
  deleteDashboardByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDashboardByNameInput!
  ): DeleteDashboardPayload

  """Deletes a single `Deepdive` using its globally unique id."""
  deleteDeepdiveByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDeepdiveByNodeIdInput!
  ): DeleteDeepdivePayload

  """Deletes a single `Deepdive` using a unique key."""
  deleteDeepdive(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDeepdiveInput!
  ): DeleteDeepdivePayload

  """Deletes a single `Discount` using its globally unique id."""
  deleteDiscountByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDiscountByNodeIdInput!
  ): DeleteDiscountPayload

  """Deletes a single `Discount` using a unique key."""
  deleteDiscount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDiscountInput!
  ): DeleteDiscountPayload

  """Deletes a single `Endofshift` using its globally unique id."""
  deleteEndofshiftByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEndofshiftByNodeIdInput!
  ): DeleteEndofshiftPayload

  """Deletes a single `Endofshift` using a unique key."""
  deleteEndofshift(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEndofshiftInput!
  ): DeleteEndofshiftPayload

  """Deletes a single `Event` using its globally unique id."""
  deleteEventByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEventByNodeIdInput!
  ): DeleteEventPayload

  """Deletes a single `Event` using a unique key."""
  deleteEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEventInput!
  ): DeleteEventPayload

  """Deletes a single `Fullfillment` using its globally unique id."""
  deleteFullfillmentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFullfillmentByNodeIdInput!
  ): DeleteFullfillmentPayload

  """Deletes a single `Fullfillment` using a unique key."""
  deleteFullfillment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFullfillmentInput!
  ): DeleteFullfillmentPayload

  """Deletes a single `Glossary` using its globally unique id."""
  deleteGlossaryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGlossaryByNodeIdInput!
  ): DeleteGlossaryPayload

  """Deletes a single `Glossary` using a unique key."""
  deleteGlossary(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGlossaryInput!
  ): DeleteGlossaryPayload

  """Deletes a single `Integration` using its globally unique id."""
  deleteIntegrationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteIntegrationByNodeIdInput!
  ): DeleteIntegrationPayload

  """Deletes a single `Integration` using a unique key."""
  deleteIntegration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteIntegrationInput!
  ): DeleteIntegrationPayload

  """Deletes a single `Internalization` using its globally unique id."""
  deleteInternalizationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInternalizationByNodeIdInput!
  ): DeleteInternalizationPayload

  """Deletes a single `Internalization` using a unique key."""
  deleteInternalization(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInternalizationInput!
  ): DeleteInternalizationPayload

  """Deletes a single `Invoice` using its globally unique id."""
  deleteInvoiceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInvoiceByNodeIdInput!
  ): DeleteInvoicePayload

  """Deletes a single `Invoice` using a unique key."""
  deleteInvoice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInvoiceInput!
  ): DeleteInvoicePayload

  """Deletes a single `LogIn` using its globally unique id."""
  deleteLogInByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLogInByNodeIdInput!
  ): DeleteLogInPayload

  """Deletes a single `LogIn` using a unique key."""
  deleteLogIn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLogInInput!
  ): DeleteLogInPayload

  """Deletes a single `Manufacturer` using its globally unique id."""
  deleteManufacturerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteManufacturerByNodeIdInput!
  ): DeleteManufacturerPayload

  """Deletes a single `Manufacturer` using a unique key."""
  deleteManufacturer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteManufacturerInput!
  ): DeleteManufacturerPayload

  """Deletes a single `Mediamanager` using its globally unique id."""
  deleteMediamanagerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMediamanagerByNodeIdInput!
  ): DeleteMediamanagerPayload

  """Deletes a single `Mediamanager` using a unique key."""
  deleteMediamanager(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMediamanagerInput!
  ): DeleteMediamanagerPayload

  """Deletes a single `Newsletter` using its globally unique id."""
  deleteNewsletterByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNewsletterByNodeIdInput!
  ): DeleteNewsletterPayload

  """Deletes a single `Newsletter` using a unique key."""
  deleteNewsletter(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNewsletterInput!
  ): DeleteNewsletterPayload

  """Deletes a single `Ooto` using its globally unique id."""
  deleteOotoByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOotoByNodeIdInput!
  ): DeleteOotoPayload

  """Deletes a single `Ooto` using a unique key."""
  deleteOoto(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOotoInput!
  ): DeleteOotoPayload

  """Deletes a single `Order` using its globally unique id."""
  deleteOrderByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrderByNodeIdInput!
  ): DeleteOrderPayload

  """Deletes a single `Order` using a unique key."""
  deleteOrder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrderInput!
  ): DeleteOrderPayload

  """Deletes a single `Page` using its globally unique id."""
  deletePageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePageByNodeIdInput!
  ): DeletePagePayload

  """Deletes a single `Page` using a unique key."""
  deletePage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePageInput!
  ): DeletePagePayload

  """Deletes a single `Partner` using its globally unique id."""
  deletePartnerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePartnerByNodeIdInput!
  ): DeletePartnerPayload

  """Deletes a single `Partner` using a unique key."""
  deletePartner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePartnerInput!
  ): DeletePartnerPayload

  """Deletes a single `Payment` using its globally unique id."""
  deletePaymentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePaymentByNodeIdInput!
  ): DeletePaymentPayload

  """Deletes a single `Payment` using a unique key."""
  deletePayment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePaymentInput!
  ): DeletePaymentPayload

  """Deletes a single `Permission` using its globally unique id."""
  deletePermissionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePermissionByNodeIdInput!
  ): DeletePermissionPayload

  """Deletes a single `Permission` using a unique key."""
  deletePermission(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePermissionInput!
  ): DeletePermissionPayload

  """Deletes a single `Plugin` using its globally unique id."""
  deletePluginByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePluginByNodeIdInput!
  ): DeletePluginPayload

  """Deletes a single `Plugin` using a unique key."""
  deletePlugin(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePluginInput!
  ): DeletePluginPayload

  """Deletes a single `ProductType` using its globally unique id."""
  deleteProductTypeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductTypeByNodeIdInput!
  ): DeleteProductTypePayload

  """Deletes a single `ProductType` using a unique key."""
  deleteProductType(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductTypeInput!
  ): DeleteProductTypePayload

  """Deletes a single `Product` using its globally unique id."""
  deleteProductByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductByNodeIdInput!
  ): DeleteProductPayload

  """Deletes a single `Product` using a unique key."""
  deleteProduct(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProductInput!
  ): DeleteProductPayload

  """Deletes a single `Project` using its globally unique id."""
  deleteProjectByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectByNodeIdInput!
  ): DeleteProjectPayload

  """Deletes a single `Project` using a unique key."""
  deleteProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectInput!
  ): DeleteProjectPayload

  """Deletes a single `Provider` using its globally unique id."""
  deleteProviderByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProviderByNodeIdInput!
  ): DeleteProviderPayload

  """Deletes a single `Provider` using a unique key."""
  deleteProvider(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProviderInput!
  ): DeleteProviderPayload

  """Deletes a single `Quote` using its globally unique id."""
  deleteQuoteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteQuoteByNodeIdInput!
  ): DeleteQuotePayload

  """Deletes a single `Quote` using a unique key."""
  deleteQuote(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteQuoteInput!
  ): DeleteQuotePayload

  """Deletes a single `Return` using its globally unique id."""
  deleteReturnByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReturnByNodeIdInput!
  ): DeleteReturnPayload

  """Deletes a single `Return` using a unique key."""
  deleteReturn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReturnInput!
  ): DeleteReturnPayload

  """Deletes a single `Review` using its globally unique id."""
  deleteReviewByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReviewByNodeIdInput!
  ): DeleteReviewPayload

  """Deletes a single `Review` using a unique key."""
  deleteReview(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReviewInput!
  ): DeleteReviewPayload

  """Deletes a single `Reward` using its globally unique id."""
  deleteRewardByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRewardByNodeIdInput!
  ): DeleteRewardPayload

  """Deletes a single `Reward` using a unique key."""
  deleteReward(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRewardInput!
  ): DeleteRewardPayload

  """Deletes a single `Role` using its globally unique id."""
  deleteRoleByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRoleByNodeIdInput!
  ): DeleteRolePayload

  """Deletes a single `Role` using a unique key."""
  deleteRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRoleInput!
  ): DeleteRolePayload

  """Deletes a single `Scheduler` using its globally unique id."""
  deleteSchedulerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSchedulerByNodeIdInput!
  ): DeleteSchedulerPayload

  """Deletes a single `Scheduler` using a unique key."""
  deleteScheduler(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSchedulerInput!
  ): DeleteSchedulerPayload

  """Deletes a single `Segment` using its globally unique id."""
  deleteSegmentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSegmentByNodeIdInput!
  ): DeleteSegmentPayload

  """Deletes a single `Segment` using a unique key."""
  deleteSegment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSegmentInput!
  ): DeleteSegmentPayload

  """Deletes a single `Setting` using its globally unique id."""
  deleteSettingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSettingByNodeIdInput!
  ): DeleteSettingPayload

  """Deletes a single `Setting` using a unique key."""
  deleteSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSettingInput!
  ): DeleteSettingPayload

  """Deletes a single `Shipment` using its globally unique id."""
  deleteShipmentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteShipmentByNodeIdInput!
  ): DeleteShipmentPayload

  """Deletes a single `Shipment` using a unique key."""
  deleteShipment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteShipmentInput!
  ): DeleteShipmentPayload

  """Deletes a single `State` using its globally unique id."""
  deleteStateByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStateByNodeIdInput!
  ): DeleteStatePayload

  """Deletes a single `State` using a unique key."""
  deleteState(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStateInput!
  ): DeleteStatePayload

  """Deletes a single `Tag` using its globally unique id."""
  deleteTagByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagByNodeIdInput!
  ): DeleteTagPayload

  """Deletes a single `Tag` using a unique key."""
  deleteTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagInput!
  ): DeleteTagPayload

  """Deletes a single `Tax` using its globally unique id."""
  deleteTaxByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTaxByNodeIdInput!
  ): DeleteTaxPayload

  """Deletes a single `Tax` using a unique key."""
  deleteTax(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTaxInput!
  ): DeleteTaxPayload

  """Deletes a single `Theme` using its globally unique id."""
  deleteThemeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteThemeByNodeIdInput!
  ): DeleteThemePayload

  """Deletes a single `Theme` using a unique key."""
  deleteTheme(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteThemeInput!
  ): DeleteThemePayload

  """Deletes a single `Ticketing` using its globally unique id."""
  deleteTicketingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTicketingByNodeIdInput!
  ): DeleteTicketingPayload

  """Deletes a single `Ticketing` using a unique key."""
  deleteTicketing(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTicketingInput!
  ): DeleteTicketingPayload

  """Deletes a single `Transaction` using its globally unique id."""
  deleteTransactionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTransactionByNodeIdInput!
  ): DeleteTransactionPayload

  """Deletes a single `Transaction` using a unique key."""
  deleteTransaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTransactionInput!
  ): DeleteTransactionPayload

  """Deletes a single `UploadFile` using its globally unique id."""
  deleteUploadFileByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUploadFileByNodeIdInput!
  ): DeleteUploadFilePayload

  """Deletes a single `UploadFile` using a unique key."""
  deleteUploadFile(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUploadFileInput!
  ): DeleteUploadFilePayload

  """Deletes a single `User` using its globally unique id."""
  deleteUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByNodeIdInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single `Vendor` using its globally unique id."""
  deleteVendorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVendorByNodeIdInput!
  ): DeleteVendorPayload

  """Deletes a single `Vendor` using a unique key."""
  deleteVendor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVendorInput!
  ): DeleteVendorPayload

  """Deletes a single `Visit` using its globally unique id."""
  deleteVisitByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVisitByNodeIdInput!
  ): DeleteVisitPayload

  """Deletes a single `Visit` using a unique key."""
  deleteVisit(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVisitInput!
  ): DeleteVisitPayload

  """Deletes a single `Warehouse` using its globally unique id."""
  deleteWarehouseByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWarehouseByNodeIdInput!
  ): DeleteWarehousePayload

  """Deletes a single `Warehouse` using a unique key."""
  deleteWarehouse(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWarehouseInput!
  ): DeleteWarehousePayload

  """Deletes a single `Webhook` using its globally unique id."""
  deleteWebhookByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWebhookByNodeIdInput!
  ): DeleteWebhookPayload

  """Deletes a single `Webhook` using a unique key."""
  deleteWebhook(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWebhookInput!
  ): DeleteWebhookPayload

  """Deletes a single `Website` using its globally unique id."""
  deleteWebsiteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWebsiteByNodeIdInput!
  ): DeleteWebsitePayload

  """Deletes a single `Website` using a unique key."""
  deleteWebsite(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWebsiteInput!
  ): DeleteWebsitePayload

  """Deletes a single `Wishlist` using its globally unique id."""
  deleteWishlistByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWishlistByNodeIdInput!
  ): DeleteWishlistPayload

  """Deletes a single `Wishlist` using a unique key."""
  deleteWishlist(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWishlistInput!
  ): DeleteWishlistPayload

  """Deletes a single `Workspace` using its globally unique id."""
  deleteWorkspaceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWorkspaceByNodeIdInput!
  ): DeleteWorkspacePayload

  """Deletes a single `Workspace` using a unique key."""
  deleteWorkspace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWorkspaceInput!
  ): DeleteWorkspacePayload

  """Deletes a single `Zone` using its globally unique id."""
  deleteZoneByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteZoneByNodeIdInput!
  ): DeleteZonePayload

  """Deletes a single `Zone` using a unique key."""
  deleteZone(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteZoneInput!
  ): DeleteZonePayload
}

"""The output of our create `_PrismaMigration` mutation."""
type CreatePrismaMigrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `_PrismaMigration` that was created by this mutation."""
  _prismaMigration: _PrismaMigration

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `_PrismaMigration`. May be used by Relay 1."""
  _prismaMigrationEdge(
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): _PrismaMigrationsEdge
}

"""All input for the create `_PrismaMigration` mutation."""
input CreatePrismaMigrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `_PrismaMigration` to be created by this mutation."""
  _prismaMigration: _PrismaMigrationInput!
}

"""An input for mutations affecting `_PrismaMigration`"""
input _PrismaMigrationInput {
  id: String!
  checksum: String!
  finishedAt: Datetime
  migrationName: String!
  logs: String
  rolledBackAt: Datetime
  startedAt: Datetime
  appliedStepsCount: Int
}

"""The output of our create `Agreement` mutation."""
type CreateAgreementPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Agreement` that was created by this mutation."""
  agreement: Agreement

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Agreement`. May be used by Relay 1."""
  agreementEdge(
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgreementsEdge
}

"""All input for the create `Agreement` mutation."""
input CreateAgreementInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Agreement` to be created by this mutation."""
  agreement: AgreementInput!
}

"""An input for mutations affecting `Agreement`"""
input AgreementInput {
  id: BigInt
  referenceId: String
  created: Datetime
  updated: Datetime
  content: String
  name: String
  image: String
  excerpt: String
  type: String
  userId: String
  shopId: String
  mediamanager: String
}

"""The output of our create `Apitoken` mutation."""
type CreateApitokenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Apitoken` that was created by this mutation."""
  apitoken: Apitoken

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Apitoken`. May be used by Relay 1."""
  apitokenEdge(
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): ApitokensEdge
}

"""All input for the create `Apitoken` mutation."""
input CreateApitokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Apitoken` to be created by this mutation."""
  apitoken: ApitokenInput!
}

"""An input for mutations affecting `Apitoken`"""
input ApitokenInput {
  id: BigInt
  createdAt: Datetime
  name: String!
  tokenType: String
  description: String
  token: BigInt!
}

"""The output of our create `Article` mutation."""
type CreateArticlePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Article` that was created by this mutation."""
  article: Article

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Article`. May be used by Relay 1."""
  articleEdge(
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArticlesEdge
}

"""All input for the create `Article` mutation."""
input CreateArticleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Article` to be created by this mutation."""
  article: ArticleInput!
}

"""An input for mutations affecting `Article`"""
input ArticleInput {
  id: Int
  name: String
  excerpt: String
  content: String
  image: String
  categories: String
  customers: String
  users: String
  published: String
  custId: String
  isPublic: String
  metaDescription: String
  metaName: String
  metaUrl: String
  tags: String
  type: String
}

"""The output of our create `Attribute` mutation."""
type CreateAttributePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Attribute` that was created by this mutation."""
  attribute: Attribute

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Attribute`. May be used by Relay 1."""
  attributeEdge(
    """The method to use when ordering `Attribute`."""
    orderBy: [AttributesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AttributesEdge
}

"""All input for the create `Attribute` mutation."""
input CreateAttributeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Attribute` to be created by this mutation."""
  attribute: AttributeInput!
}

"""An input for mutations affecting `Attribute`"""
input AttributeInput {
  id: Int
  defaultLabel: String
  attributeCode: String
  filterOptions: String
  useSearch: String
  layeredNavigation: Boolean
  searchResultsLayeredNavigation: Boolean
  position: String
  promoRuleConditions: Boolean
  allowHtmlTagsStorefront: Boolean
  visibleCatalogPagesStorefront: Boolean
  usedProductListing: Boolean
  usedSortingProductListing: Boolean
  prodId: BigInt!
  attributeClass: String
  attributeValue: String
  columnOptions: String
  facetedNavigation: Boolean
  isPublic: String
  metaDescription: String
  metaName: Boolean
  metaUrl: String
  productAttributeSet: String
  products: String
}

"""The output of our create `Brand` mutation."""
type CreateBrandPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Brand` that was created by this mutation."""
  brand: Brand

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Brand`. May be used by Relay 1."""
  brandEdge(
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BrandsEdge
}

"""All input for the create `Brand` mutation."""
input CreateBrandInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Brand` to be created by this mutation."""
  brand: BrandInput!
}

"""An input for mutations affecting `Brand`"""
input BrandInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
  mediamanager: String
  products: String
  workspaces: String
}

"""The output of our create `Category` mutation."""
type CreateCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Category` that was created by this mutation."""
  category: Category

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""All input for the create `Category` mutation."""
input CreateCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Category` to be created by this mutation."""
  category: CategoryInput!
}

"""An input for mutations affecting `Category`"""
input CategoryInput {
  id: Int
  thumbnail: String
  name: String!
  visibility: String
  status: Boolean
  websites: String
  product: String
  country: String
  description: String
  content: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  workspaces: String
}

"""The output of our create `Channel` mutation."""
type CreateChannelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Channel` that was created by this mutation."""
  channel: Channel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Channel`. May be used by Relay 1."""
  channelEdge(
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChannelsEdge
}

"""All input for the create `Channel` mutation."""
input CreateChannelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Channel` to be created by this mutation."""
  channel: ChannelInput!
}

"""An input for mutations affecting `Channel`"""
input ChannelInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  currency: String
  defaultLang: String
  includeTax: String
  defaultZone: String
  defaultShipping: String
  clientId: String
  clientSecret: String
}

"""The output of our create `Checklist` mutation."""
type CreateChecklistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Checklist` that was created by this mutation."""
  checklist: Checklist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Checklist`. May be used by Relay 1."""
  checklistEdge(
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChecklistsEdge
}

"""All input for the create `Checklist` mutation."""
input CreateChecklistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Checklist` to be created by this mutation."""
  checklist: ChecklistInput!
}

"""An input for mutations affecting `Checklist`"""
input ChecklistInput {
  id: BigInt
  createdAt: Datetime
  username: String
  location: String
  regionalManager: String
  manager: String
  description: String
  ticket: String
  project: String
  region: String
  country: String
  media: String
  prodId: String
  trainings: String
  task: String
  type: String
}

"""The output of our create `City` mutation."""
type CreateCityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `City` that was created by this mutation."""
  city: City

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `City`. May be used by Relay 1."""
  cityEdge(
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge
}

"""All input for the create `City` mutation."""
input CreateCityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `City` to be created by this mutation."""
  city: CityInput!
}

"""An input for mutations affecting `City`"""
input CityInput {
  id: Int
  name: String!
  description: String
  state: String
  country: String
  postalCode: String
  image: String
}

"""The output of our create `Collection` mutation."""
type CreateCollectionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Collection` that was created by this mutation."""
  collection: Collection

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Collection`. May be used by Relay 1."""
  collectionEdge(
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CollectionsEdge
}

"""All input for the create `Collection` mutation."""
input CreateCollectionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Collection` to be created by this mutation."""
  collection: CollectionInput!
}

"""An input for mutations affecting `Collection`"""
input CollectionInput {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  image: String
  product: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
}

"""The output of our create `ContentType` mutation."""
type CreateContentTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ContentType` that was created by this mutation."""
  contentType: ContentType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ContentType`. May be used by Relay 1."""
  contentTypeEdge(
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContentTypesEdge
}

"""All input for the create `ContentType` mutation."""
input CreateContentTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ContentType` to be created by this mutation."""
  contentType: ContentTypeInput!
}

"""An input for mutations affecting `ContentType`"""
input ContentTypeInput {
  id: BigInt
  createdAt: Datetime
  text: String
  number: BigFloat
  json: JSON
  link: String
  email: String
  uid: String
  date: Date
  time: Time
  timestamp: Datetime
  boolean: Boolean
  richText: String
  password: String
  media: String
  databaseName: String
}

"""The output of our create `Country` mutation."""
type CreateCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Country` that was created by this mutation."""
  country: Country

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Country`. May be used by Relay 1."""
  countryEdge(
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge
}

"""All input for the create `Country` mutation."""
input CreateCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Country` to be created by this mutation."""
  country: CountryInput!
}

"""An input for mutations affecting `Country`"""
input CountryInput {
  id: Int
  name: String!
  description: String
  image: String
  region: String
  trainings: String
}

"""The output of our create `Currency` mutation."""
type CreateCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Currency` that was created by this mutation."""
  currency: Currency

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
}

"""All input for the create `Currency` mutation."""
input CreateCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Currency` to be created by this mutation."""
  currency: CurrencyInput!
}

"""An input for mutations affecting `Currency`"""
input CurrencyInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  region: String
  symbol: String
  useStandard: String
}

"""The output of our create `Customer` mutation."""
type CreateCustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Customer` that was created by this mutation."""
  customer: Customer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Customer`. May be used by Relay 1."""
  customerEdge(
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersEdge
}

"""All input for the create `Customer` mutation."""
input CreateCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Customer` to be created by this mutation."""
  customer: CustomerInput!
}

"""An input for mutations affecting `Customer`"""
input CustomerInput {
  id: Int
  thumbnail: String
  namePrefix: String
  firstName: String!
  middleName: String
  lastName: String!
  email: String!
  customerGroup: String
  phone: String
  zipcode: String
  nameSuffix: String
  websites: String
  product: String
  country: String
  state: String
  customerSince: Datetime
  confirmedEmail: String
  dateOfBirth: String
  taxVatNumber: String
  gender: String
  description: String
  shortDescription: String
  image: String
  address: String
  addressTwo: String
  paymentType: String
  username: String
  password: String
  comments: String
  creditMemos: String
  customerPayment: String
  emails: String
  mediamanager: String
  messages: String
  newsletterSubscribers: String
  orders: String
  projects: String
  quotes: String
  returns: String
  workspaces: String
}

"""The output of our create `Dashboard` mutation."""
type CreateDashboardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Dashboard` that was created by this mutation."""
  dashboard: Dashboard

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Dashboard`. May be used by Relay 1."""
  dashboardEdge(
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DashboardsEdge
}

"""All input for the create `Dashboard` mutation."""
input CreateDashboardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Dashboard` to be created by this mutation."""
  dashboard: DashboardInput!
}

"""An input for mutations affecting `Dashboard`"""
input DashboardInput {
  id: BigInt
  createdAt: Datetime
  name: String
  clientId: String
  clientSecret: String
  privacy: String
  category: String
  url: String
  media: String
  reports: String
  tasks: String
  projects: String
  tickets: String
  customers: String
  checklists: String
  visits: String
  users: String
  products: String
  articles: String
  sales: String
  logo: String
  content: String
  published: String
}

"""The output of our create `Deepdive` mutation."""
type CreateDeepdivePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Deepdive` that was created by this mutation."""
  deepdive: Deepdive

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Deepdive`. May be used by Relay 1."""
  deepdiveEdge(
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DeepdivesEdge
}

"""All input for the create `Deepdive` mutation."""
input CreateDeepdiveInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Deepdive` to be created by this mutation."""
  deepdive: DeepdiveInput!
}

"""An input for mutations affecting `Deepdive`"""
input DeepdiveInput {
  id: BigInt
  createdAt: Datetime
  endDate: String
  content: String
  attendees: String
  login: String
  startDate: String
  whid: String
}

"""The output of our create `Discount` mutation."""
type CreateDiscountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Discount` that was created by this mutation."""
  discount: Discount

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Discount`. May be used by Relay 1."""
  discountEdge(
    """The method to use when ordering `Discount`."""
    orderBy: [DiscountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiscountsEdge
}

"""All input for the create `Discount` mutation."""
input CreateDiscountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Discount` to be created by this mutation."""
  discount: DiscountInput!
}

"""An input for mutations affecting `Discount`"""
input DiscountInput {
  id: BigInt
  name: String!
  excerpt: String
  discount: String
  image: String
  published: Datetime
  specialOffers: String
  rewards: String
  coupons: String
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  type: String
  creditMemo: String
  billToName: String
  orderNumber: String
  refunded: String
  status: String
}

"""The output of our create `Endofshift` mutation."""
type CreateEndofshiftPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Endofshift` that was created by this mutation."""
  endofshift: Endofshift

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Endofshift`. May be used by Relay 1."""
  endofshiftEdge(
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EndofshiftsEdge
}

"""All input for the create `Endofshift` mutation."""
input CreateEndofshiftInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Endofshift` to be created by this mutation."""
  endofshift: EndofshiftInput!
}

"""An input for mutations affecting `Endofshift`"""
input EndofshiftInput {
  id: BigInt
  createdAt: Datetime
  content: String
  login: String
  mcms: String
  nextShift: String
  projects: String
  tickets: String
  whid: String
}

"""The output of our create `Event` mutation."""
type CreateEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was created by this mutation."""
  event: Event

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the create `Event` mutation."""
input CreateEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Event` to be created by this mutation."""
  event: EventInput!
}

"""An input for mutations affecting `Event`"""
input EventInput {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  tickets: String
  image: String
  start: String
  end: String
  category: String
  city: String
  state: String
  country: String
  postalcode: String
  type: String
  invitationEmail: String
  invitationBillingAddress: String
  invitationGrandTotalPurchased: String
  invitationInvoiceDate: String
  invitationOrderNumber: String
  invitationPaymentMethod: String
  invitationShippingAddress: String
  invitationCustomerName: String
  invitationStatus: String
  media: String
}

"""The output of our create `Fullfillment` mutation."""
type CreateFullfillmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Fullfillment` that was created by this mutation."""
  fullfillment: Fullfillment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Fullfillment`. May be used by Relay 1."""
  fullfillmentEdge(
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FullfillmentsEdge
}

"""All input for the create `Fullfillment` mutation."""
input CreateFullfillmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Fullfillment` to be created by this mutation."""
  fullfillment: FullfillmentInput!
}

"""An input for mutations affecting `Fullfillment`"""
input FullfillmentInput {
  id: BigInt
  createdAt: Datetime
  name: String
  shippingZones: String
  company: String
  address: String
  addressTwo: String
  city: String
  state: String
  zipcode: String
  country: String
  countryArea: String
  phone: String
  pickup: String
  stock: String
}

"""The output of our create `Glossary` mutation."""
type CreateGlossaryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Glossary` that was created by this mutation."""
  glossary: Glossary

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Glossary`. May be used by Relay 1."""
  glossaryEdge(
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GlossariesEdge
}

"""All input for the create `Glossary` mutation."""
input CreateGlossaryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Glossary` to be created by this mutation."""
  glossary: GlossaryInput!
}

"""An input for mutations affecting `Glossary`"""
input GlossaryInput {
  id: Int
  name: String!
  content: String
  image: String
  published: Datetime
}

"""The output of our create `Integration` mutation."""
type CreateIntegrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Integration` that was created by this mutation."""
  integration: Integration

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Integration`. May be used by Relay 1."""
  integrationEdge(
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): IntegrationsEdge
}

"""All input for the create `Integration` mutation."""
input CreateIntegrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Integration` to be created by this mutation."""
  integration: IntegrationInput!
}

"""An input for mutations affecting `Integration`"""
input IntegrationInput {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  media: String
  location: String
  category: String
}

"""The output of our create `Internalization` mutation."""
type CreateInternalizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Internalization` that was created by this mutation."""
  internalization: Internalization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Internalization`. May be used by Relay 1."""
  internalizationEdge(
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InternalizationsEdge
}

"""All input for the create `Internalization` mutation."""
input CreateInternalizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Internalization` to be created by this mutation."""
  internalization: InternalizationInput!
}

"""An input for mutations affecting `Internalization`"""
input InternalizationInput {
  id: BigInt
  createdAt: Datetime
  name: String
  region: String
  description: String
  default: String
  website: String
}

"""The output of our create `Invoice` mutation."""
type CreateInvoicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Invoice` that was created by this mutation."""
  invoice: Invoice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Invoice`. May be used by Relay 1."""
  invoiceEdge(
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvoicesEdge
}

"""All input for the create `Invoice` mutation."""
input CreateInvoiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Invoice` to be created by this mutation."""
  invoice: InvoiceInput!
}

"""An input for mutations affecting `Invoice`"""
input InvoiceInput {
  invoice: Int!
  orderNumber: BigInt!
  invoiceDate: Datetime
  billToName: String!
  billingAddress: String
  grandTotalBase: String
  grandTotalPurchased: String
  status: String
  shippingAddress: String
  customerName: String
  email: String
  customerGroup: String
  paymentMethod: String
  shippingInformation: String
  subtotal: String
  shippingAndHandling: String
  id: BigInt
}

"""The output of our create `LogIn` mutation."""
type CreateLogInPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LogIn` that was created by this mutation."""
  logIn: LogIn

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `LogIn`. May be used by Relay 1."""
  logInEdge(
    """The method to use when ordering `LogIn`."""
    orderBy: [LogInsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LogInsEdge
}

"""All input for the create `LogIn` mutation."""
input CreateLogInInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LogIn` to be created by this mutation."""
  logIn: LogInInput!
}

"""An input for mutations affecting `LogIn`"""
input LogInInput {
  id: BigInt
  createdAt: Datetime
  email: String
  password: String
  token: String
  expiresIn: String
  users: String
  username: String
}

"""The output of our create `Manufacturer` mutation."""
type CreateManufacturerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Manufacturer` that was created by this mutation."""
  manufacturer: Manufacturer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Manufacturer`. May be used by Relay 1."""
  manufacturerEdge(
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ManufacturersEdge
}

"""All input for the create `Manufacturer` mutation."""
input CreateManufacturerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Manufacturer` to be created by this mutation."""
  manufacturer: ManufacturerInput!
}

"""An input for mutations affecting `Manufacturer`"""
input ManufacturerInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
  products: String
}

"""The output of our create `Mediamanager` mutation."""
type CreateMediamanagerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Mediamanager` that was created by this mutation."""
  mediamanager: Mediamanager

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Mediamanager`. May be used by Relay 1."""
  mediamanagerEdge(
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
  ): MediamanagersEdge
}

"""All input for the create `Mediamanager` mutation."""
input CreateMediamanagerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Mediamanager` to be created by this mutation."""
  mediamanager: MediamanagerInput!
}

"""An input for mutations affecting `Mediamanager`"""
input MediamanagerInput {
  id: Int
  createdAt: Datetime
  name: String
  description: String
  media: String
  keywords: String
  tags: String
  brands: String
  status: String
  expirationDate: String
  copyright: String
  dimensions: String
  author: String
  contentType: String
  versions: String
  watermarkName: String
  watermarkDescription: String
  watermarkMedia: String
  agreements: String
  albums: String
  comment: String
  workspace: String
  taskName: String
  taskDescription: String
  taskType: String
  members: String
  products: String
  agreementsAgreementsTomediamanager: String
  brandsBrandsTomediamanager: String
  comments: String
  customers: String
  productsMediamanagerToproducts: String
  tasks: String
  users: String
}

"""The output of our create `Newsletter` mutation."""
type CreateNewsletterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Newsletter` that was created by this mutation."""
  newsletter: Newsletter

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Newsletter`. May be used by Relay 1."""
  newsletterEdge(
    """The method to use when ordering `Newsletter`."""
    orderBy: [NewslettersOrderBy!] = [PRIMARY_KEY_ASC]
  ): NewslettersEdge
}

"""All input for the create `Newsletter` mutation."""
input CreateNewsletterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Newsletter` to be created by this mutation."""
  newsletter: NewsletterInput!
}

"""An input for mutations affecting `Newsletter`"""
input NewsletterInput {
  id: Int
  email: String!
  customerFirstName: String
  customerLastName: String
  store: String
  status: String
  websites: String
  createdAt: Datetime
  custId: Int!
  customers: String
}

"""The output of our create `Ooto` mutation."""
type CreateOotoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ooto` that was created by this mutation."""
  ooto: Ooto

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Ooto`. May be used by Relay 1."""
  ootoEdge(
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!] = [PRIMARY_KEY_ASC]
  ): OotosEdge
}

"""All input for the create `Ooto` mutation."""
input CreateOotoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Ooto` to be created by this mutation."""
  ooto: OotoInput!
}

"""An input for mutations affecting `Ooto`"""
input OotoInput {
  id: BigInt
  createdAt: Datetime
  login: String
  startDate: String
  endDate: String
  note: String
  usingTime: String
  location: String
}

"""The output of our create `Order` mutation."""
type CreateOrderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Order` that was created by this mutation."""
  order: Order

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Order`. May be used by Relay 1."""
  orderEdge(
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrdersEdge
}

"""All input for the create `Order` mutation."""
input CreateOrderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Order` to be created by this mutation."""
  order: OrderInput!
}

"""An input for mutations affecting `Order`"""
input OrderInput {
  id: Int
  purchasePoint: Int
  purchaseDate: Datetime
  billToName: String!
  shipToName: String
  grandTotalBase: Int
  grandTotalPurchased: Int
  status: Boolean
  action: Boolean
  allocatedSources: String
  braintreeTransactionSource: String
  custId: Int!
  prodId: BigInt!
  customers: String
  products: String
  quotes: String
  transactions: String
}

"""The output of our create `Page` mutation."""
type CreatePagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Page` that was created by this mutation."""
  page: Page

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Page`. May be used by Relay 1."""
  pageEdge(
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PagesEdge
}

"""All input for the create `Page` mutation."""
input CreatePageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Page` to be created by this mutation."""
  page: PageInput!
}

"""An input for mutations affecting `Page`"""
input PageInput {
  id: Int
  enablePage: Boolean
  title: String!
  contentTitle: String
  content: String
  urlKey: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
}

"""The output of our create `Partner` mutation."""
type CreatePartnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Partner` that was created by this mutation."""
  partner: Partner

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Partner`. May be used by Relay 1."""
  partnerEdge(
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnersEdge
}

"""All input for the create `Partner` mutation."""
input CreatePartnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Partner` to be created by this mutation."""
  partner: PartnerInput!
}

"""An input for mutations affecting `Partner`"""
input PartnerInput {
  id: BigInt
  createdAt: Datetime
  name: String
  address: String
  city: String
  state: String
  country: String
  isPublic: String
  businessType: String
}

"""The output of our create `Payment` mutation."""
type CreatePaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Payment` that was created by this mutation."""
  payment: Payment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Payment`. May be used by Relay 1."""
  paymentEdge(
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsEdge
}

"""All input for the create `Payment` mutation."""
input CreatePaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Payment` to be created by this mutation."""
  payment: PaymentInput!
}

"""An input for mutations affecting `Payment`"""
input PaymentInput {
  id: BigInt
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String!
  active: String
  country: String
}

"""The output of our create `Permission` mutation."""
type CreatePermissionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Permission` that was created by this mutation."""
  permission: Permission

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Permission`. May be used by Relay 1."""
  permissionEdge(
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PermissionsEdge
}

"""All input for the create `Permission` mutation."""
input CreatePermissionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Permission` to be created by this mutation."""
  permission: PermissionInput!
}

"""An input for mutations affecting `Permission`"""
input PermissionInput {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  create: String
  delete: String
  read: String
  role: String
  update: String
  users: String
}

"""The output of our create `Plugin` mutation."""
type CreatePluginPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Plugin` that was created by this mutation."""
  plugin: Plugin

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Plugin`. May be used by Relay 1."""
  pluginEdge(
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PluginsEdge
}

"""All input for the create `Plugin` mutation."""
input CreatePluginInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Plugin` to be created by this mutation."""
  plugin: PluginInput!
}

"""An input for mutations affecting `Plugin`"""
input PluginInput {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  githubLink: String
  description: String
  logo: String
  screenshots: String
  lastUpdated: Datetime
  publisherName: String
  agreeTerms: Boolean
  publisherEmail: String
}

"""The output of our create `ProductType` mutation."""
type CreateProductTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProductType` that was created by this mutation."""
  productType: ProductType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProductType`. May be used by Relay 1."""
  productTypeEdge(
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductTypesEdge
}

"""All input for the create `ProductType` mutation."""
input CreateProductTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ProductType` to be created by this mutation."""
  productType: ProductTypeInput!
}

"""An input for mutations affecting `ProductType`"""
input ProductTypeInput {
  id: Int
  typeName: String
  taxes: String
  isShippable: String
  metaUrl: String
  metaDescription: String
  filterOptions: String
  productType: String
  prodId: BigInt!
  products: String
}

"""The output of our create `Product` mutation."""
type CreateProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Product` that was created by this mutation."""
  product: Product

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Product`. May be used by Relay 1."""
  productEdge(
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge
}

"""All input for the create `Product` mutation."""
input CreateProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Product` to be created by this mutation."""
  product: ProductInput!
}

"""An input for mutations affecting `Product`"""
input ProductInput {
  id: BigInt
  sku: BigInt!
  thumbnail: String
  name: String!
  price: String
  quantityPerSource: String
  salableQuantity: String
  visibility: String
  status: Boolean
  websites: String
  product: String
  taxClass: String
  stockStatus: String
  weight: String
  categories: String
  createdAt: Datetime
  country: String
  size: String
  format: String
  height: String
  content: String
  shortDescription: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  file: String
  manufacture: String
  attributes: String
  brand: String
  contract: String
  costString: String
  customerType: String
  family: String
  manufacturerPartNumber: String
  occassions: String
  partNumber: String
  relatedProduct: BigInt
  tags: String
  types: String
  variants: String
  zone: String
  brands: String
  coupons: String
  creditMemos: String
  manufacturer: String
  mediamanager: String
  occassionsOccassionsToproducts: String
  orders: String
  otherProducts: String
  productAttribute: String
  productTypes: String
  products: String
  quotes: String
  rating: String
  returns: String
  taxRate: String
  taxRule: String
  trainings: String
  workspaces: String
}

"""The output of our create `Project` mutation."""
type CreateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was created by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""All input for the create `Project` mutation."""
input CreateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Project` to be created by this mutation."""
  project: ProjectInput!
}

"""An input for mutations affecting `Project`"""
input ProjectInput {
  id: BigInt
  name: String
  projectManager: String
  startDate: String
  endDate: String
  resource: String
  considerworkingdays: String
  projectTemplate: String
  status: String
  createdAt: Datetime
  assignee: String
  custId: Int
  doing: String
  done: String
  goalCollaborators: String
  goalMeasurement: String
  goalName: String
  goalPrivacy: String
  goalProgressSource: String
  goalTimeperiod: String
  goalUpdatemethod: String
  priority: String
  sectionRule: String
  staffId: Int
  taskId: BigInt
  ticketId: BigInt
  customers: String
  tasks: String
  ticketing: String
  users: String
  workspaces: String
  tags: String
  product: String
  websites: String
  method: String
  zone: String
  type: String
  team: String
  categories: String
  company: String
  file: String
}

"""The output of our create `Provider` mutation."""
type CreateProviderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Provider` that was created by this mutation."""
  provider: Provider

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Provider`. May be used by Relay 1."""
  providerEdge(
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProvidersEdge
}

"""All input for the create `Provider` mutation."""
input CreateProviderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Provider` to be created by this mutation."""
  provider: ProviderInput!
}

"""An input for mutations affecting `Provider`"""
input ProviderInput {
  id: BigInt
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String!
  active: String
}

"""The output of our create `Quote` mutation."""
type CreateQuotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Quote` that was created by this mutation."""
  quote: Quote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Quote`. May be used by Relay 1."""
  quoteEdge(
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): QuotesEdge
}

"""All input for the create `Quote` mutation."""
input CreateQuoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Quote` to be created by this mutation."""
  quote: QuoteInput!
}

"""An input for mutations affecting `Quote`"""
input QuoteInput {
  id: Int
  name: String!
  grandTotal: String
  createdAt: Datetime
  categories: String
  validUntil: String
  quoteStage: String
  customers: String
  custId: Int!
  prodId: BigInt!
  orderId: Int!
  account: String
  approvalIssues: String
  approvalStatus: String
  assignedTo: String
  billingCity: String
  billingCountry: String
  billingPostal: String
  billingState: String
  billingStreet: String
  contact: String
  currency: String
  discount: String
  invoiceStatus: String
  lineItemDiscount: String
  lineItemGroupTotal: String
  lineItemName: String
  lineItemSubtotal: String
  lineItemTax: String
  lineItemTotal: String
  paymentTerms: String
  shipping: String
  shippingCity: String
  shippingCountry: String
  shippingPostal: String
  shippingState: String
  shippingStreet: String
  shippingTax: String
  subtotal: String
  tax: String
  total: String
  customersCustomersToquotes: String
  orders: String
  productsProductsToquotes: String
}

"""The output of our create `Return` mutation."""
type CreateReturnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Return` that was created by this mutation."""
  return: Return

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Return`. May be used by Relay 1."""
  returnEdge(
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReturnsEdge
}

"""All input for the create `Return` mutation."""
input CreateReturnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Return` to be created by this mutation."""
  return: ReturnInput!
}

"""An input for mutations affecting `Return`"""
input ReturnInput {
  id: BigInt
  createdAt: Datetime
  name: String
  validity: String
  returnPrefix: String
  customers: String
  products: String
  type: String
  description: String
  shippingNumber: String
  shippingDescription: String
  status: String
  liquidationReason: String
  media: String
  weight: String
  height: String
  howShipped: String
  location: String
  shipTo: String
  caseId: String
}

"""The output of our create `Review` mutation."""
type CreateReviewPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Review` that was created by this mutation."""
  review: Review

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Review`. May be used by Relay 1."""
  reviewEdge(
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReviewsEdge
}

"""All input for the create `Review` mutation."""
input CreateReviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Review` to be created by this mutation."""
  review: ReviewInput!
}

"""An input for mutations affecting `Review`"""
input ReviewInput {
  id: Int
  firstName: String
  lastName: String
  content: String
  websites: String
  createdAt: Datetime
  shopId: Int!
  commentId: Int!
}

"""The output of our create `Reward` mutation."""
type CreateRewardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Reward` that was created by this mutation."""
  reward: Reward

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Reward`. May be used by Relay 1."""
  rewardEdge(
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RewardsEdge
}

"""All input for the create `Reward` mutation."""
input CreateRewardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Reward` to be created by this mutation."""
  reward: RewardInput!
}

"""An input for mutations affecting `Reward`"""
input RewardInput {
  id: Int
  name: String!
  slug: String
  level: String
  createdAt: Datetime
  coupons: String
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""The output of our create `Role` mutation."""
type CreateRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Role` that was created by this mutation."""
  role: Role

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Role`. May be used by Relay 1."""
  roleEdge(
    """The method to use when ordering `Role`."""
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesEdge
}

"""All input for the create `Role` mutation."""
input CreateRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Role` to be created by this mutation."""
  role: RoleInput!
}

"""An input for mutations affecting `Role`"""
input RoleInput {
  id: Int
  roleName: String!
  content: String
  createdAt: Datetime
}

"""The output of our create `Scheduler` mutation."""
type CreateSchedulerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Scheduler` that was created by this mutation."""
  scheduler: Scheduler

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Scheduler`. May be used by Relay 1."""
  schedulerEdge(
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SchedulersEdge
}

"""All input for the create `Scheduler` mutation."""
input CreateSchedulerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Scheduler` to be created by this mutation."""
  scheduler: SchedulerInput!
}

"""An input for mutations affecting `Scheduler`"""
input SchedulerInput {
  id: BigInt
  createdAt: Datetime
  endDate: String
  level: String
  login: String
  notes: String
  startDate: String
  whid: String
  label: String
  public: String
  permission: String
  name: String
}

"""The output of our create `Segment` mutation."""
type CreateSegmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Segment` that was created by this mutation."""
  segment: Segment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Segment`. May be used by Relay 1."""
  segmentEdge(
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SegmentsEdge
}

"""All input for the create `Segment` mutation."""
input CreateSegmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Segment` to be created by this mutation."""
  segment: SegmentInput!
}

"""An input for mutations affecting `Segment`"""
input SegmentInput {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  website: String
  status: String
  applyTo: String
  customers: String
}

"""The output of our create `Setting` mutation."""
type CreateSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Setting` that was created by this mutation."""
  setting: Setting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsEdge
}

"""All input for the create `Setting` mutation."""
input CreateSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Setting` to be created by this mutation."""
  setting: SettingInput!
}

"""An input for mutations affecting `Setting`"""
input SettingInput {
  id: BigInt
  createdAt: Datetime
  storeName: String
  storePhone: String
  storeHours: String
  country: String
  region: String
  zipcode: String
  city: String
  address: String
  addressTwo: String
  vatNumber: String
  allowState: String
  stateRequiredFor: String
  allowCountries: String
  defaultCountry: String
  optionalZip: String
  europeanUnionCountries: String
  topDestinations: String
  baseCurrency: String
  defaultCurrency: String
  allowedCurrency: String
  siteName: String
  siteWebsite: String
  sentryDsn: String
  awsS3: String
  databaseUrl: String
  isPublic: String
  type: String
  googleAnalytics: String
  searchSetting: String
  mailServer: String
  siteTagline: String
}

"""The output of our create `Shipment` mutation."""
type CreateShipmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Shipment` that was created by this mutation."""
  shipment: Shipment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Shipment`. May be used by Relay 1."""
  shipmentEdge(
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShipmentsEdge
}

"""All input for the create `Shipment` mutation."""
input CreateShipmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Shipment` to be created by this mutation."""
  shipment: ShipmentInput!
}

"""An input for mutations affecting `Shipment`"""
input ShipmentInput {
  product: String
  speedGrade: String
  shipDate: Datetime
  carrierName: String!
  transitTime: String
  trackingUrl: String
  image: String
  id: BigInt
  clientId: String
  clientSecret: String
  country: String
  website: String
}

"""The output of our create `State` mutation."""
type CreateStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `State` that was created by this mutation."""
  state: State

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `State`. May be used by Relay 1."""
  stateEdge(
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatesEdge
}

"""All input for the create `State` mutation."""
input CreateStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `State` to be created by this mutation."""
  state: StateInput!
}

"""An input for mutations affecting `State`"""
input StateInput {
  id: Int
  name: String!
  description: String
  country: String
  image: String
  trainings: String
}

"""The output of our create `Tag` mutation."""
type CreateTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Tag` that was created by this mutation."""
  tag: Tag

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsEdge
}

"""All input for the create `Tag` mutation."""
input CreateTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Tag` to be created by this mutation."""
  tag: TagInput!
}

"""An input for mutations affecting `Tag`"""
input TagInput {
  id: Int
  name: String!
  excerpt: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""The output of our create `Tax` mutation."""
type CreateTaxPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Tax` that was created by this mutation."""
  tax: Tax

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Tax`. May be used by Relay 1."""
  taxEdge(
    """The method to use when ordering `Tax`."""
    orderBy: [TaxesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxesEdge
}

"""All input for the create `Tax` mutation."""
input CreateTaxInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Tax` to be created by this mutation."""
  tax: TaxInput!
}

"""An input for mutations affecting `Tax`"""
input TaxInput {
  id: Int
  taxIdentifier: String!
  postcode: String
  state: String
  country: String
  ratePercent: String
  taxDefault: String
  products: String
  taxRuleName: String
  taxCategory: String
}

"""The output of our create `Theme` mutation."""
type CreateThemePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Theme` that was created by this mutation."""
  theme: Theme

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Theme`. May be used by Relay 1."""
  themeEdge(
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ThemesEdge
}

"""All input for the create `Theme` mutation."""
input CreateThemeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Theme` to be created by this mutation."""
  theme: ThemeInput!
}

"""An input for mutations affecting `Theme`"""
input ThemeInput {
  id: Int
  title: String
  parentTheme: String
  themePath: String
  action: String
  websiteId: BigInt!
  websites: String!
}

"""The output of our create `Ticketing` mutation."""
type CreateTicketingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ticketing` that was created by this mutation."""
  ticketing: Ticketing

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Ticketing`. May be used by Relay 1."""
  ticketingEdge(
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TicketingsEdge
}

"""All input for the create `Ticketing` mutation."""
input CreateTicketingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Ticketing` to be created by this mutation."""
  ticketing: TicketingInput!
}

"""An input for mutations affecting `Ticketing`"""
input TicketingInput {
  id: BigInt
  createdAt: Datetime
  name: String
  location: String
  date: String
  severity: String
  team: String
  requester: String
  requesterEmail: String
  content: String
  department: String
  media: String
  projects: String
  ticketType: String
  comment: String
  products: String
  priority: String
  status: String
  resolution: String
  assignedTo: String
  dateModified: Datetime
  accountName: String
  level: String
  projectsProjectsToticketing: String
}

"""The output of our create `Transaction` mutation."""
type CreateTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transaction` that was created by this mutation."""
  transaction: Transaction

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""All input for the create `Transaction` mutation."""
input CreateTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Transaction` to be created by this mutation."""
  transaction: TransactionInput!
}

"""An input for mutations affecting `Transaction`"""
input TransactionInput {
  id: Int
  orderId: Int!
  transactionId: Int!
  parentTransactionId: Int!
  created: Datetime
  paymentMethod: BigInt!
  closed: String
  customerPayment: String
  orders: String
}

"""The output of our create `UploadFile` mutation."""
type CreateUploadFilePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UploadFile` that was created by this mutation."""
  uploadFile: UploadFile

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UploadFile`. May be used by Relay 1."""
  uploadFileEdge(
    """The method to use when ordering `UploadFile`."""
    orderBy: [UploadFilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UploadFilesEdge
}

"""All input for the create `UploadFile` mutation."""
input CreateUploadFileInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `UploadFile` to be created by this mutation."""
  uploadFile: UploadFileInput!
}

"""An input for mutations affecting `UploadFile`"""
input UploadFileInput {
  id: Int
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: BigFloat!
  url: String!
  previewUrl: String
  provider: String!
  providerMetadata: JSON
  createdBy: Int
  updatedBy: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  id: BigInt
  username: String!
  firstName: String!
  lastName: String
  email: String!
  password: String!
  interfaceLocale: String
  value: String
  permissions: String
  createdAt: Datetime
  emails: String
  mediamanager: String
  messages: String
  projects: String
  workspaces: String
}

"""The output of our create `Vendor` mutation."""
type CreateVendorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Vendor` that was created by this mutation."""
  vendor: Vendor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Vendor`. May be used by Relay 1."""
  vendorEdge(
    """The method to use when ordering `Vendor`."""
    orderBy: [VendorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VendorsEdge
}

"""All input for the create `Vendor` mutation."""
input CreateVendorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Vendor` to be created by this mutation."""
  vendor: VendorInput!
}

"""An input for mutations affecting `Vendor`"""
input VendorInput {
  id: Int
  name: String!
  description: String
  image: String
  website: String
  products: String
  articles: String
  customers: String
  comments: String
  coupons: String
  categories: String
  polls: String
  quotes: String
  reviews: String
  giftCertificates: String
  rating: String
  tags: String
  users: String
  invoices: String
  reports: String
  rewardPoints: String
  specialDiscounts: String
  statistics: String
  stocks: String
  country: String
  physicalStore: String
  type: String
  workspaces: String
}

"""The output of our create `Visit` mutation."""
type CreateVisitPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Visit` that was created by this mutation."""
  visit: Visit

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Visit`. May be used by Relay 1."""
  visitEdge(
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VisitsEdge
}

"""All input for the create `Visit` mutation."""
input CreateVisitInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Visit` to be created by this mutation."""
  visit: VisitInput!
}

"""An input for mutations affecting `Visit`"""
input VisitInput {
  id: BigInt
  createdAt: Datetime
  location: String
  username: String
  reason: String
  content: String
  emergency: String
  startDate: String
  endDate: String
  task: String
  meeting: String
}

"""The output of our create `Warehouse` mutation."""
type CreateWarehousePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Warehouse` that was created by this mutation."""
  warehouse: Warehouse

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Warehouse`. May be used by Relay 1."""
  warehouseEdge(
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WarehousesEdge
}

"""All input for the create `Warehouse` mutation."""
input CreateWarehouseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Warehouse` to be created by this mutation."""
  warehouse: WarehouseInput!
}

"""An input for mutations affecting `Warehouse`"""
input WarehouseInput {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  city: String
  state: String
  country: String
  postal: String
  status: String
  image: String
  products: String
  category: String
  isPublic: String
}

"""The output of our create `Webhook` mutation."""
type CreateWebhookPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Webhook` that was created by this mutation."""
  webhook: Webhook

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Webhook`. May be used by Relay 1."""
  webhookEdge(
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhooksEdge
}

"""All input for the create `Webhook` mutation."""
input CreateWebhookInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Webhook` to be created by this mutation."""
  webhook: WebhookInput!
}

"""An input for mutations affecting `Webhook`"""
input WebhookInput {
  id: BigInt
  createdAt: Datetime
  name: String!
  url: String!
  headers: String
  create: String
  retrieve: String
  update: String
  delete: String
  publish: String
  unpublish: String
}

"""The output of our create `Website` mutation."""
type CreateWebsitePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Website` that was created by this mutation."""
  website: Website

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Website`. May be used by Relay 1."""
  websiteEdge(
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebsitesEdge
}

"""All input for the create `Website` mutation."""
input CreateWebsiteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Website` to be created by this mutation."""
  website: WebsiteInput!
}

"""An input for mutations affecting `Website`"""
input WebsiteInput {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  shop: String
  store: String
  category: String
  themes: String
  image: String
}

"""The output of our create `Wishlist` mutation."""
type CreateWishlistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Wishlist` that was created by this mutation."""
  wishlist: Wishlist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Wishlist`. May be used by Relay 1."""
  wishlistEdge(
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): WishlistsEdge
}

"""All input for the create `Wishlist` mutation."""
input CreateWishlistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Wishlist` to be created by this mutation."""
  wishlist: WishlistInput!
}

"""An input for mutations affecting `Wishlist`"""
input WishlistInput {
  id: BigInt
  createdAt: Datetime
  name: String
  customers: String
  visibility: String
  products: String
  quantity: String
  occassions: String
}

"""The output of our create `Workspace` mutation."""
type CreateWorkspacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Workspace` that was created by this mutation."""
  workspace: Workspace

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Workspace`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspacesEdge
}

"""All input for the create `Workspace` mutation."""
input CreateWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Workspace` to be created by this mutation."""
  workspace: WorkspaceInput!
}

"""An input for mutations affecting `Workspace`"""
input WorkspaceInput {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  description: String
  customers: Int
  users: Int
  products: BigInt
  tasks: BigInt
  brands: BigInt
  shops: Int
  category: Int
  isPublic: Boolean
  projects: BigInt
  author: String
  media: String
  brandsBrandsToworkspaces: String
  categories: String
  customersCustomersToworkspaces: String
  productsProductsToworkspaces: String
  projectsProjectsToworkspaces: String
  shopsShopsToworkspaces: String
  tasksTasksToworkspaces: String
  usersUsersToworkspaces: String
}

"""The output of our create `Zone` mutation."""
type CreateZonePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Zone` that was created by this mutation."""
  zone: Zone

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Zone`. May be used by Relay 1."""
  zoneEdge(
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ZonesEdge
}

"""All input for the create `Zone` mutation."""
input CreateZoneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Zone` to be created by this mutation."""
  zone: ZoneInput!
}

"""An input for mutations affecting `Zone`"""
input ZoneInput {
  id: BigInt
  createdAt: Datetime
  name: String
  updatedAt: Datetime
  scope: String
  type: String
  country: String
  code: String
}

"""The output of our update `_PrismaMigration` mutation."""
type UpdatePrismaMigrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `_PrismaMigration` that was updated by this mutation."""
  _prismaMigration: _PrismaMigration

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `_PrismaMigration`. May be used by Relay 1."""
  _prismaMigrationEdge(
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): _PrismaMigrationsEdge
}

"""All input for the `updatePrismaMigrationByNodeId` mutation."""
input UpdatePrismaMigrationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `_PrismaMigration` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `_PrismaMigration` being updated.
  """
  patch: _PrismaMigrationPatch!
}

"""
Represents an update to a `_PrismaMigration`. Fields that are set will be updated.
"""
input _PrismaMigrationPatch {
  id: String
  checksum: String
  finishedAt: Datetime
  migrationName: String
  logs: String
  rolledBackAt: Datetime
  startedAt: Datetime
  appliedStepsCount: Int
}

"""All input for the `updatePrismaMigration` mutation."""
input UpdatePrismaMigrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `_PrismaMigration` being updated.
  """
  patch: _PrismaMigrationPatch!
  id: String!
}

"""The output of our update `Agreement` mutation."""
type UpdateAgreementPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Agreement` that was updated by this mutation."""
  agreement: Agreement

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Agreement`. May be used by Relay 1."""
  agreementEdge(
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgreementsEdge
}

"""All input for the `updateAgreementByNodeId` mutation."""
input UpdateAgreementByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Agreement` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Agreement` being updated.
  """
  patch: AgreementPatch!
}

"""
Represents an update to a `Agreement`. Fields that are set will be updated.
"""
input AgreementPatch {
  id: BigInt
  referenceId: String
  created: Datetime
  updated: Datetime
  content: String
  name: String
  image: String
  excerpt: String
  type: String
  userId: String
  shopId: String
  mediamanager: String
}

"""All input for the `updateAgreement` mutation."""
input UpdateAgreementInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Agreement` being updated.
  """
  patch: AgreementPatch!
  id: BigInt!
}

"""The output of our update `Apitoken` mutation."""
type UpdateApitokenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Apitoken` that was updated by this mutation."""
  apitoken: Apitoken

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Apitoken`. May be used by Relay 1."""
  apitokenEdge(
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): ApitokensEdge
}

"""All input for the `updateApitokenByNodeId` mutation."""
input UpdateApitokenByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Apitoken` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Apitoken` being updated.
  """
  patch: ApitokenPatch!
}

"""
Represents an update to a `Apitoken`. Fields that are set will be updated.
"""
input ApitokenPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  tokenType: String
  description: String
  token: BigInt
}

"""All input for the `updateApitoken` mutation."""
input UpdateApitokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Apitoken` being updated.
  """
  patch: ApitokenPatch!
  id: BigInt!
}

"""The output of our update `Article` mutation."""
type UpdateArticlePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Article` that was updated by this mutation."""
  article: Article

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Article`. May be used by Relay 1."""
  articleEdge(
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArticlesEdge
}

"""All input for the `updateArticleByNodeId` mutation."""
input UpdateArticleByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Article` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Article` being updated.
  """
  patch: ArticlePatch!
}

"""
Represents an update to a `Article`. Fields that are set will be updated.
"""
input ArticlePatch {
  id: Int
  name: String
  excerpt: String
  content: String
  image: String
  categories: String
  customers: String
  users: String
  published: String
  custId: String
  isPublic: String
  metaDescription: String
  metaName: String
  metaUrl: String
  tags: String
  type: String
}

"""All input for the `updateArticle` mutation."""
input UpdateArticleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Article` being updated.
  """
  patch: ArticlePatch!
  id: Int!
}

"""The output of our update `Attribute` mutation."""
type UpdateAttributePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Attribute` that was updated by this mutation."""
  attribute: Attribute

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Attribute`. May be used by Relay 1."""
  attributeEdge(
    """The method to use when ordering `Attribute`."""
    orderBy: [AttributesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AttributesEdge
}

"""All input for the `updateAttributeByNodeId` mutation."""
input UpdateAttributeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Attribute` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Attribute` being updated.
  """
  patch: AttributePatch!
}

"""
Represents an update to a `Attribute`. Fields that are set will be updated.
"""
input AttributePatch {
  id: Int
  defaultLabel: String
  attributeCode: String
  filterOptions: String
  useSearch: String
  layeredNavigation: Boolean
  searchResultsLayeredNavigation: Boolean
  position: String
  promoRuleConditions: Boolean
  allowHtmlTagsStorefront: Boolean
  visibleCatalogPagesStorefront: Boolean
  usedProductListing: Boolean
  usedSortingProductListing: Boolean
  prodId: BigInt
  attributeClass: String
  attributeValue: String
  columnOptions: String
  facetedNavigation: Boolean
  isPublic: String
  metaDescription: String
  metaName: Boolean
  metaUrl: String
  productAttributeSet: String
  products: String
}

"""All input for the `updateAttribute` mutation."""
input UpdateAttributeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Attribute` being updated.
  """
  patch: AttributePatch!
  id: Int!
}

"""The output of our update `Brand` mutation."""
type UpdateBrandPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Brand` that was updated by this mutation."""
  brand: Brand

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Brand`. May be used by Relay 1."""
  brandEdge(
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BrandsEdge
}

"""All input for the `updateBrandByNodeId` mutation."""
input UpdateBrandByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Brand` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Brand` being updated.
  """
  patch: BrandPatch!
}

"""
Represents an update to a `Brand`. Fields that are set will be updated.
"""
input BrandPatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
  mediamanager: String
  products: String
  workspaces: String
}

"""All input for the `updateBrand` mutation."""
input UpdateBrandInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Brand` being updated.
  """
  patch: BrandPatch!
  id: BigInt!
}

"""The output of our update `Category` mutation."""
type UpdateCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Category` that was updated by this mutation."""
  category: Category

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""All input for the `updateCategoryByNodeId` mutation."""
input UpdateCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Category` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Category` being updated.
  """
  patch: CategoryPatch!
}

"""
Represents an update to a `Category`. Fields that are set will be updated.
"""
input CategoryPatch {
  id: Int
  thumbnail: String
  name: String
  visibility: String
  status: Boolean
  websites: String
  product: String
  country: String
  description: String
  content: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  workspaces: String
}

"""All input for the `updateCategory` mutation."""
input UpdateCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Category` being updated.
  """
  patch: CategoryPatch!
  id: Int!
}

"""The output of our update `Channel` mutation."""
type UpdateChannelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Channel` that was updated by this mutation."""
  channel: Channel

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Channel`. May be used by Relay 1."""
  channelEdge(
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChannelsEdge
}

"""All input for the `updateChannelByNodeId` mutation."""
input UpdateChannelByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Channel` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Channel` being updated.
  """
  patch: ChannelPatch!
}

"""
Represents an update to a `Channel`. Fields that are set will be updated.
"""
input ChannelPatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  currency: String
  defaultLang: String
  includeTax: String
  defaultZone: String
  defaultShipping: String
  clientId: String
  clientSecret: String
}

"""All input for the `updateChannel` mutation."""
input UpdateChannelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Channel` being updated.
  """
  patch: ChannelPatch!
  id: BigInt!
}

"""The output of our update `Checklist` mutation."""
type UpdateChecklistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Checklist` that was updated by this mutation."""
  checklist: Checklist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Checklist`. May be used by Relay 1."""
  checklistEdge(
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChecklistsEdge
}

"""All input for the `updateChecklistByNodeId` mutation."""
input UpdateChecklistByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Checklist` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Checklist` being updated.
  """
  patch: ChecklistPatch!
}

"""
Represents an update to a `Checklist`. Fields that are set will be updated.
"""
input ChecklistPatch {
  id: BigInt
  createdAt: Datetime
  username: String
  location: String
  regionalManager: String
  manager: String
  description: String
  ticket: String
  project: String
  region: String
  country: String
  media: String
  prodId: String
  trainings: String
  task: String
  type: String
}

"""All input for the `updateChecklist` mutation."""
input UpdateChecklistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Checklist` being updated.
  """
  patch: ChecklistPatch!
  id: BigInt!
}

"""The output of our update `City` mutation."""
type UpdateCityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `City` that was updated by this mutation."""
  city: City

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `City`. May be used by Relay 1."""
  cityEdge(
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge
}

"""All input for the `updateCityByNodeId` mutation."""
input UpdateCityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `City` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `City` being updated.
  """
  patch: CityPatch!
}

"""Represents an update to a `City`. Fields that are set will be updated."""
input CityPatch {
  id: Int
  name: String
  description: String
  state: String
  country: String
  postalCode: String
  image: String
}

"""All input for the `updateCity` mutation."""
input UpdateCityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `City` being updated.
  """
  patch: CityPatch!
  id: Int!
}

"""The output of our update `Collection` mutation."""
type UpdateCollectionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Collection` that was updated by this mutation."""
  collection: Collection

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Collection`. May be used by Relay 1."""
  collectionEdge(
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CollectionsEdge
}

"""All input for the `updateCollectionByNodeId` mutation."""
input UpdateCollectionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Collection` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Collection` being updated.
  """
  patch: CollectionPatch!
}

"""
Represents an update to a `Collection`. Fields that are set will be updated.
"""
input CollectionPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  image: String
  product: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
}

"""All input for the `updateCollection` mutation."""
input UpdateCollectionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Collection` being updated.
  """
  patch: CollectionPatch!
  id: BigInt!
}

"""The output of our update `ContentType` mutation."""
type UpdateContentTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ContentType` that was updated by this mutation."""
  contentType: ContentType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ContentType`. May be used by Relay 1."""
  contentTypeEdge(
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContentTypesEdge
}

"""All input for the `updateContentTypeByNodeId` mutation."""
input UpdateContentTypeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ContentType` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ContentType` being updated.
  """
  patch: ContentTypePatch!
}

"""
Represents an update to a `ContentType`. Fields that are set will be updated.
"""
input ContentTypePatch {
  id: BigInt
  createdAt: Datetime
  text: String
  number: BigFloat
  json: JSON
  link: String
  email: String
  uid: String
  date: Date
  time: Time
  timestamp: Datetime
  boolean: Boolean
  richText: String
  password: String
  media: String
  databaseName: String
}

"""All input for the `updateContentType` mutation."""
input UpdateContentTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ContentType` being updated.
  """
  patch: ContentTypePatch!
  id: BigInt!
}

"""The output of our update `Country` mutation."""
type UpdateCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Country` that was updated by this mutation."""
  country: Country

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Country`. May be used by Relay 1."""
  countryEdge(
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge
}

"""All input for the `updateCountryByNodeId` mutation."""
input UpdateCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Country` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Country` being updated.
  """
  patch: CountryPatch!
}

"""
Represents an update to a `Country`. Fields that are set will be updated.
"""
input CountryPatch {
  id: Int
  name: String
  description: String
  image: String
  region: String
  trainings: String
}

"""All input for the `updateCountry` mutation."""
input UpdateCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Country` being updated.
  """
  patch: CountryPatch!
  id: Int!
}

"""The output of our update `Currency` mutation."""
type UpdateCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Currency` that was updated by this mutation."""
  currency: Currency

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
}

"""All input for the `updateCurrencyByNodeId` mutation."""
input UpdateCurrencyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Currency` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Currency` being updated.
  """
  patch: CurrencyPatch!
}

"""
Represents an update to a `Currency`. Fields that are set will be updated.
"""
input CurrencyPatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  region: String
  symbol: String
  useStandard: String
}

"""All input for the `updateCurrency` mutation."""
input UpdateCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Currency` being updated.
  """
  patch: CurrencyPatch!
  id: BigInt!
}

"""The output of our update `Customer` mutation."""
type UpdateCustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Customer` that was updated by this mutation."""
  customer: Customer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Customer`. May be used by Relay 1."""
  customerEdge(
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersEdge
}

"""All input for the `updateCustomerByNodeId` mutation."""
input UpdateCustomerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Customer` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Customer` being updated.
  """
  patch: CustomerPatch!
}

"""
Represents an update to a `Customer`. Fields that are set will be updated.
"""
input CustomerPatch {
  id: Int
  thumbnail: String
  namePrefix: String
  firstName: String
  middleName: String
  lastName: String
  email: String
  customerGroup: String
  phone: String
  zipcode: String
  nameSuffix: String
  websites: String
  product: String
  country: String
  state: String
  customerSince: Datetime
  confirmedEmail: String
  dateOfBirth: String
  taxVatNumber: String
  gender: String
  description: String
  shortDescription: String
  image: String
  address: String
  addressTwo: String
  paymentType: String
  username: String
  password: String
  comments: String
  creditMemos: String
  customerPayment: String
  emails: String
  mediamanager: String
  messages: String
  newsletterSubscribers: String
  orders: String
  projects: String
  quotes: String
  returns: String
  workspaces: String
}

"""All input for the `updateCustomer` mutation."""
input UpdateCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Customer` being updated.
  """
  patch: CustomerPatch!
  id: Int!
}

"""The output of our update `Dashboard` mutation."""
type UpdateDashboardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Dashboard` that was updated by this mutation."""
  dashboard: Dashboard

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Dashboard`. May be used by Relay 1."""
  dashboardEdge(
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DashboardsEdge
}

"""All input for the `updateDashboardByNodeId` mutation."""
input UpdateDashboardByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Dashboard` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Dashboard` being updated.
  """
  patch: DashboardPatch!
}

"""
Represents an update to a `Dashboard`. Fields that are set will be updated.
"""
input DashboardPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  clientId: String
  clientSecret: String
  privacy: String
  category: String
  url: String
  media: String
  reports: String
  tasks: String
  projects: String
  tickets: String
  customers: String
  checklists: String
  visits: String
  users: String
  products: String
  articles: String
  sales: String
  logo: String
  content: String
  published: String
}

"""All input for the `updateDashboard` mutation."""
input UpdateDashboardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Dashboard` being updated.
  """
  patch: DashboardPatch!
  id: BigInt!
}

"""All input for the `updateDashboardByName` mutation."""
input UpdateDashboardByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Dashboard` being updated.
  """
  patch: DashboardPatch!
  name: String!
}

"""The output of our update `Deepdive` mutation."""
type UpdateDeepdivePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Deepdive` that was updated by this mutation."""
  deepdive: Deepdive

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Deepdive`. May be used by Relay 1."""
  deepdiveEdge(
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DeepdivesEdge
}

"""All input for the `updateDeepdiveByNodeId` mutation."""
input UpdateDeepdiveByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Deepdive` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Deepdive` being updated.
  """
  patch: DeepdivePatch!
}

"""
Represents an update to a `Deepdive`. Fields that are set will be updated.
"""
input DeepdivePatch {
  id: BigInt
  createdAt: Datetime
  endDate: String
  content: String
  attendees: String
  login: String
  startDate: String
  whid: String
}

"""All input for the `updateDeepdive` mutation."""
input UpdateDeepdiveInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Deepdive` being updated.
  """
  patch: DeepdivePatch!
  id: BigInt!
}

"""The output of our update `Discount` mutation."""
type UpdateDiscountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Discount` that was updated by this mutation."""
  discount: Discount

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Discount`. May be used by Relay 1."""
  discountEdge(
    """The method to use when ordering `Discount`."""
    orderBy: [DiscountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiscountsEdge
}

"""All input for the `updateDiscountByNodeId` mutation."""
input UpdateDiscountByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Discount` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Discount` being updated.
  """
  patch: DiscountPatch!
}

"""
Represents an update to a `Discount`. Fields that are set will be updated.
"""
input DiscountPatch {
  id: BigInt
  name: String
  excerpt: String
  discount: String
  image: String
  published: Datetime
  specialOffers: String
  rewards: String
  coupons: String
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
  type: String
  creditMemo: String
  billToName: String
  orderNumber: String
  refunded: String
  status: String
}

"""All input for the `updateDiscount` mutation."""
input UpdateDiscountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Discount` being updated.
  """
  patch: DiscountPatch!
  id: BigInt!
}

"""The output of our update `Endofshift` mutation."""
type UpdateEndofshiftPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Endofshift` that was updated by this mutation."""
  endofshift: Endofshift

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Endofshift`. May be used by Relay 1."""
  endofshiftEdge(
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EndofshiftsEdge
}

"""All input for the `updateEndofshiftByNodeId` mutation."""
input UpdateEndofshiftByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Endofshift` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Endofshift` being updated.
  """
  patch: EndofshiftPatch!
}

"""
Represents an update to a `Endofshift`. Fields that are set will be updated.
"""
input EndofshiftPatch {
  id: BigInt
  createdAt: Datetime
  content: String
  login: String
  mcms: String
  nextShift: String
  projects: String
  tickets: String
  whid: String
}

"""All input for the `updateEndofshift` mutation."""
input UpdateEndofshiftInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Endofshift` being updated.
  """
  patch: EndofshiftPatch!
  id: BigInt!
}

"""The output of our update `Event` mutation."""
type UpdateEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was updated by this mutation."""
  event: Event

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the `updateEventByNodeId` mutation."""
input UpdateEventByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Event` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Event` being updated.
  """
  patch: EventPatch!
}

"""
Represents an update to a `Event`. Fields that are set will be updated.
"""
input EventPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  tickets: String
  image: String
  start: String
  end: String
  category: String
  city: String
  state: String
  country: String
  postalcode: String
  type: String
  invitationEmail: String
  invitationBillingAddress: String
  invitationGrandTotalPurchased: String
  invitationInvoiceDate: String
  invitationOrderNumber: String
  invitationPaymentMethod: String
  invitationShippingAddress: String
  invitationCustomerName: String
  invitationStatus: String
  media: String
}

"""All input for the `updateEvent` mutation."""
input UpdateEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Event` being updated.
  """
  patch: EventPatch!
  id: BigInt!
}

"""The output of our update `Fullfillment` mutation."""
type UpdateFullfillmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Fullfillment` that was updated by this mutation."""
  fullfillment: Fullfillment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Fullfillment`. May be used by Relay 1."""
  fullfillmentEdge(
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FullfillmentsEdge
}

"""All input for the `updateFullfillmentByNodeId` mutation."""
input UpdateFullfillmentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Fullfillment` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Fullfillment` being updated.
  """
  patch: FullfillmentPatch!
}

"""
Represents an update to a `Fullfillment`. Fields that are set will be updated.
"""
input FullfillmentPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  shippingZones: String
  company: String
  address: String
  addressTwo: String
  city: String
  state: String
  zipcode: String
  country: String
  countryArea: String
  phone: String
  pickup: String
  stock: String
}

"""All input for the `updateFullfillment` mutation."""
input UpdateFullfillmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Fullfillment` being updated.
  """
  patch: FullfillmentPatch!
  id: BigInt!
}

"""The output of our update `Glossary` mutation."""
type UpdateGlossaryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Glossary` that was updated by this mutation."""
  glossary: Glossary

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Glossary`. May be used by Relay 1."""
  glossaryEdge(
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GlossariesEdge
}

"""All input for the `updateGlossaryByNodeId` mutation."""
input UpdateGlossaryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Glossary` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Glossary` being updated.
  """
  patch: GlossaryPatch!
}

"""
Represents an update to a `Glossary`. Fields that are set will be updated.
"""
input GlossaryPatch {
  id: Int
  name: String
  content: String
  image: String
  published: Datetime
}

"""All input for the `updateGlossary` mutation."""
input UpdateGlossaryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Glossary` being updated.
  """
  patch: GlossaryPatch!
  id: Int!
}

"""The output of our update `Integration` mutation."""
type UpdateIntegrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Integration` that was updated by this mutation."""
  integration: Integration

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Integration`. May be used by Relay 1."""
  integrationEdge(
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): IntegrationsEdge
}

"""All input for the `updateIntegrationByNodeId` mutation."""
input UpdateIntegrationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Integration` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Integration` being updated.
  """
  patch: IntegrationPatch!
}

"""
Represents an update to a `Integration`. Fields that are set will be updated.
"""
input IntegrationPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  media: String
  location: String
  category: String
}

"""All input for the `updateIntegration` mutation."""
input UpdateIntegrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Integration` being updated.
  """
  patch: IntegrationPatch!
  id: BigInt!
}

"""The output of our update `Internalization` mutation."""
type UpdateInternalizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Internalization` that was updated by this mutation."""
  internalization: Internalization

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Internalization`. May be used by Relay 1."""
  internalizationEdge(
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InternalizationsEdge
}

"""All input for the `updateInternalizationByNodeId` mutation."""
input UpdateInternalizationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Internalization` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Internalization` being updated.
  """
  patch: InternalizationPatch!
}

"""
Represents an update to a `Internalization`. Fields that are set will be updated.
"""
input InternalizationPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  region: String
  description: String
  default: String
  website: String
}

"""All input for the `updateInternalization` mutation."""
input UpdateInternalizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Internalization` being updated.
  """
  patch: InternalizationPatch!
  id: BigInt!
}

"""The output of our update `Invoice` mutation."""
type UpdateInvoicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Invoice` that was updated by this mutation."""
  invoice: Invoice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Invoice`. May be used by Relay 1."""
  invoiceEdge(
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvoicesEdge
}

"""All input for the `updateInvoiceByNodeId` mutation."""
input UpdateInvoiceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Invoice` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Invoice` being updated.
  """
  patch: InvoicePatch!
}

"""
Represents an update to a `Invoice`. Fields that are set will be updated.
"""
input InvoicePatch {
  invoice: Int
  orderNumber: BigInt
  invoiceDate: Datetime
  billToName: String
  billingAddress: String
  grandTotalBase: String
  grandTotalPurchased: String
  status: String
  shippingAddress: String
  customerName: String
  email: String
  customerGroup: String
  paymentMethod: String
  shippingInformation: String
  subtotal: String
  shippingAndHandling: String
  id: BigInt
}

"""All input for the `updateInvoice` mutation."""
input UpdateInvoiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Invoice` being updated.
  """
  patch: InvoicePatch!
  id: BigInt!
}

"""The output of our update `LogIn` mutation."""
type UpdateLogInPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LogIn` that was updated by this mutation."""
  logIn: LogIn

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `LogIn`. May be used by Relay 1."""
  logInEdge(
    """The method to use when ordering `LogIn`."""
    orderBy: [LogInsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LogInsEdge
}

"""All input for the `updateLogInByNodeId` mutation."""
input UpdateLogInByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LogIn` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LogIn` being updated.
  """
  patch: LogInPatch!
}

"""
Represents an update to a `LogIn`. Fields that are set will be updated.
"""
input LogInPatch {
  id: BigInt
  createdAt: Datetime
  email: String
  password: String
  token: String
  expiresIn: String
  users: String
  username: String
}

"""All input for the `updateLogIn` mutation."""
input UpdateLogInInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LogIn` being updated.
  """
  patch: LogInPatch!
  id: BigInt!
}

"""The output of our update `Manufacturer` mutation."""
type UpdateManufacturerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Manufacturer` that was updated by this mutation."""
  manufacturer: Manufacturer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Manufacturer`. May be used by Relay 1."""
  manufacturerEdge(
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ManufacturersEdge
}

"""All input for the `updateManufacturerByNodeId` mutation."""
input UpdateManufacturerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Manufacturer` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Manufacturer` being updated.
  """
  patch: ManufacturerPatch!
}

"""
Represents an update to a `Manufacturer`. Fields that are set will be updated.
"""
input ManufacturerPatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  country: String
  state: String
  isPublic: String
  city: String
  product: BigInt
  description: String
  media: String
  products: String
}

"""All input for the `updateManufacturer` mutation."""
input UpdateManufacturerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Manufacturer` being updated.
  """
  patch: ManufacturerPatch!
  id: BigInt!
}

"""The output of our update `Mediamanager` mutation."""
type UpdateMediamanagerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Mediamanager` that was updated by this mutation."""
  mediamanager: Mediamanager

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Mediamanager`. May be used by Relay 1."""
  mediamanagerEdge(
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
  ): MediamanagersEdge
}

"""All input for the `updateMediamanagerByNodeId` mutation."""
input UpdateMediamanagerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Mediamanager` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Mediamanager` being updated.
  """
  patch: MediamanagerPatch!
}

"""
Represents an update to a `Mediamanager`. Fields that are set will be updated.
"""
input MediamanagerPatch {
  id: Int
  createdAt: Datetime
  name: String
  description: String
  media: String
  keywords: String
  tags: String
  brands: String
  status: String
  expirationDate: String
  copyright: String
  dimensions: String
  author: String
  contentType: String
  versions: String
  watermarkName: String
  watermarkDescription: String
  watermarkMedia: String
  agreements: String
  albums: String
  comment: String
  workspace: String
  taskName: String
  taskDescription: String
  taskType: String
  members: String
  products: String
  agreementsAgreementsTomediamanager: String
  brandsBrandsTomediamanager: String
  comments: String
  customers: String
  productsMediamanagerToproducts: String
  tasks: String
  users: String
}

"""All input for the `updateMediamanager` mutation."""
input UpdateMediamanagerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Mediamanager` being updated.
  """
  patch: MediamanagerPatch!
  id: Int!
}

"""The output of our update `Newsletter` mutation."""
type UpdateNewsletterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Newsletter` that was updated by this mutation."""
  newsletter: Newsletter

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Newsletter`. May be used by Relay 1."""
  newsletterEdge(
    """The method to use when ordering `Newsletter`."""
    orderBy: [NewslettersOrderBy!] = [PRIMARY_KEY_ASC]
  ): NewslettersEdge
}

"""All input for the `updateNewsletterByNodeId` mutation."""
input UpdateNewsletterByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Newsletter` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Newsletter` being updated.
  """
  patch: NewsletterPatch!
}

"""
Represents an update to a `Newsletter`. Fields that are set will be updated.
"""
input NewsletterPatch {
  id: Int
  email: String
  customerFirstName: String
  customerLastName: String
  store: String
  status: String
  websites: String
  createdAt: Datetime
  custId: Int
  customers: String
}

"""All input for the `updateNewsletter` mutation."""
input UpdateNewsletterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Newsletter` being updated.
  """
  patch: NewsletterPatch!
  id: Int!
}

"""The output of our update `Ooto` mutation."""
type UpdateOotoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ooto` that was updated by this mutation."""
  ooto: Ooto

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Ooto`. May be used by Relay 1."""
  ootoEdge(
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!] = [PRIMARY_KEY_ASC]
  ): OotosEdge
}

"""All input for the `updateOotoByNodeId` mutation."""
input UpdateOotoByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Ooto` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Ooto` being updated.
  """
  patch: OotoPatch!
}

"""Represents an update to a `Ooto`. Fields that are set will be updated."""
input OotoPatch {
  id: BigInt
  createdAt: Datetime
  login: String
  startDate: String
  endDate: String
  note: String
  usingTime: String
  location: String
}

"""All input for the `updateOoto` mutation."""
input UpdateOotoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Ooto` being updated.
  """
  patch: OotoPatch!
  id: BigInt!
}

"""The output of our update `Order` mutation."""
type UpdateOrderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Order` that was updated by this mutation."""
  order: Order

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Order`. May be used by Relay 1."""
  orderEdge(
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrdersEdge
}

"""All input for the `updateOrderByNodeId` mutation."""
input UpdateOrderByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Order` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Order` being updated.
  """
  patch: OrderPatch!
}

"""
Represents an update to a `Order`. Fields that are set will be updated.
"""
input OrderPatch {
  id: Int
  purchasePoint: Int
  purchaseDate: Datetime
  billToName: String
  shipToName: String
  grandTotalBase: Int
  grandTotalPurchased: Int
  status: Boolean
  action: Boolean
  allocatedSources: String
  braintreeTransactionSource: String
  custId: Int
  prodId: BigInt
  customers: String
  products: String
  quotes: String
  transactions: String
}

"""All input for the `updateOrder` mutation."""
input UpdateOrderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Order` being updated.
  """
  patch: OrderPatch!
  id: Int!
}

"""The output of our update `Page` mutation."""
type UpdatePagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Page` that was updated by this mutation."""
  page: Page

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Page`. May be used by Relay 1."""
  pageEdge(
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PagesEdge
}

"""All input for the `updatePageByNodeId` mutation."""
input UpdatePageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Page` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Page` being updated.
  """
  patch: PagePatch!
}

"""Represents an update to a `Page`. Fields that are set will be updated."""
input PagePatch {
  id: Int
  enablePage: Boolean
  title: String
  contentTitle: String
  content: String
  urlKey: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
}

"""All input for the `updatePage` mutation."""
input UpdatePageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Page` being updated.
  """
  patch: PagePatch!
  id: Int!
}

"""The output of our update `Partner` mutation."""
type UpdatePartnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Partner` that was updated by this mutation."""
  partner: Partner

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Partner`. May be used by Relay 1."""
  partnerEdge(
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnersEdge
}

"""All input for the `updatePartnerByNodeId` mutation."""
input UpdatePartnerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Partner` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Partner` being updated.
  """
  patch: PartnerPatch!
}

"""
Represents an update to a `Partner`. Fields that are set will be updated.
"""
input PartnerPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  address: String
  city: String
  state: String
  country: String
  isPublic: String
  businessType: String
}

"""All input for the `updatePartner` mutation."""
input UpdatePartnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Partner` being updated.
  """
  patch: PartnerPatch!
  id: BigInt!
}

"""The output of our update `Payment` mutation."""
type UpdatePaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Payment` that was updated by this mutation."""
  payment: Payment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Payment`. May be used by Relay 1."""
  paymentEdge(
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsEdge
}

"""All input for the `updatePaymentByNodeId` mutation."""
input UpdatePaymentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Payment` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Payment` being updated.
  """
  patch: PaymentPatch!
}

"""
Represents an update to a `Payment`. Fields that are set will be updated.
"""
input PaymentPatch {
  id: BigInt
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String
  active: String
  country: String
}

"""All input for the `updatePayment` mutation."""
input UpdatePaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Payment` being updated.
  """
  patch: PaymentPatch!
  id: BigInt!
}

"""The output of our update `Permission` mutation."""
type UpdatePermissionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Permission` that was updated by this mutation."""
  permission: Permission

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Permission`. May be used by Relay 1."""
  permissionEdge(
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PermissionsEdge
}

"""All input for the `updatePermissionByNodeId` mutation."""
input UpdatePermissionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Permission` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Permission` being updated.
  """
  patch: PermissionPatch!
}

"""
Represents an update to a `Permission`. Fields that are set will be updated.
"""
input PermissionPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  content: String
  create: String
  delete: String
  read: String
  role: String
  update: String
  users: String
}

"""All input for the `updatePermission` mutation."""
input UpdatePermissionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Permission` being updated.
  """
  patch: PermissionPatch!
  id: BigInt!
}

"""The output of our update `Plugin` mutation."""
type UpdatePluginPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Plugin` that was updated by this mutation."""
  plugin: Plugin

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Plugin`. May be used by Relay 1."""
  pluginEdge(
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PluginsEdge
}

"""All input for the `updatePluginByNodeId` mutation."""
input UpdatePluginByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Plugin` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Plugin` being updated.
  """
  patch: PluginPatch!
}

"""
Represents an update to a `Plugin`. Fields that are set will be updated.
"""
input PluginPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  githubLink: String
  description: String
  logo: String
  screenshots: String
  lastUpdated: Datetime
  publisherName: String
  agreeTerms: Boolean
  publisherEmail: String
}

"""All input for the `updatePlugin` mutation."""
input UpdatePluginInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Plugin` being updated.
  """
  patch: PluginPatch!
  id: BigInt!
}

"""The output of our update `ProductType` mutation."""
type UpdateProductTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProductType` that was updated by this mutation."""
  productType: ProductType

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProductType`. May be used by Relay 1."""
  productTypeEdge(
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductTypesEdge
}

"""All input for the `updateProductTypeByNodeId` mutation."""
input UpdateProductTypeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProductType` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ProductType` being updated.
  """
  patch: ProductTypePatch!
}

"""
Represents an update to a `ProductType`. Fields that are set will be updated.
"""
input ProductTypePatch {
  id: Int
  typeName: String
  taxes: String
  isShippable: String
  metaUrl: String
  metaDescription: String
  filterOptions: String
  productType: String
  prodId: BigInt
  products: String
}

"""All input for the `updateProductType` mutation."""
input UpdateProductTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ProductType` being updated.
  """
  patch: ProductTypePatch!
  id: Int!
}

"""The output of our update `Product` mutation."""
type UpdateProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Product` that was updated by this mutation."""
  product: Product

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Product`. May be used by Relay 1."""
  productEdge(
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge
}

"""All input for the `updateProductByNodeId` mutation."""
input UpdateProductByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Product` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Product` being updated.
  """
  patch: ProductPatch!
}

"""
Represents an update to a `Product`. Fields that are set will be updated.
"""
input ProductPatch {
  id: BigInt
  sku: BigInt
  thumbnail: String
  name: String
  price: String
  quantityPerSource: String
  salableQuantity: String
  visibility: String
  status: Boolean
  websites: String
  product: String
  taxClass: String
  stockStatus: String
  weight: String
  categories: String
  createdAt: Datetime
  country: String
  size: String
  format: String
  height: String
  content: String
  shortDescription: String
  image: String
  metaTitle: String
  metaKeywords: String
  metaDescription: String
  metaUrl: String
  file: String
  manufacture: String
  attributes: String
  brand: String
  contract: String
  costString: String
  customerType: String
  family: String
  manufacturerPartNumber: String
  occassions: String
  partNumber: String
  relatedProduct: BigInt
  tags: String
  types: String
  variants: String
  zone: String
  brands: String
  coupons: String
  creditMemos: String
  manufacturer: String
  mediamanager: String
  occassionsOccassionsToproducts: String
  orders: String
  otherProducts: String
  productAttribute: String
  productTypes: String
  products: String
  quotes: String
  rating: String
  returns: String
  taxRate: String
  taxRule: String
  trainings: String
  workspaces: String
}

"""All input for the `updateProduct` mutation."""
input UpdateProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Product` being updated.
  """
  patch: ProductPatch!
  id: BigInt!
}

"""The output of our update `Project` mutation."""
type UpdateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was updated by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""All input for the `updateProjectByNodeId` mutation."""
input UpdateProjectByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!
}

"""
Represents an update to a `Project`. Fields that are set will be updated.
"""
input ProjectPatch {
  id: BigInt
  name: String
  projectManager: String
  startDate: String
  endDate: String
  resource: String
  considerworkingdays: String
  projectTemplate: String
  status: String
  createdAt: Datetime
  assignee: String
  custId: Int
  doing: String
  done: String
  goalCollaborators: String
  goalMeasurement: String
  goalName: String
  goalPrivacy: String
  goalProgressSource: String
  goalTimeperiod: String
  goalUpdatemethod: String
  priority: String
  sectionRule: String
  staffId: Int
  taskId: BigInt
  ticketId: BigInt
  customers: String
  tasks: String
  ticketing: String
  users: String
  workspaces: String
  tags: String
  product: String
  websites: String
  method: String
  zone: String
  type: String
  team: String
  categories: String
  company: String
  file: String
}

"""All input for the `updateProject` mutation."""
input UpdateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  patch: ProjectPatch!
  id: BigInt!
}

"""The output of our update `Provider` mutation."""
type UpdateProviderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Provider` that was updated by this mutation."""
  provider: Provider

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Provider`. May be used by Relay 1."""
  providerEdge(
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProvidersEdge
}

"""All input for the `updateProviderByNodeId` mutation."""
input UpdateProviderByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Provider` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Provider` being updated.
  """
  patch: ProviderPatch!
}

"""
Represents an update to a `Provider`. Fields that are set will be updated.
"""
input ProviderPatch {
  id: BigInt
  createdAt: Datetime
  clientId: String
  clientSecret: String
  hostUri: String
  redirectUrl: String
  redirectUrlApp: String
  icon: String
  name: String
  active: String
}

"""All input for the `updateProvider` mutation."""
input UpdateProviderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Provider` being updated.
  """
  patch: ProviderPatch!
  id: BigInt!
}

"""The output of our update `Quote` mutation."""
type UpdateQuotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Quote` that was updated by this mutation."""
  quote: Quote

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Quote`. May be used by Relay 1."""
  quoteEdge(
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): QuotesEdge
}

"""All input for the `updateQuoteByNodeId` mutation."""
input UpdateQuoteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Quote` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Quote` being updated.
  """
  patch: QuotePatch!
}

"""
Represents an update to a `Quote`. Fields that are set will be updated.
"""
input QuotePatch {
  id: Int
  name: String
  grandTotal: String
  createdAt: Datetime
  categories: String
  validUntil: String
  quoteStage: String
  customers: String
  custId: Int
  prodId: BigInt
  orderId: Int
  account: String
  approvalIssues: String
  approvalStatus: String
  assignedTo: String
  billingCity: String
  billingCountry: String
  billingPostal: String
  billingState: String
  billingStreet: String
  contact: String
  currency: String
  discount: String
  invoiceStatus: String
  lineItemDiscount: String
  lineItemGroupTotal: String
  lineItemName: String
  lineItemSubtotal: String
  lineItemTax: String
  lineItemTotal: String
  paymentTerms: String
  shipping: String
  shippingCity: String
  shippingCountry: String
  shippingPostal: String
  shippingState: String
  shippingStreet: String
  shippingTax: String
  subtotal: String
  tax: String
  total: String
  customersCustomersToquotes: String
  orders: String
  productsProductsToquotes: String
}

"""All input for the `updateQuote` mutation."""
input UpdateQuoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Quote` being updated.
  """
  patch: QuotePatch!
  id: Int!
}

"""The output of our update `Return` mutation."""
type UpdateReturnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Return` that was updated by this mutation."""
  return: Return

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Return`. May be used by Relay 1."""
  returnEdge(
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReturnsEdge
}

"""All input for the `updateReturnByNodeId` mutation."""
input UpdateReturnByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Return` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Return` being updated.
  """
  patch: ReturnPatch!
}

"""
Represents an update to a `Return`. Fields that are set will be updated.
"""
input ReturnPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  validity: String
  returnPrefix: String
  customers: String
  products: String
  type: String
  description: String
  shippingNumber: String
  shippingDescription: String
  status: String
  liquidationReason: String
  media: String
  weight: String
  height: String
  howShipped: String
  location: String
  shipTo: String
  caseId: String
}

"""All input for the `updateReturn` mutation."""
input UpdateReturnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Return` being updated.
  """
  patch: ReturnPatch!
  id: BigInt!
}

"""The output of our update `Review` mutation."""
type UpdateReviewPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Review` that was updated by this mutation."""
  review: Review

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Review`. May be used by Relay 1."""
  reviewEdge(
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReviewsEdge
}

"""All input for the `updateReviewByNodeId` mutation."""
input UpdateReviewByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Review` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Review` being updated.
  """
  patch: ReviewPatch!
}

"""
Represents an update to a `Review`. Fields that are set will be updated.
"""
input ReviewPatch {
  id: Int
  firstName: String
  lastName: String
  content: String
  websites: String
  createdAt: Datetime
  shopId: Int
  commentId: Int
}

"""All input for the `updateReview` mutation."""
input UpdateReviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Review` being updated.
  """
  patch: ReviewPatch!
  id: Int!
}

"""The output of our update `Reward` mutation."""
type UpdateRewardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Reward` that was updated by this mutation."""
  reward: Reward

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Reward`. May be used by Relay 1."""
  rewardEdge(
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RewardsEdge
}

"""All input for the `updateRewardByNodeId` mutation."""
input UpdateRewardByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Reward` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Reward` being updated.
  """
  patch: RewardPatch!
}

"""
Represents an update to a `Reward`. Fields that are set will be updated.
"""
input RewardPatch {
  id: Int
  name: String
  slug: String
  level: String
  createdAt: Datetime
  coupons: String
  expiration: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""All input for the `updateReward` mutation."""
input UpdateRewardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Reward` being updated.
  """
  patch: RewardPatch!
  id: Int!
}

"""The output of our update `Role` mutation."""
type UpdateRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Role` that was updated by this mutation."""
  role: Role

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Role`. May be used by Relay 1."""
  roleEdge(
    """The method to use when ordering `Role`."""
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesEdge
}

"""All input for the `updateRoleByNodeId` mutation."""
input UpdateRoleByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Role` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Role` being updated.
  """
  patch: RolePatch!
}

"""Represents an update to a `Role`. Fields that are set will be updated."""
input RolePatch {
  id: Int
  roleName: String
  content: String
  createdAt: Datetime
}

"""All input for the `updateRole` mutation."""
input UpdateRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Role` being updated.
  """
  patch: RolePatch!
  id: Int!
}

"""The output of our update `Scheduler` mutation."""
type UpdateSchedulerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Scheduler` that was updated by this mutation."""
  scheduler: Scheduler

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Scheduler`. May be used by Relay 1."""
  schedulerEdge(
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SchedulersEdge
}

"""All input for the `updateSchedulerByNodeId` mutation."""
input UpdateSchedulerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Scheduler` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Scheduler` being updated.
  """
  patch: SchedulerPatch!
}

"""
Represents an update to a `Scheduler`. Fields that are set will be updated.
"""
input SchedulerPatch {
  id: BigInt
  createdAt: Datetime
  endDate: String
  level: String
  login: String
  notes: String
  startDate: String
  whid: String
  label: String
  public: String
  permission: String
  name: String
}

"""All input for the `updateScheduler` mutation."""
input UpdateSchedulerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Scheduler` being updated.
  """
  patch: SchedulerPatch!
  id: BigInt!
}

"""The output of our update `Segment` mutation."""
type UpdateSegmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Segment` that was updated by this mutation."""
  segment: Segment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Segment`. May be used by Relay 1."""
  segmentEdge(
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SegmentsEdge
}

"""All input for the `updateSegmentByNodeId` mutation."""
input UpdateSegmentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Segment` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Segment` being updated.
  """
  patch: SegmentPatch!
}

"""
Represents an update to a `Segment`. Fields that are set will be updated.
"""
input SegmentPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  website: String
  status: String
  applyTo: String
  customers: String
}

"""All input for the `updateSegment` mutation."""
input UpdateSegmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Segment` being updated.
  """
  patch: SegmentPatch!
  id: BigInt!
}

"""The output of our update `Setting` mutation."""
type UpdateSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Setting` that was updated by this mutation."""
  setting: Setting

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsEdge
}

"""All input for the `updateSettingByNodeId` mutation."""
input UpdateSettingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Setting` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Setting` being updated.
  """
  patch: SettingPatch!
}

"""
Represents an update to a `Setting`. Fields that are set will be updated.
"""
input SettingPatch {
  id: BigInt
  createdAt: Datetime
  storeName: String
  storePhone: String
  storeHours: String
  country: String
  region: String
  zipcode: String
  city: String
  address: String
  addressTwo: String
  vatNumber: String
  allowState: String
  stateRequiredFor: String
  allowCountries: String
  defaultCountry: String
  optionalZip: String
  europeanUnionCountries: String
  topDestinations: String
  baseCurrency: String
  defaultCurrency: String
  allowedCurrency: String
  siteName: String
  siteWebsite: String
  sentryDsn: String
  awsS3: String
  databaseUrl: String
  isPublic: String
  type: String
  googleAnalytics: String
  searchSetting: String
  mailServer: String
  siteTagline: String
}

"""All input for the `updateSetting` mutation."""
input UpdateSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Setting` being updated.
  """
  patch: SettingPatch!
  id: BigInt!
}

"""The output of our update `Shipment` mutation."""
type UpdateShipmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Shipment` that was updated by this mutation."""
  shipment: Shipment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Shipment`. May be used by Relay 1."""
  shipmentEdge(
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShipmentsEdge
}

"""All input for the `updateShipmentByNodeId` mutation."""
input UpdateShipmentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Shipment` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Shipment` being updated.
  """
  patch: ShipmentPatch!
}

"""
Represents an update to a `Shipment`. Fields that are set will be updated.
"""
input ShipmentPatch {
  product: String
  speedGrade: String
  shipDate: Datetime
  carrierName: String
  transitTime: String
  trackingUrl: String
  image: String
  id: BigInt
  clientId: String
  clientSecret: String
  country: String
  website: String
}

"""All input for the `updateShipment` mutation."""
input UpdateShipmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Shipment` being updated.
  """
  patch: ShipmentPatch!
  id: BigInt!
}

"""The output of our update `State` mutation."""
type UpdateStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `State` that was updated by this mutation."""
  state: State

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `State`. May be used by Relay 1."""
  stateEdge(
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatesEdge
}

"""All input for the `updateStateByNodeId` mutation."""
input UpdateStateByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `State` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `State` being updated.
  """
  patch: StatePatch!
}

"""
Represents an update to a `State`. Fields that are set will be updated.
"""
input StatePatch {
  id: Int
  name: String
  description: String
  country: String
  image: String
  trainings: String
}

"""All input for the `updateState` mutation."""
input UpdateStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `State` being updated.
  """
  patch: StatePatch!
  id: Int!
}

"""The output of our update `Tag` mutation."""
type UpdateTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Tag` that was updated by this mutation."""
  tag: Tag

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsEdge
}

"""All input for the `updateTagByNodeId` mutation."""
input UpdateTagByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Tag` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Tag` being updated.
  """
  patch: TagPatch!
}

"""Represents an update to a `Tag`. Fields that are set will be updated."""
input TagPatch {
  id: Int
  name: String
  excerpt: String
  categories: String
  articles: String
  products: String
  customers: String
  users: String
}

"""All input for the `updateTag` mutation."""
input UpdateTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Tag` being updated.
  """
  patch: TagPatch!
  id: Int!
}

"""The output of our update `Tax` mutation."""
type UpdateTaxPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Tax` that was updated by this mutation."""
  tax: Tax

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Tax`. May be used by Relay 1."""
  taxEdge(
    """The method to use when ordering `Tax`."""
    orderBy: [TaxesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxesEdge
}

"""All input for the `updateTaxByNodeId` mutation."""
input UpdateTaxByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Tax` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Tax` being updated.
  """
  patch: TaxPatch!
}

"""Represents an update to a `Tax`. Fields that are set will be updated."""
input TaxPatch {
  id: Int
  taxIdentifier: String
  postcode: String
  state: String
  country: String
  ratePercent: String
  taxDefault: String
  products: String
  taxRuleName: String
  taxCategory: String
}

"""All input for the `updateTax` mutation."""
input UpdateTaxInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Tax` being updated.
  """
  patch: TaxPatch!
  id: Int!
}

"""The output of our update `Theme` mutation."""
type UpdateThemePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Theme` that was updated by this mutation."""
  theme: Theme

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Theme`. May be used by Relay 1."""
  themeEdge(
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ThemesEdge
}

"""All input for the `updateThemeByNodeId` mutation."""
input UpdateThemeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Theme` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Theme` being updated.
  """
  patch: ThemePatch!
}

"""
Represents an update to a `Theme`. Fields that are set will be updated.
"""
input ThemePatch {
  id: Int
  title: String
  parentTheme: String
  themePath: String
  action: String
  websiteId: BigInt
  websites: String
}

"""All input for the `updateTheme` mutation."""
input UpdateThemeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Theme` being updated.
  """
  patch: ThemePatch!
  id: Int!
}

"""The output of our update `Ticketing` mutation."""
type UpdateTicketingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ticketing` that was updated by this mutation."""
  ticketing: Ticketing

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Ticketing`. May be used by Relay 1."""
  ticketingEdge(
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TicketingsEdge
}

"""All input for the `updateTicketingByNodeId` mutation."""
input UpdateTicketingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Ticketing` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Ticketing` being updated.
  """
  patch: TicketingPatch!
}

"""
Represents an update to a `Ticketing`. Fields that are set will be updated.
"""
input TicketingPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  location: String
  date: String
  severity: String
  team: String
  requester: String
  requesterEmail: String
  content: String
  department: String
  media: String
  projects: String
  ticketType: String
  comment: String
  products: String
  priority: String
  status: String
  resolution: String
  assignedTo: String
  dateModified: Datetime
  accountName: String
  level: String
  projectsProjectsToticketing: String
}

"""All input for the `updateTicketing` mutation."""
input UpdateTicketingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Ticketing` being updated.
  """
  patch: TicketingPatch!
  id: BigInt!
}

"""The output of our update `Transaction` mutation."""
type UpdateTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transaction` that was updated by this mutation."""
  transaction: Transaction

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""All input for the `updateTransactionByNodeId` mutation."""
input UpdateTransactionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Transaction` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Transaction` being updated.
  """
  patch: TransactionPatch!
}

"""
Represents an update to a `Transaction`. Fields that are set will be updated.
"""
input TransactionPatch {
  id: Int
  orderId: Int
  transactionId: Int
  parentTransactionId: Int
  created: Datetime
  paymentMethod: BigInt
  closed: String
  customerPayment: String
  orders: String
}

"""All input for the `updateTransaction` mutation."""
input UpdateTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Transaction` being updated.
  """
  patch: TransactionPatch!
  id: Int!
}

"""The output of our update `UploadFile` mutation."""
type UpdateUploadFilePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UploadFile` that was updated by this mutation."""
  uploadFile: UploadFile

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UploadFile`. May be used by Relay 1."""
  uploadFileEdge(
    """The method to use when ordering `UploadFile`."""
    orderBy: [UploadFilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UploadFilesEdge
}

"""All input for the `updateUploadFileByNodeId` mutation."""
input UpdateUploadFileByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UploadFile` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UploadFile` being updated.
  """
  patch: UploadFilePatch!
}

"""
Represents an update to a `UploadFile`. Fields that are set will be updated.
"""
input UploadFilePatch {
  id: Int
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: BigFloat
  url: String
  previewUrl: String
  provider: String
  providerMetadata: JSON
  createdBy: Int
  updatedBy: Int
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateUploadFile` mutation."""
input UpdateUploadFileInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UploadFile` being updated.
  """
  patch: UploadFilePatch!
  id: Int!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUserByNodeId` mutation."""
input UpdateUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  id: BigInt
  username: String
  firstName: String
  lastName: String
  email: String
  password: String
  interfaceLocale: String
  value: String
  permissions: String
  createdAt: Datetime
  emails: String
  mediamanager: String
  messages: String
  projects: String
  workspaces: String
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
  id: BigInt!
}

"""The output of our update `Vendor` mutation."""
type UpdateVendorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Vendor` that was updated by this mutation."""
  vendor: Vendor

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Vendor`. May be used by Relay 1."""
  vendorEdge(
    """The method to use when ordering `Vendor`."""
    orderBy: [VendorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VendorsEdge
}

"""All input for the `updateVendorByNodeId` mutation."""
input UpdateVendorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Vendor` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Vendor` being updated.
  """
  patch: VendorPatch!
}

"""
Represents an update to a `Vendor`. Fields that are set will be updated.
"""
input VendorPatch {
  id: Int
  name: String
  description: String
  image: String
  website: String
  products: String
  articles: String
  customers: String
  comments: String
  coupons: String
  categories: String
  polls: String
  quotes: String
  reviews: String
  giftCertificates: String
  rating: String
  tags: String
  users: String
  invoices: String
  reports: String
  rewardPoints: String
  specialDiscounts: String
  statistics: String
  stocks: String
  country: String
  physicalStore: String
  type: String
  workspaces: String
}

"""All input for the `updateVendor` mutation."""
input UpdateVendorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Vendor` being updated.
  """
  patch: VendorPatch!
  id: Int!
}

"""The output of our update `Visit` mutation."""
type UpdateVisitPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Visit` that was updated by this mutation."""
  visit: Visit

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Visit`. May be used by Relay 1."""
  visitEdge(
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VisitsEdge
}

"""All input for the `updateVisitByNodeId` mutation."""
input UpdateVisitByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Visit` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Visit` being updated.
  """
  patch: VisitPatch!
}

"""
Represents an update to a `Visit`. Fields that are set will be updated.
"""
input VisitPatch {
  id: BigInt
  createdAt: Datetime
  location: String
  username: String
  reason: String
  content: String
  emergency: String
  startDate: String
  endDate: String
  task: String
  meeting: String
}

"""All input for the `updateVisit` mutation."""
input UpdateVisitInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Visit` being updated.
  """
  patch: VisitPatch!
  id: BigInt!
}

"""The output of our update `Warehouse` mutation."""
type UpdateWarehousePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Warehouse` that was updated by this mutation."""
  warehouse: Warehouse

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Warehouse`. May be used by Relay 1."""
  warehouseEdge(
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WarehousesEdge
}

"""All input for the `updateWarehouseByNodeId` mutation."""
input UpdateWarehouseByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Warehouse` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Warehouse` being updated.
  """
  patch: WarehousePatch!
}

"""
Represents an update to a `Warehouse`. Fields that are set will be updated.
"""
input WarehousePatch {
  id: BigInt
  createdAt: Datetime
  name: String
  description: String
  city: String
  state: String
  country: String
  postal: String
  status: String
  image: String
  products: String
  category: String
  isPublic: String
}

"""All input for the `updateWarehouse` mutation."""
input UpdateWarehouseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Warehouse` being updated.
  """
  patch: WarehousePatch!
  id: BigInt!
}

"""The output of our update `Webhook` mutation."""
type UpdateWebhookPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Webhook` that was updated by this mutation."""
  webhook: Webhook

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Webhook`. May be used by Relay 1."""
  webhookEdge(
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhooksEdge
}

"""All input for the `updateWebhookByNodeId` mutation."""
input UpdateWebhookByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Webhook` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Webhook` being updated.
  """
  patch: WebhookPatch!
}

"""
Represents an update to a `Webhook`. Fields that are set will be updated.
"""
input WebhookPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  headers: String
  create: String
  retrieve: String
  update: String
  delete: String
  publish: String
  unpublish: String
}

"""All input for the `updateWebhook` mutation."""
input UpdateWebhookInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Webhook` being updated.
  """
  patch: WebhookPatch!
  id: BigInt!
}

"""The output of our update `Website` mutation."""
type UpdateWebsitePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Website` that was updated by this mutation."""
  website: Website

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Website`. May be used by Relay 1."""
  websiteEdge(
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebsitesEdge
}

"""All input for the `updateWebsiteByNodeId` mutation."""
input UpdateWebsiteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Website` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Website` being updated.
  """
  patch: WebsitePatch!
}

"""
Represents an update to a `Website`. Fields that are set will be updated.
"""
input WebsitePatch {
  id: BigInt
  createdAt: Datetime
  name: String
  url: String
  shop: String
  store: String
  category: String
  themes: String
  image: String
}

"""All input for the `updateWebsite` mutation."""
input UpdateWebsiteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Website` being updated.
  """
  patch: WebsitePatch!
  id: BigInt!
}

"""The output of our update `Wishlist` mutation."""
type UpdateWishlistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Wishlist` that was updated by this mutation."""
  wishlist: Wishlist

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Wishlist`. May be used by Relay 1."""
  wishlistEdge(
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): WishlistsEdge
}

"""All input for the `updateWishlistByNodeId` mutation."""
input UpdateWishlistByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Wishlist` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Wishlist` being updated.
  """
  patch: WishlistPatch!
}

"""
Represents an update to a `Wishlist`. Fields that are set will be updated.
"""
input WishlistPatch {
  id: BigInt
  createdAt: Datetime
  name: String
  customers: String
  visibility: String
  products: String
  quantity: String
  occassions: String
}

"""All input for the `updateWishlist` mutation."""
input UpdateWishlistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Wishlist` being updated.
  """
  patch: WishlistPatch!
  id: BigInt!
}

"""The output of our update `Workspace` mutation."""
type UpdateWorkspacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Workspace` that was updated by this mutation."""
  workspace: Workspace

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Workspace`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspacesEdge
}

"""All input for the `updateWorkspaceByNodeId` mutation."""
input UpdateWorkspaceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Workspace` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Workspace` being updated.
  """
  patch: WorkspacePatch!
}

"""
Represents an update to a `Workspace`. Fields that are set will be updated.
"""
input WorkspacePatch {
  id: BigInt
  createdAt: Datetime
  code: String
  name: String
  description: String
  customers: Int
  users: Int
  products: BigInt
  tasks: BigInt
  brands: BigInt
  shops: Int
  category: Int
  isPublic: Boolean
  projects: BigInt
  author: String
  media: String
  brandsBrandsToworkspaces: String
  categories: String
  customersCustomersToworkspaces: String
  productsProductsToworkspaces: String
  projectsProjectsToworkspaces: String
  shopsShopsToworkspaces: String
  tasksTasksToworkspaces: String
  usersUsersToworkspaces: String
}

"""All input for the `updateWorkspace` mutation."""
input UpdateWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Workspace` being updated.
  """
  patch: WorkspacePatch!
  id: BigInt!
}

"""The output of our update `Zone` mutation."""
type UpdateZonePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Zone` that was updated by this mutation."""
  zone: Zone

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Zone`. May be used by Relay 1."""
  zoneEdge(
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ZonesEdge
}

"""All input for the `updateZoneByNodeId` mutation."""
input UpdateZoneByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Zone` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Zone` being updated.
  """
  patch: ZonePatch!
}

"""Represents an update to a `Zone`. Fields that are set will be updated."""
input ZonePatch {
  id: BigInt
  createdAt: Datetime
  name: String
  updatedAt: Datetime
  scope: String
  type: String
  country: String
  code: String
}

"""All input for the `updateZone` mutation."""
input UpdateZoneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Zone` being updated.
  """
  patch: ZonePatch!
  id: BigInt!
}

"""The output of our delete `_PrismaMigration` mutation."""
type DeletePrismaMigrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `_PrismaMigration` that was deleted by this mutation."""
  _prismaMigration: _PrismaMigration
  deletedPrismaMigrationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `_PrismaMigration`. May be used by Relay 1."""
  _prismaMigrationEdge(
    """The method to use when ordering `_PrismaMigration`."""
    orderBy: [_PrismaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): _PrismaMigrationsEdge
}

"""All input for the `deletePrismaMigrationByNodeId` mutation."""
input DeletePrismaMigrationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `_PrismaMigration` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePrismaMigration` mutation."""
input DeletePrismaMigrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Agreement` mutation."""
type DeleteAgreementPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Agreement` that was deleted by this mutation."""
  agreement: Agreement
  deletedAgreementNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Agreement`. May be used by Relay 1."""
  agreementEdge(
    """The method to use when ordering `Agreement`."""
    orderBy: [AgreementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AgreementsEdge
}

"""All input for the `deleteAgreementByNodeId` mutation."""
input DeleteAgreementByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Agreement` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAgreement` mutation."""
input DeleteAgreementInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Apitoken` mutation."""
type DeleteApitokenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Apitoken` that was deleted by this mutation."""
  apitoken: Apitoken
  deletedApitokenNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Apitoken`. May be used by Relay 1."""
  apitokenEdge(
    """The method to use when ordering `Apitoken`."""
    orderBy: [ApitokensOrderBy!] = [PRIMARY_KEY_ASC]
  ): ApitokensEdge
}

"""All input for the `deleteApitokenByNodeId` mutation."""
input DeleteApitokenByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Apitoken` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteApitoken` mutation."""
input DeleteApitokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Article` mutation."""
type DeleteArticlePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Article` that was deleted by this mutation."""
  article: Article
  deletedArticleNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Article`. May be used by Relay 1."""
  articleEdge(
    """The method to use when ordering `Article`."""
    orderBy: [ArticlesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArticlesEdge
}

"""All input for the `deleteArticleByNodeId` mutation."""
input DeleteArticleByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Article` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteArticle` mutation."""
input DeleteArticleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Attribute` mutation."""
type DeleteAttributePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Attribute` that was deleted by this mutation."""
  attribute: Attribute
  deletedAttributeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Attribute`. May be used by Relay 1."""
  attributeEdge(
    """The method to use when ordering `Attribute`."""
    orderBy: [AttributesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AttributesEdge
}

"""All input for the `deleteAttributeByNodeId` mutation."""
input DeleteAttributeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Attribute` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAttribute` mutation."""
input DeleteAttributeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Brand` mutation."""
type DeleteBrandPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Brand` that was deleted by this mutation."""
  brand: Brand
  deletedBrandNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Brand`. May be used by Relay 1."""
  brandEdge(
    """The method to use when ordering `Brand`."""
    orderBy: [BrandsOrderBy!] = [PRIMARY_KEY_ASC]
  ): BrandsEdge
}

"""All input for the `deleteBrandByNodeId` mutation."""
input DeleteBrandByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Brand` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteBrand` mutation."""
input DeleteBrandInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Category` mutation."""
type DeleteCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Category` that was deleted by this mutation."""
  category: Category
  deletedCategoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Category`. May be used by Relay 1."""
  categoryEdge(
    """The method to use when ordering `Category`."""
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge
}

"""All input for the `deleteCategoryByNodeId` mutation."""
input DeleteCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Category` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCategory` mutation."""
input DeleteCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Channel` mutation."""
type DeleteChannelPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Channel` that was deleted by this mutation."""
  channel: Channel
  deletedChannelNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Channel`. May be used by Relay 1."""
  channelEdge(
    """The method to use when ordering `Channel`."""
    orderBy: [ChannelsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChannelsEdge
}

"""All input for the `deleteChannelByNodeId` mutation."""
input DeleteChannelByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Channel` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteChannel` mutation."""
input DeleteChannelInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Checklist` mutation."""
type DeleteChecklistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Checklist` that was deleted by this mutation."""
  checklist: Checklist
  deletedChecklistNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Checklist`. May be used by Relay 1."""
  checklistEdge(
    """The method to use when ordering `Checklist`."""
    orderBy: [ChecklistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ChecklistsEdge
}

"""All input for the `deleteChecklistByNodeId` mutation."""
input DeleteChecklistByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Checklist` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteChecklist` mutation."""
input DeleteChecklistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `City` mutation."""
type DeleteCityPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `City` that was deleted by this mutation."""
  city: City
  deletedCityNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `City`. May be used by Relay 1."""
  cityEdge(
    """The method to use when ordering `City`."""
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge
}

"""All input for the `deleteCityByNodeId` mutation."""
input DeleteCityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `City` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCity` mutation."""
input DeleteCityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Collection` mutation."""
type DeleteCollectionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Collection` that was deleted by this mutation."""
  collection: Collection
  deletedCollectionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Collection`. May be used by Relay 1."""
  collectionEdge(
    """The method to use when ordering `Collection`."""
    orderBy: [CollectionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CollectionsEdge
}

"""All input for the `deleteCollectionByNodeId` mutation."""
input DeleteCollectionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Collection` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCollection` mutation."""
input DeleteCollectionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ContentType` mutation."""
type DeleteContentTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ContentType` that was deleted by this mutation."""
  contentType: ContentType
  deletedContentTypeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ContentType`. May be used by Relay 1."""
  contentTypeEdge(
    """The method to use when ordering `ContentType`."""
    orderBy: [ContentTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContentTypesEdge
}

"""All input for the `deleteContentTypeByNodeId` mutation."""
input DeleteContentTypeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ContentType` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteContentType` mutation."""
input DeleteContentTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Country` mutation."""
type DeleteCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Country` that was deleted by this mutation."""
  country: Country
  deletedCountryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Country`. May be used by Relay 1."""
  countryEdge(
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge
}

"""All input for the `deleteCountryByNodeId` mutation."""
input DeleteCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Country` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCountry` mutation."""
input DeleteCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Currency` mutation."""
type DeleteCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Currency` that was deleted by this mutation."""
  currency: Currency
  deletedCurrencyNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
}

"""All input for the `deleteCurrencyByNodeId` mutation."""
input DeleteCurrencyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Currency` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCurrency` mutation."""
input DeleteCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Customer` mutation."""
type DeleteCustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Customer` that was deleted by this mutation."""
  customer: Customer
  deletedCustomerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Customer`. May be used by Relay 1."""
  customerEdge(
    """The method to use when ordering `Customer`."""
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersEdge
}

"""All input for the `deleteCustomerByNodeId` mutation."""
input DeleteCustomerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Customer` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCustomer` mutation."""
input DeleteCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Dashboard` mutation."""
type DeleteDashboardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Dashboard` that was deleted by this mutation."""
  dashboard: Dashboard
  deletedDashboardNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Dashboard`. May be used by Relay 1."""
  dashboardEdge(
    """The method to use when ordering `Dashboard`."""
    orderBy: [DashboardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DashboardsEdge
}

"""All input for the `deleteDashboardByNodeId` mutation."""
input DeleteDashboardByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Dashboard` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDashboard` mutation."""
input DeleteDashboardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""All input for the `deleteDashboardByName` mutation."""
input DeleteDashboardByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""The output of our delete `Deepdive` mutation."""
type DeleteDeepdivePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Deepdive` that was deleted by this mutation."""
  deepdive: Deepdive
  deletedDeepdiveNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Deepdive`. May be used by Relay 1."""
  deepdiveEdge(
    """The method to use when ordering `Deepdive`."""
    orderBy: [DeepdivesOrderBy!] = [PRIMARY_KEY_ASC]
  ): DeepdivesEdge
}

"""All input for the `deleteDeepdiveByNodeId` mutation."""
input DeleteDeepdiveByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Deepdive` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDeepdive` mutation."""
input DeleteDeepdiveInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Discount` mutation."""
type DeleteDiscountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Discount` that was deleted by this mutation."""
  discount: Discount
  deletedDiscountNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Discount`. May be used by Relay 1."""
  discountEdge(
    """The method to use when ordering `Discount`."""
    orderBy: [DiscountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DiscountsEdge
}

"""All input for the `deleteDiscountByNodeId` mutation."""
input DeleteDiscountByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Discount` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDiscount` mutation."""
input DeleteDiscountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Endofshift` mutation."""
type DeleteEndofshiftPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Endofshift` that was deleted by this mutation."""
  endofshift: Endofshift
  deletedEndofshiftNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Endofshift`. May be used by Relay 1."""
  endofshiftEdge(
    """The method to use when ordering `Endofshift`."""
    orderBy: [EndofshiftsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EndofshiftsEdge
}

"""All input for the `deleteEndofshiftByNodeId` mutation."""
input DeleteEndofshiftByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Endofshift` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteEndofshift` mutation."""
input DeleteEndofshiftInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Event` mutation."""
type DeleteEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Event` that was deleted by this mutation."""
  event: Event
  deletedEventNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Event`. May be used by Relay 1."""
  eventEdge(
    """The method to use when ordering `Event`."""
    orderBy: [EventsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EventsEdge
}

"""All input for the `deleteEventByNodeId` mutation."""
input DeleteEventByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Event` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteEvent` mutation."""
input DeleteEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Fullfillment` mutation."""
type DeleteFullfillmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Fullfillment` that was deleted by this mutation."""
  fullfillment: Fullfillment
  deletedFullfillmentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Fullfillment`. May be used by Relay 1."""
  fullfillmentEdge(
    """The method to use when ordering `Fullfillment`."""
    orderBy: [FullfillmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FullfillmentsEdge
}

"""All input for the `deleteFullfillmentByNodeId` mutation."""
input DeleteFullfillmentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Fullfillment` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteFullfillment` mutation."""
input DeleteFullfillmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Glossary` mutation."""
type DeleteGlossaryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Glossary` that was deleted by this mutation."""
  glossary: Glossary
  deletedGlossaryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Glossary`. May be used by Relay 1."""
  glossaryEdge(
    """The method to use when ordering `Glossary`."""
    orderBy: [GlossariesOrderBy!] = [PRIMARY_KEY_ASC]
  ): GlossariesEdge
}

"""All input for the `deleteGlossaryByNodeId` mutation."""
input DeleteGlossaryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Glossary` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGlossary` mutation."""
input DeleteGlossaryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Integration` mutation."""
type DeleteIntegrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Integration` that was deleted by this mutation."""
  integration: Integration
  deletedIntegrationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Integration`. May be used by Relay 1."""
  integrationEdge(
    """The method to use when ordering `Integration`."""
    orderBy: [IntegrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): IntegrationsEdge
}

"""All input for the `deleteIntegrationByNodeId` mutation."""
input DeleteIntegrationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Integration` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteIntegration` mutation."""
input DeleteIntegrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Internalization` mutation."""
type DeleteInternalizationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Internalization` that was deleted by this mutation."""
  internalization: Internalization
  deletedInternalizationNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Internalization`. May be used by Relay 1."""
  internalizationEdge(
    """The method to use when ordering `Internalization`."""
    orderBy: [InternalizationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): InternalizationsEdge
}

"""All input for the `deleteInternalizationByNodeId` mutation."""
input DeleteInternalizationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Internalization` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteInternalization` mutation."""
input DeleteInternalizationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Invoice` mutation."""
type DeleteInvoicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Invoice` that was deleted by this mutation."""
  invoice: Invoice
  deletedInvoiceNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Invoice`. May be used by Relay 1."""
  invoiceEdge(
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvoicesEdge
}

"""All input for the `deleteInvoiceByNodeId` mutation."""
input DeleteInvoiceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Invoice` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteInvoice` mutation."""
input DeleteInvoiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `LogIn` mutation."""
type DeleteLogInPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LogIn` that was deleted by this mutation."""
  logIn: LogIn
  deletedLogInNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `LogIn`. May be used by Relay 1."""
  logInEdge(
    """The method to use when ordering `LogIn`."""
    orderBy: [LogInsOrderBy!] = [PRIMARY_KEY_ASC]
  ): LogInsEdge
}

"""All input for the `deleteLogInByNodeId` mutation."""
input DeleteLogInByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LogIn` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLogIn` mutation."""
input DeleteLogInInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Manufacturer` mutation."""
type DeleteManufacturerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Manufacturer` that was deleted by this mutation."""
  manufacturer: Manufacturer
  deletedManufacturerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Manufacturer`. May be used by Relay 1."""
  manufacturerEdge(
    """The method to use when ordering `Manufacturer`."""
    orderBy: [ManufacturersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ManufacturersEdge
}

"""All input for the `deleteManufacturerByNodeId` mutation."""
input DeleteManufacturerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Manufacturer` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteManufacturer` mutation."""
input DeleteManufacturerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Mediamanager` mutation."""
type DeleteMediamanagerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Mediamanager` that was deleted by this mutation."""
  mediamanager: Mediamanager
  deletedMediamanagerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Mediamanager`. May be used by Relay 1."""
  mediamanagerEdge(
    """The method to use when ordering `Mediamanager`."""
    orderBy: [MediamanagersOrderBy!] = [PRIMARY_KEY_ASC]
  ): MediamanagersEdge
}

"""All input for the `deleteMediamanagerByNodeId` mutation."""
input DeleteMediamanagerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Mediamanager` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMediamanager` mutation."""
input DeleteMediamanagerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Newsletter` mutation."""
type DeleteNewsletterPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Newsletter` that was deleted by this mutation."""
  newsletter: Newsletter
  deletedNewsletterNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Newsletter`. May be used by Relay 1."""
  newsletterEdge(
    """The method to use when ordering `Newsletter`."""
    orderBy: [NewslettersOrderBy!] = [PRIMARY_KEY_ASC]
  ): NewslettersEdge
}

"""All input for the `deleteNewsletterByNodeId` mutation."""
input DeleteNewsletterByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Newsletter` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteNewsletter` mutation."""
input DeleteNewsletterInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Ooto` mutation."""
type DeleteOotoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ooto` that was deleted by this mutation."""
  ooto: Ooto
  deletedOotoNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Ooto`. May be used by Relay 1."""
  ootoEdge(
    """The method to use when ordering `Ooto`."""
    orderBy: [OotosOrderBy!] = [PRIMARY_KEY_ASC]
  ): OotosEdge
}

"""All input for the `deleteOotoByNodeId` mutation."""
input DeleteOotoByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Ooto` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteOoto` mutation."""
input DeleteOotoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Order` mutation."""
type DeleteOrderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Order` that was deleted by this mutation."""
  order: Order
  deletedOrderNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Order`. May be used by Relay 1."""
  orderEdge(
    """The method to use when ordering `Order`."""
    orderBy: [OrdersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrdersEdge
}

"""All input for the `deleteOrderByNodeId` mutation."""
input DeleteOrderByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Order` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteOrder` mutation."""
input DeleteOrderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Page` mutation."""
type DeletePagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Page` that was deleted by this mutation."""
  page: Page
  deletedPageNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Page`. May be used by Relay 1."""
  pageEdge(
    """The method to use when ordering `Page`."""
    orderBy: [PagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PagesEdge
}

"""All input for the `deletePageByNodeId` mutation."""
input DeletePageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Page` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePage` mutation."""
input DeletePageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Partner` mutation."""
type DeletePartnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Partner` that was deleted by this mutation."""
  partner: Partner
  deletedPartnerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Partner`. May be used by Relay 1."""
  partnerEdge(
    """The method to use when ordering `Partner`."""
    orderBy: [PartnersOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnersEdge
}

"""All input for the `deletePartnerByNodeId` mutation."""
input DeletePartnerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Partner` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePartner` mutation."""
input DeletePartnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Payment` mutation."""
type DeletePaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Payment` that was deleted by this mutation."""
  payment: Payment
  deletedPaymentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Payment`. May be used by Relay 1."""
  paymentEdge(
    """The method to use when ordering `Payment`."""
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsEdge
}

"""All input for the `deletePaymentByNodeId` mutation."""
input DeletePaymentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Payment` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePayment` mutation."""
input DeletePaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Permission` mutation."""
type DeletePermissionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Permission` that was deleted by this mutation."""
  permission: Permission
  deletedPermissionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Permission`. May be used by Relay 1."""
  permissionEdge(
    """The method to use when ordering `Permission`."""
    orderBy: [PermissionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PermissionsEdge
}

"""All input for the `deletePermissionByNodeId` mutation."""
input DeletePermissionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Permission` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePermission` mutation."""
input DeletePermissionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Plugin` mutation."""
type DeletePluginPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Plugin` that was deleted by this mutation."""
  plugin: Plugin
  deletedPluginNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Plugin`. May be used by Relay 1."""
  pluginEdge(
    """The method to use when ordering `Plugin`."""
    orderBy: [PluginsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PluginsEdge
}

"""All input for the `deletePluginByNodeId` mutation."""
input DeletePluginByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Plugin` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePlugin` mutation."""
input DeletePluginInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ProductType` mutation."""
type DeleteProductTypePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProductType` that was deleted by this mutation."""
  productType: ProductType
  deletedProductTypeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ProductType`. May be used by Relay 1."""
  productTypeEdge(
    """The method to use when ordering `ProductType`."""
    orderBy: [ProductTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductTypesEdge
}

"""All input for the `deleteProductTypeByNodeId` mutation."""
input DeleteProductTypeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProductType` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteProductType` mutation."""
input DeleteProductTypeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Product` mutation."""
type DeleteProductPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Product` that was deleted by this mutation."""
  product: Product
  deletedProductNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Product`. May be used by Relay 1."""
  productEdge(
    """The method to use when ordering `Product`."""
    orderBy: [ProductsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProductsEdge
}

"""All input for the `deleteProductByNodeId` mutation."""
input DeleteProductByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Product` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteProduct` mutation."""
input DeleteProductInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Project` mutation."""
type DeleteProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was deleted by this mutation."""
  project: Project
  deletedProjectNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""All input for the `deleteProjectByNodeId` mutation."""
input DeleteProjectByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteProject` mutation."""
input DeleteProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Provider` mutation."""
type DeleteProviderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Provider` that was deleted by this mutation."""
  provider: Provider
  deletedProviderNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Provider`. May be used by Relay 1."""
  providerEdge(
    """The method to use when ordering `Provider`."""
    orderBy: [ProvidersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProvidersEdge
}

"""All input for the `deleteProviderByNodeId` mutation."""
input DeleteProviderByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Provider` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteProvider` mutation."""
input DeleteProviderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Quote` mutation."""
type DeleteQuotePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Quote` that was deleted by this mutation."""
  quote: Quote
  deletedQuoteNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Quote`. May be used by Relay 1."""
  quoteEdge(
    """The method to use when ordering `Quote`."""
    orderBy: [QuotesOrderBy!] = [PRIMARY_KEY_ASC]
  ): QuotesEdge
}

"""All input for the `deleteQuoteByNodeId` mutation."""
input DeleteQuoteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Quote` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteQuote` mutation."""
input DeleteQuoteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Return` mutation."""
type DeleteReturnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Return` that was deleted by this mutation."""
  return: Return
  deletedReturnNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Return`. May be used by Relay 1."""
  returnEdge(
    """The method to use when ordering `Return`."""
    orderBy: [ReturnsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReturnsEdge
}

"""All input for the `deleteReturnByNodeId` mutation."""
input DeleteReturnByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Return` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteReturn` mutation."""
input DeleteReturnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Review` mutation."""
type DeleteReviewPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Review` that was deleted by this mutation."""
  review: Review
  deletedReviewNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Review`. May be used by Relay 1."""
  reviewEdge(
    """The method to use when ordering `Review`."""
    orderBy: [ReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReviewsEdge
}

"""All input for the `deleteReviewByNodeId` mutation."""
input DeleteReviewByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Review` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteReview` mutation."""
input DeleteReviewInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Reward` mutation."""
type DeleteRewardPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Reward` that was deleted by this mutation."""
  reward: Reward
  deletedRewardNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Reward`. May be used by Relay 1."""
  rewardEdge(
    """The method to use when ordering `Reward`."""
    orderBy: [RewardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RewardsEdge
}

"""All input for the `deleteRewardByNodeId` mutation."""
input DeleteRewardByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Reward` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteReward` mutation."""
input DeleteRewardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Role` mutation."""
type DeleteRolePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Role` that was deleted by this mutation."""
  role: Role
  deletedRoleNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Role`. May be used by Relay 1."""
  roleEdge(
    """The method to use when ordering `Role`."""
    orderBy: [RolesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RolesEdge
}

"""All input for the `deleteRoleByNodeId` mutation."""
input DeleteRoleByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Role` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteRole` mutation."""
input DeleteRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Scheduler` mutation."""
type DeleteSchedulerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Scheduler` that was deleted by this mutation."""
  scheduler: Scheduler
  deletedSchedulerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Scheduler`. May be used by Relay 1."""
  schedulerEdge(
    """The method to use when ordering `Scheduler`."""
    orderBy: [SchedulersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SchedulersEdge
}

"""All input for the `deleteSchedulerByNodeId` mutation."""
input DeleteSchedulerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Scheduler` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteScheduler` mutation."""
input DeleteSchedulerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Segment` mutation."""
type DeleteSegmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Segment` that was deleted by this mutation."""
  segment: Segment
  deletedSegmentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Segment`. May be used by Relay 1."""
  segmentEdge(
    """The method to use when ordering `Segment`."""
    orderBy: [SegmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SegmentsEdge
}

"""All input for the `deleteSegmentByNodeId` mutation."""
input DeleteSegmentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Segment` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSegment` mutation."""
input DeleteSegmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Setting` mutation."""
type DeleteSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Setting` that was deleted by this mutation."""
  setting: Setting
  deletedSettingNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsEdge
}

"""All input for the `deleteSettingByNodeId` mutation."""
input DeleteSettingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Setting` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSetting` mutation."""
input DeleteSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Shipment` mutation."""
type DeleteShipmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Shipment` that was deleted by this mutation."""
  shipment: Shipment
  deletedShipmentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Shipment`. May be used by Relay 1."""
  shipmentEdge(
    """The method to use when ordering `Shipment`."""
    orderBy: [ShipmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ShipmentsEdge
}

"""All input for the `deleteShipmentByNodeId` mutation."""
input DeleteShipmentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Shipment` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteShipment` mutation."""
input DeleteShipmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `State` mutation."""
type DeleteStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `State` that was deleted by this mutation."""
  state: State
  deletedStateNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `State`. May be used by Relay 1."""
  stateEdge(
    """The method to use when ordering `State`."""
    orderBy: [StatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StatesEdge
}

"""All input for the `deleteStateByNodeId` mutation."""
input DeleteStateByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `State` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteState` mutation."""
input DeleteStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Tag` mutation."""
type DeleteTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Tag` that was deleted by this mutation."""
  tag: Tag
  deletedTagNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsEdge
}

"""All input for the `deleteTagByNodeId` mutation."""
input DeleteTagByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Tag` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTag` mutation."""
input DeleteTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Tax` mutation."""
type DeleteTaxPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Tax` that was deleted by this mutation."""
  tax: Tax
  deletedTaxNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Tax`. May be used by Relay 1."""
  taxEdge(
    """The method to use when ordering `Tax`."""
    orderBy: [TaxesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TaxesEdge
}

"""All input for the `deleteTaxByNodeId` mutation."""
input DeleteTaxByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Tax` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTax` mutation."""
input DeleteTaxInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Theme` mutation."""
type DeleteThemePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Theme` that was deleted by this mutation."""
  theme: Theme
  deletedThemeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Theme`. May be used by Relay 1."""
  themeEdge(
    """The method to use when ordering `Theme`."""
    orderBy: [ThemesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ThemesEdge
}

"""All input for the `deleteThemeByNodeId` mutation."""
input DeleteThemeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Theme` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTheme` mutation."""
input DeleteThemeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Ticketing` mutation."""
type DeleteTicketingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Ticketing` that was deleted by this mutation."""
  ticketing: Ticketing
  deletedTicketingNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Ticketing`. May be used by Relay 1."""
  ticketingEdge(
    """The method to use when ordering `Ticketing`."""
    orderBy: [TicketingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TicketingsEdge
}

"""All input for the `deleteTicketingByNodeId` mutation."""
input DeleteTicketingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Ticketing` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTicketing` mutation."""
input DeleteTicketingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Transaction` mutation."""
type DeleteTransactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transaction` that was deleted by this mutation."""
  transaction: Transaction
  deletedTransactionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Transaction`. May be used by Relay 1."""
  transactionEdge(
    """The method to use when ordering `Transaction`."""
    orderBy: [TransactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TransactionsEdge
}

"""All input for the `deleteTransactionByNodeId` mutation."""
input DeleteTransactionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Transaction` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTransaction` mutation."""
input DeleteTransactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `UploadFile` mutation."""
type DeleteUploadFilePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `UploadFile` that was deleted by this mutation."""
  uploadFile: UploadFile
  deletedUploadFileNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `UploadFile`. May be used by Relay 1."""
  uploadFileEdge(
    """The method to use when ordering `UploadFile`."""
    orderBy: [UploadFilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UploadFilesEdge
}

"""All input for the `deleteUploadFileByNodeId` mutation."""
input DeleteUploadFileByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UploadFile` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUploadFile` mutation."""
input DeleteUploadFileInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `deleteUserByNodeId` mutation."""
input DeleteUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Vendor` mutation."""
type DeleteVendorPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Vendor` that was deleted by this mutation."""
  vendor: Vendor
  deletedVendorNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Vendor`. May be used by Relay 1."""
  vendorEdge(
    """The method to use when ordering `Vendor`."""
    orderBy: [VendorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VendorsEdge
}

"""All input for the `deleteVendorByNodeId` mutation."""
input DeleteVendorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Vendor` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVendor` mutation."""
input DeleteVendorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"""The output of our delete `Visit` mutation."""
type DeleteVisitPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Visit` that was deleted by this mutation."""
  visit: Visit
  deletedVisitNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Visit`. May be used by Relay 1."""
  visitEdge(
    """The method to use when ordering `Visit`."""
    orderBy: [VisitsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VisitsEdge
}

"""All input for the `deleteVisitByNodeId` mutation."""
input DeleteVisitByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Visit` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVisit` mutation."""
input DeleteVisitInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Warehouse` mutation."""
type DeleteWarehousePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Warehouse` that was deleted by this mutation."""
  warehouse: Warehouse
  deletedWarehouseNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Warehouse`. May be used by Relay 1."""
  warehouseEdge(
    """The method to use when ordering `Warehouse`."""
    orderBy: [WarehousesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WarehousesEdge
}

"""All input for the `deleteWarehouseByNodeId` mutation."""
input DeleteWarehouseByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Warehouse` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteWarehouse` mutation."""
input DeleteWarehouseInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Webhook` mutation."""
type DeleteWebhookPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Webhook` that was deleted by this mutation."""
  webhook: Webhook
  deletedWebhookNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Webhook`. May be used by Relay 1."""
  webhookEdge(
    """The method to use when ordering `Webhook`."""
    orderBy: [WebhooksOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebhooksEdge
}

"""All input for the `deleteWebhookByNodeId` mutation."""
input DeleteWebhookByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Webhook` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteWebhook` mutation."""
input DeleteWebhookInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Website` mutation."""
type DeleteWebsitePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Website` that was deleted by this mutation."""
  website: Website
  deletedWebsiteNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Website`. May be used by Relay 1."""
  websiteEdge(
    """The method to use when ordering `Website`."""
    orderBy: [WebsitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WebsitesEdge
}

"""All input for the `deleteWebsiteByNodeId` mutation."""
input DeleteWebsiteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Website` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteWebsite` mutation."""
input DeleteWebsiteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Wishlist` mutation."""
type DeleteWishlistPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Wishlist` that was deleted by this mutation."""
  wishlist: Wishlist
  deletedWishlistNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Wishlist`. May be used by Relay 1."""
  wishlistEdge(
    """The method to use when ordering `Wishlist`."""
    orderBy: [WishlistsOrderBy!] = [PRIMARY_KEY_ASC]
  ): WishlistsEdge
}

"""All input for the `deleteWishlistByNodeId` mutation."""
input DeleteWishlistByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Wishlist` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteWishlist` mutation."""
input DeleteWishlistInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Workspace` mutation."""
type DeleteWorkspacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Workspace` that was deleted by this mutation."""
  workspace: Workspace
  deletedWorkspaceNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Workspace`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspacesEdge
}

"""All input for the `deleteWorkspaceByNodeId` mutation."""
input DeleteWorkspaceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Workspace` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteWorkspace` mutation."""
input DeleteWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Zone` mutation."""
type DeleteZonePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Zone` that was deleted by this mutation."""
  zone: Zone
  deletedZoneNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Zone`. May be used by Relay 1."""
  zoneEdge(
    """The method to use when ordering `Zone`."""
    orderBy: [ZonesOrderBy!] = [PRIMARY_KEY_ASC]
  ): ZonesEdge
}

"""All input for the `deleteZoneByNodeId` mutation."""
input DeleteZoneByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Zone` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteZone` mutation."""
input DeleteZoneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}
